function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n2)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n2, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var dist$e = {};
var dist$d = {};
function OrderedMap$e(content2) {
  this.content = content2;
}
OrderedMap$e.prototype = {
  constructor: OrderedMap$e,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$e(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$e(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$e([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$e(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$e(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$e.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$e(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$e.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$e(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$e.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$e.from = function(value) {
  if (value instanceof OrderedMap$e)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$e(content2);
};
var orderedmap$6 = OrderedMap$e;
Object.defineProperty(dist$d, "__esModule", { value: true });
function _interopDefault$a(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$d = _interopDefault$a(orderedmap$6);
function findDiffStart$7(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$7(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$7(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$7(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$7 = function Fragment(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$c = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$7.prototype.nodesBetween = function nodesBetween(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$7.prototype.descendants = function descendants(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$7.prototype.textBetween = function textBetween(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$7.prototype.append = function append(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$7(content2, this.size + other.size);
};
Fragment$7.prototype.cut = function cut(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$7(result2, size);
};
Fragment$7.prototype.cutByIndex = function cutByIndex(from12, to) {
  if (from12 == to) {
    return Fragment$7.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$7(this.content.slice(from12, to));
};
Fragment$7.prototype.replaceChild = function replaceChild(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$7(copy12, size);
};
Fragment$7.prototype.addToStart = function addToStart(node18) {
  return new Fragment$7([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$7.prototype.addToEnd = function addToEnd(node18) {
  return new Fragment$7(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$7.prototype.eq = function eq(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$c.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$c.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$c.childCount.get = function() {
  return this.content.length;
};
Fragment$7.prototype.child = function child(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$7.prototype.maybeChild = function maybeChild(index8) {
  return this.content[index8];
};
Fragment$7.prototype.forEach = function forEach(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$7.prototype.findDiffStart = function findDiffStart$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$7(this, other, pos);
};
Fragment$7.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$7(this, other, pos, otherPos);
};
Fragment$7.prototype.findIndex = function findIndex(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$7(0, pos);
  }
  if (pos == this.size) {
    return retIndex$7(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$7(i + 1, end8);
      }
      return retIndex$7(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$7.prototype.toString = function toString() {
  return "<" + this.toStringInner() + ">";
};
Fragment$7.prototype.toStringInner = function toStringInner() {
  return this.content.join(", ");
};
Fragment$7.prototype.toJSON = function toJSON() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$7.fromJSON = function fromJSON(schema2, value) {
  if (!value) {
    return Fragment$7.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$7(value.map(schema2.nodeFromJSON));
};
Fragment$7.fromArray = function fromArray(array) {
  if (!array.length) {
    return Fragment$7.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$7(joined || array, size);
};
Fragment$7.from = function from(nodes2) {
  if (!nodes2) {
    return Fragment$7.empty;
  }
  if (nodes2 instanceof Fragment$7) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$7([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$7.prototype, prototypeAccessors$1$c);
var found$7 = { index: 0, offset: 0 };
function retIndex$7(index8, offset2) {
  found$7.index = index8;
  found$7.offset = offset2;
  return found$7;
}
Fragment$7.empty = new Fragment$7([], 0);
function compareDeep$7(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$7(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$7(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$7 = function Mark(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$7.prototype.addToSet = function addToSet(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$7.prototype.removeFromSet = function removeFromSet(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$7.prototype.isInSet = function isInSet(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$7.prototype.eq = function eq2(other) {
  return this == other || this.type == other.type && compareDeep$7(this.attrs, other.attrs);
};
Mark$7.prototype.toJSON = function toJSON2() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$7.fromJSON = function fromJSON2(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$7.sameSet = function sameSet(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$7.setFrom = function setFrom(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$7.none;
  }
  if (marks9 instanceof Mark$7) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$7.none = [];
function ReplaceError$7(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$7.prototype;
  return err8;
}
ReplaceError$7.prototype = Object.create(Error.prototype);
ReplaceError$7.prototype.constructor = ReplaceError$7;
ReplaceError$7.prototype.name = "ReplaceError";
var Slice$7 = function Slice(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$8 = { size: {} };
prototypeAccessors$2$8.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$7.prototype.insertAt = function insertAt(pos, fragment) {
  var content2 = insertInto$7(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$7(content2, this.openStart, this.openEnd);
};
Slice$7.prototype.removeBetween = function removeBetween(from12, to) {
  return new Slice$7(removeRange$7(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$7.prototype.eq = function eq3(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$7.prototype.toString = function toString2() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$7.prototype.toJSON = function toJSON3() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$7.fromJSON = function fromJSON3(schema2, json) {
  if (!json) {
    return Slice$7.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$7(Fragment$7.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$7.maxOpen = function maxOpen(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$7(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$7.prototype, prototypeAccessors$2$8);
function removeRange$7(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$7(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$7(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$7(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$7.empty = new Slice$7(Fragment$7.empty, 0, 0);
function replace$8($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$7("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$7("Inconsistent open depths");
  }
  return replaceOuter$7($from, $to, slice11, 0);
}
function replaceOuter$7($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$7($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$7(node18, replaceTwoWay$7($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$7(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$7(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$7(node18, replaceThreeWay$7($from, start16, end8, $to, depth));
  }
}
function checkJoin$7(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$7("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$8($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$7(node18, $after.node(depth));
  return node18;
}
function addNode$7(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$7($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$7($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$7(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$7($end.nodeBefore, target);
  }
}
function close$7(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$7("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$7($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$8($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$8($end, $to, depth + 1);
  var content2 = [];
  addRange$7(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$7(openStart, openEnd);
    addNode$7(close$7(openStart, replaceThreeWay$7($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$7(close$7(openStart, replaceTwoWay$7($from, $start, depth + 1)), content2);
    }
    addRange$7($start, $end, depth, content2);
    if (openEnd) {
      addNode$7(close$7(openEnd, replaceTwoWay$7($end, $to, depth + 1)), content2);
    }
  }
  addRange$7($to, null, depth, content2);
  return new Fragment$7(content2);
}
function replaceTwoWay$7($from, $to, depth) {
  var content2 = [];
  addRange$7(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$8($from, $to, depth + 1);
    addNode$7(close$7(type, replaceTwoWay$7($from, $to, depth + 1)), content2);
  }
  addRange$7($to, null, depth, content2);
  return new Fragment$7(content2);
}
function prepareSliceForReplace$7(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$7.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$7 = function ResolvedPos(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$6 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$7.prototype.resolveDepth = function resolveDepth(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$6.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$6.doc.get = function() {
  return this.node(0);
};
ResolvedPos$7.prototype.node = function node(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$7.prototype.index = function index(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$7.prototype.indexAfter = function indexAfter(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$7.prototype.start = function start(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$7.prototype.end = function end(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$7.prototype.before = function before(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$7.prototype.after = function after(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$6.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$6.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$6.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$7.prototype.marks = function marks() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$7.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$7.prototype.marksAcross = function marksAcross($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$7.prototype.sharedDepth = function sharedDepth(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$7.prototype.blockRange = function blockRange(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$7(this$1$1, other, d);
    }
  }
};
ResolvedPos$7.prototype.sameParent = function sameParent(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$7.prototype.max = function max(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$7.prototype.min = function min(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$7.prototype.toString = function toString3() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$7.resolve = function resolve(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$7(pos, path, parentOffset);
};
ResolvedPos$7.resolveCached = function resolveCached(doc2, pos) {
  for (var i = 0; i < resolveCache$7.length; i++) {
    var cached = resolveCache$7[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$7[resolveCachePos$7] = ResolvedPos$7.resolve(doc2, pos);
  resolveCachePos$7 = (resolveCachePos$7 + 1) % resolveCacheSize$7;
  return result2;
};
Object.defineProperties(ResolvedPos$7.prototype, prototypeAccessors$3$6);
var resolveCache$7 = [];
var resolveCachePos$7 = 0;
var resolveCacheSize$7 = 12;
var NodeRange$7 = function NodeRange($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$6 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$6.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$6.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$6.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$6.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$6.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$7.prototype, prototypeAccessors$1$1$6);
var emptyAttrs$7 = /* @__PURE__ */ Object.create(null);
var Node$8 = function Node2(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$7.empty;
  this.marks = marks9 || Mark$7.none;
};
var prototypeAccessors$g = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$g.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$g.childCount.get = function() {
  return this.content.childCount;
};
Node$8.prototype.child = function child2(index8) {
  return this.content.child(index8);
};
Node$8.prototype.maybeChild = function maybeChild2(index8) {
  return this.content.maybeChild(index8);
};
Node$8.prototype.forEach = function forEach2(f2) {
  this.content.forEach(f2);
};
Node$8.prototype.nodesBetween = function nodesBetween2(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$8.prototype.descendants = function descendants2(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$g.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$8.prototype.textBetween = function textBetween2(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$g.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$g.lastChild.get = function() {
  return this.content.lastChild;
};
Node$8.prototype.eq = function eq4(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$8.prototype.sameMarkup = function sameMarkup(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$8.prototype.hasMarkup = function hasMarkup(type, attrs, marks9) {
  return this.type == type && compareDeep$7(this.attrs, attrs || type.defaultAttrs || emptyAttrs$7) && Mark$7.sameSet(this.marks, marks9 || Mark$7.none);
};
Node$8.prototype.copy = function copy(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$8.prototype.mark = function mark(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$8.prototype.cut = function cut2(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$8.prototype.slice = function slice(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$7.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$7(content2, $from.depth - depth, $to.depth - depth);
};
Node$8.prototype.replace = function replace$1(from12, to, slice11) {
  return replace$8(this.resolve(from12), this.resolve(to), slice11);
};
Node$8.prototype.nodeAt = function nodeAt(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$8.prototype.childAfter = function childAfter(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$8.prototype.childBefore = function childBefore(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$8.prototype.resolve = function resolve2(pos) {
  return ResolvedPos$7.resolveCached(this, pos);
};
Node$8.prototype.resolveNoCache = function resolveNoCache(pos) {
  return ResolvedPos$7.resolve(this, pos);
};
Node$8.prototype.rangeHasMark = function rangeHasMark(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$g.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$g.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$g.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$g.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$g.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$g.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$g.isAtom.get = function() {
  return this.type.isAtom;
};
Node$8.prototype.toString = function toString4() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$7(this.marks, name);
};
Node$8.prototype.contentMatchAt = function contentMatchAt(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$8.prototype.canReplace = function canReplace(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$7.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$8.prototype.canReplaceWith = function canReplaceWith(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$8.prototype.canAppend = function canAppend(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$8.prototype.defaultContentType = function defaultContentType(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$8.prototype.check = function check() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$8.prototype.toJSON = function toJSON4() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$8.fromJSON = function fromJSON4(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$7.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$8.prototype, prototypeAccessors$g);
var TextNode$7 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$7(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$8);
function wrapMarks$7(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$7 = function ContentMatch(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$6 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$7.parse = function parse(string, nodeTypes) {
  var stream = new TokenStream$7(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$7.empty;
  }
  var expr = parseExpr$7(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$7(nfa$7(expr));
  checkForDeadEnds$7(match2, stream);
  return match2;
};
ContentMatch$7.prototype.matchType = function matchType(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$7.prototype.matchFragment = function matchFragment(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$6.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$6.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$7.prototype.compatible = function compatible(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$7.prototype.fillBefore = function fillBefore(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$7.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$7.prototype.findWrapping = function findWrapping(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$7.prototype.computeWrapping = function computeWrapping(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$6.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$7.prototype.edge = function edge(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$7.prototype.toString = function toString5() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$7.prototype, prototypeAccessors$5$6);
ContentMatch$7.empty = new ContentMatch$7(true);
var TokenStream$7 = function TokenStream(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$6 = { next: {} };
prototypeAccessors$1$3$6.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$7.prototype.eat = function eat(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$7.prototype.err = function err(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$7.prototype, prototypeAccessors$1$3$6);
function parseExpr$7(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$7(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$7(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$7(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$7(stream) {
  var expr = parseExprAtom$7(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$7(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$7(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$7(stream, expr) {
  var min9 = parseNum$7(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$7(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$7(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$7(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$7(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$7(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$7(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$7(a, b) {
  return a - b;
}
function nullFrom$7(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$7);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$7(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$7(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$7(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$7(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$7);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$7(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$7(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$7(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$7(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$7(attrs[name]);
    }
  }
  return result2;
}
var NodeType$a = function NodeType(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$7(spec.attrs);
  this.defaultAttrs = defaultAttrs$7(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$6 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$6.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$6.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$6.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$7.empty;
};
prototypeAccessors$4$6.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$a.prototype.hasRequiredAttrs = function hasRequiredAttrs(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$a.prototype.compatibleContent = function compatibleContent(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$a.prototype.computeAttrs = function computeAttrs$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$7(this.attrs, attrs);
  }
};
NodeType$a.prototype.create = function create(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$8(this, this.computeAttrs(attrs), Fragment$7.from(content2), Mark$7.setFrom(marks9));
};
NodeType$a.prototype.createChecked = function createChecked(attrs, content2, marks9) {
  content2 = Fragment$7.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$8(this, this.computeAttrs(attrs), content2, Mark$7.setFrom(marks9));
};
NodeType$a.prototype.createAndFill = function createAndFill(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$7.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$7.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$8(this, attrs, content2.append(after8), Mark$7.setFrom(marks9));
};
NodeType$a.prototype.validContent = function validContent(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$a.prototype.allowsMarkType = function allowsMarkType(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$a.prototype.allowsMarks = function allowsMarks(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$a.prototype.allowedMarks = function allowedMarks(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$7.empty;
};
NodeType$a.compile = function compile(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$a(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$a.prototype, prototypeAccessors$4$6);
var Attribute$7 = function Attribute(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$6 = { isRequired: {} };
prototypeAccessors$1$2$6.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$7.prototype, prototypeAccessors$1$2$6);
var MarkType$7 = function MarkType(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$7(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$7(this.attrs);
  this.instance = defaults && new Mark$7(this, defaults);
};
MarkType$7.prototype.create = function create2(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$7(this, computeAttrs$7(this.attrs, attrs));
};
MarkType$7.compile = function compile2(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$7(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$7.prototype.removeFromSet = function removeFromSet2(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$7.prototype.isInSet = function isInSet2(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$7.prototype.excludes = function excludes(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$7 = function Schema(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$d.from(spec.nodes);
  this.spec.marks = OrderedMap$d.from(spec.marks);
  this.nodes = NodeType$a.compile(this.spec.nodes, this);
  this.marks = MarkType$7.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$7.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$7(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$7(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$7.prototype.node = function node2(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$a)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$7.prototype.text = function text(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$7(type, type.defaultAttrs, text$1, Mark$7.setFrom(marks9));
};
Schema$7.prototype.mark = function mark2(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$7.prototype.nodeFromJSON = function nodeFromJSON(json) {
  return Node$8.fromJSON(this, json);
};
Schema$7.prototype.markFromJSON = function markFromJSON(json) {
  return Mark$7.fromJSON(this, json);
};
Schema$7.prototype.nodeType = function nodeType(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$7(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$7 = function DOMParser(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$7.prototype.parse = function parse2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$7(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$7.prototype.parseSlice = function parseSlice(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$7(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$7.maxOpen(context.finish());
};
DOMParser$7.prototype.matchTag = function matchTag(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$7(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$7.prototype.matchStyle = function matchStyle(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$7.schemaRules = function schemaRules(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$8(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$8(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$7.fromSchema = function fromSchema(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$7(schema2, DOMParser$7.schemaRules(schema2)));
};
var blockTags$7 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$7 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$7 = { ol: true, ul: true };
var OPT_PRESERVE_WS$7 = 1;
var OPT_PRESERVE_WS_FULL$7 = 2;
var OPT_OPEN_LEFT$7 = 4;
function wsOptionsFor$7(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$7 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$7 : 0);
}
var NodeContext$7 = function NodeContext(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$7 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$7.none;
};
NodeContext$7.prototype.findWrapping = function findWrapping2(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$7.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$7.prototype.finish = function finish(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$7)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$7.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$7.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$7 = function ParseContext(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$7(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$7 : 0);
  if (topNode) {
    topContext = new NodeContext$7(
      topNode.type,
      topNode.attrs,
      Mark$7.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$7(null, null, Mark$7.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$7(parser.schema.topNodeType, null, Mark$7.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$6 = { top: {}, currentPos: {} };
prototypeAccessors$6$6.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$7.prototype.addDOM = function addDOM(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$7(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$7.prototype.addTextNode = function addTextNode(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$7)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$7)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$7.prototype.addElement = function addElement(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$7.hasOwnProperty(name)) {
    normalizeList$7(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$7.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$7.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$7.prototype.readStyles = function readStyles(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$7.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$7.prototype.addElementByRule = function addElementByRule(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$7.prototype.addAll = function addAll(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$7.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$7.prototype.findPlace = function findPlace(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$7.prototype.insertNode = function insertNode(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$7.prototype.applyPendingMarks = function applyPendingMarks(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$7.prototype.enter = function enter(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$7.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$7 : wsOptionsFor$7(preserveWS);
  if (top.options & OPT_OPEN_LEFT$7 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$7;
  }
  this.nodes.push(new NodeContext$7(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$7.prototype.closeExtra = function closeExtra(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$7.prototype.finish = function finish2() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$7.prototype.sync = function sync(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$7.prototype.addPendingMark = function addPendingMark(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$7.prototype.removePendingMark = function removePendingMark(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$6.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$7.prototype.findAtPoint = function findAtPoint(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$7.prototype.findInside = function findInside(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$7.prototype.findAround = function findAround(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$7.prototype.findInText = function findInText(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$7.prototype.matchesContext = function matchesContext(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$7.prototype.textblockFromContext = function textblockFromContext() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$7.prototype, prototypeAccessors$6$6);
function normalizeList$7(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$7.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$7(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$7(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$8(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$7 = function DOMSerializer(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$7.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$8(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$7.prototype.serializeNode = function serializeNode(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$7.renderSpec(doc$8(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$7.prototype.serializeNodeAndMarks = function serializeNodeAndMarks(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$7.prototype.serializeMark = function serializeMark(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$7.renderSpec(doc$8(options), toDOM4(mark15, inline3));
};
DOMSerializer$7.renderSpec = function renderSpec(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$7.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$7.fromSchema = function fromSchema2(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$7(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$7.nodesFromSchema = function nodesFromSchema(schema2) {
  var result2 = gatherToDOM$7(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$7.marksFromSchema = function marksFromSchema(schema2) {
  return gatherToDOM$7(schema2.marks);
};
function gatherToDOM$7(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$8(options) {
  return options.document || window.document;
}
dist$d.Node = Node$8;
dist$d.ResolvedPos = ResolvedPos$7;
dist$d.NodeRange = NodeRange$7;
dist$d.Fragment = Fragment$7;
dist$d.Slice = Slice$7;
dist$d.ReplaceError = ReplaceError$7;
dist$d.Mark = Mark$7;
dist$d.Schema = Schema$7;
dist$d.NodeType = NodeType$a;
dist$d.MarkType = MarkType$7;
dist$d.ContentMatch = ContentMatch$7;
dist$d.DOMParser = DOMParser$7;
dist$d.DOMSerializer = DOMSerializer$7;
var dist$c = {};
var dist$b = {};
function OrderedMap$c(content2) {
  this.content = content2;
}
OrderedMap$c.prototype = {
  constructor: OrderedMap$c,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$c(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$c(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$c([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$c(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$c(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$c.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$c(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$c.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$c(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$c.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$c.from = function(value) {
  if (value instanceof OrderedMap$c)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$c(content2);
};
var orderedmap$5 = OrderedMap$c;
Object.defineProperty(dist$b, "__esModule", { value: true });
function _interopDefault$9(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$b = _interopDefault$9(orderedmap$5);
function findDiffStart$6(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$6(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$6(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$6(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$6 = function Fragment2(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$b = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$6.prototype.nodesBetween = function nodesBetween3(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$6.prototype.descendants = function descendants3(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$6.prototype.textBetween = function textBetween3(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$6.prototype.append = function append2(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$6(content2, this.size + other.size);
};
Fragment$6.prototype.cut = function cut3(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$6(result2, size);
};
Fragment$6.prototype.cutByIndex = function cutByIndex2(from12, to) {
  if (from12 == to) {
    return Fragment$6.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$6(this.content.slice(from12, to));
};
Fragment$6.prototype.replaceChild = function replaceChild2(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$6(copy12, size);
};
Fragment$6.prototype.addToStart = function addToStart2(node18) {
  return new Fragment$6([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$6.prototype.addToEnd = function addToEnd2(node18) {
  return new Fragment$6(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$6.prototype.eq = function eq5(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$b.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$b.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$b.childCount.get = function() {
  return this.content.length;
};
Fragment$6.prototype.child = function child3(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$6.prototype.maybeChild = function maybeChild3(index8) {
  return this.content[index8];
};
Fragment$6.prototype.forEach = function forEach3(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$6.prototype.findDiffStart = function findDiffStart$12(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$6(this, other, pos);
};
Fragment$6.prototype.findDiffEnd = function findDiffEnd$12(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$6(this, other, pos, otherPos);
};
Fragment$6.prototype.findIndex = function findIndex2(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$6(0, pos);
  }
  if (pos == this.size) {
    return retIndex$6(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$6(i + 1, end8);
      }
      return retIndex$6(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$6.prototype.toString = function toString6() {
  return "<" + this.toStringInner() + ">";
};
Fragment$6.prototype.toStringInner = function toStringInner2() {
  return this.content.join(", ");
};
Fragment$6.prototype.toJSON = function toJSON5() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$6.fromJSON = function fromJSON5(schema2, value) {
  if (!value) {
    return Fragment$6.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$6(value.map(schema2.nodeFromJSON));
};
Fragment$6.fromArray = function fromArray2(array) {
  if (!array.length) {
    return Fragment$6.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$6(joined || array, size);
};
Fragment$6.from = function from2(nodes2) {
  if (!nodes2) {
    return Fragment$6.empty;
  }
  if (nodes2 instanceof Fragment$6) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$6([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$6.prototype, prototypeAccessors$1$b);
var found$6 = { index: 0, offset: 0 };
function retIndex$6(index8, offset2) {
  found$6.index = index8;
  found$6.offset = offset2;
  return found$6;
}
Fragment$6.empty = new Fragment$6([], 0);
function compareDeep$6(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$6(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$6(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$6 = function Mark2(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$6.prototype.addToSet = function addToSet2(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$6.prototype.removeFromSet = function removeFromSet3(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$6.prototype.isInSet = function isInSet3(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$6.prototype.eq = function eq6(other) {
  return this == other || this.type == other.type && compareDeep$6(this.attrs, other.attrs);
};
Mark$6.prototype.toJSON = function toJSON6() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$6.fromJSON = function fromJSON6(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$6.sameSet = function sameSet2(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$6.setFrom = function setFrom2(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$6.none;
  }
  if (marks9 instanceof Mark$6) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$6.none = [];
function ReplaceError$6(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$6.prototype;
  return err8;
}
ReplaceError$6.prototype = Object.create(Error.prototype);
ReplaceError$6.prototype.constructor = ReplaceError$6;
ReplaceError$6.prototype.name = "ReplaceError";
var Slice$6 = function Slice2(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$7 = { size: {} };
prototypeAccessors$2$7.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$6.prototype.insertAt = function insertAt2(pos, fragment) {
  var content2 = insertInto$6(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$6(content2, this.openStart, this.openEnd);
};
Slice$6.prototype.removeBetween = function removeBetween2(from12, to) {
  return new Slice$6(removeRange$6(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$6.prototype.eq = function eq7(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$6.prototype.toString = function toString7() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$6.prototype.toJSON = function toJSON7() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$6.fromJSON = function fromJSON7(schema2, json) {
  if (!json) {
    return Slice$6.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$6(Fragment$6.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$6.maxOpen = function maxOpen2(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$6(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$6.prototype, prototypeAccessors$2$7);
function removeRange$6(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$6(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$6(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$6(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$6.empty = new Slice$6(Fragment$6.empty, 0, 0);
function replace$7($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$6("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$6("Inconsistent open depths");
  }
  return replaceOuter$6($from, $to, slice11, 0);
}
function replaceOuter$6($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$6($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$6(node18, replaceTwoWay$6($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$6(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$6(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$6(node18, replaceThreeWay$6($from, start16, end8, $to, depth));
  }
}
function checkJoin$6(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$6("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$7($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$6(node18, $after.node(depth));
  return node18;
}
function addNode$6(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$6($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$6($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$6(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$6($end.nodeBefore, target);
  }
}
function close$6(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$6("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$6($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$7($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$7($end, $to, depth + 1);
  var content2 = [];
  addRange$6(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$6(openStart, openEnd);
    addNode$6(close$6(openStart, replaceThreeWay$6($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$6(close$6(openStart, replaceTwoWay$6($from, $start, depth + 1)), content2);
    }
    addRange$6($start, $end, depth, content2);
    if (openEnd) {
      addNode$6(close$6(openEnd, replaceTwoWay$6($end, $to, depth + 1)), content2);
    }
  }
  addRange$6($to, null, depth, content2);
  return new Fragment$6(content2);
}
function replaceTwoWay$6($from, $to, depth) {
  var content2 = [];
  addRange$6(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$7($from, $to, depth + 1);
    addNode$6(close$6(type, replaceTwoWay$6($from, $to, depth + 1)), content2);
  }
  addRange$6($to, null, depth, content2);
  return new Fragment$6(content2);
}
function prepareSliceForReplace$6(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$6.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$6 = function ResolvedPos2(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$5 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$6.prototype.resolveDepth = function resolveDepth2(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$5.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$5.doc.get = function() {
  return this.node(0);
};
ResolvedPos$6.prototype.node = function node3(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$6.prototype.index = function index2(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$6.prototype.indexAfter = function indexAfter2(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$6.prototype.start = function start2(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$6.prototype.end = function end2(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$6.prototype.before = function before2(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$6.prototype.after = function after2(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$5.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$5.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$5.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$6.prototype.marks = function marks2() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$6.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$6.prototype.marksAcross = function marksAcross2($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$6.prototype.sharedDepth = function sharedDepth2(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$6.prototype.blockRange = function blockRange2(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$6(this$1$1, other, d);
    }
  }
};
ResolvedPos$6.prototype.sameParent = function sameParent2(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$6.prototype.max = function max2(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$6.prototype.min = function min2(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$6.prototype.toString = function toString8() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$6.resolve = function resolve3(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$6(pos, path, parentOffset);
};
ResolvedPos$6.resolveCached = function resolveCached2(doc2, pos) {
  for (var i = 0; i < resolveCache$6.length; i++) {
    var cached = resolveCache$6[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$6[resolveCachePos$6] = ResolvedPos$6.resolve(doc2, pos);
  resolveCachePos$6 = (resolveCachePos$6 + 1) % resolveCacheSize$6;
  return result2;
};
Object.defineProperties(ResolvedPos$6.prototype, prototypeAccessors$3$5);
var resolveCache$6 = [];
var resolveCachePos$6 = 0;
var resolveCacheSize$6 = 12;
var NodeRange$6 = function NodeRange2($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$5 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$5.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$5.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$5.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$5.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$5.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$6.prototype, prototypeAccessors$1$1$5);
var emptyAttrs$6 = /* @__PURE__ */ Object.create(null);
var Node$7 = function Node3(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$6.empty;
  this.marks = marks9 || Mark$6.none;
};
var prototypeAccessors$f = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$f.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$f.childCount.get = function() {
  return this.content.childCount;
};
Node$7.prototype.child = function child4(index8) {
  return this.content.child(index8);
};
Node$7.prototype.maybeChild = function maybeChild4(index8) {
  return this.content.maybeChild(index8);
};
Node$7.prototype.forEach = function forEach4(f2) {
  this.content.forEach(f2);
};
Node$7.prototype.nodesBetween = function nodesBetween4(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$7.prototype.descendants = function descendants4(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$f.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$7.prototype.textBetween = function textBetween4(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$f.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$f.lastChild.get = function() {
  return this.content.lastChild;
};
Node$7.prototype.eq = function eq8(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$7.prototype.sameMarkup = function sameMarkup2(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$7.prototype.hasMarkup = function hasMarkup2(type, attrs, marks9) {
  return this.type == type && compareDeep$6(this.attrs, attrs || type.defaultAttrs || emptyAttrs$6) && Mark$6.sameSet(this.marks, marks9 || Mark$6.none);
};
Node$7.prototype.copy = function copy2(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$7.prototype.mark = function mark3(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$7.prototype.cut = function cut4(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$7.prototype.slice = function slice2(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$6.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$6(content2, $from.depth - depth, $to.depth - depth);
};
Node$7.prototype.replace = function replace$12(from12, to, slice11) {
  return replace$7(this.resolve(from12), this.resolve(to), slice11);
};
Node$7.prototype.nodeAt = function nodeAt2(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$7.prototype.childAfter = function childAfter2(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$7.prototype.childBefore = function childBefore2(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$7.prototype.resolve = function resolve4(pos) {
  return ResolvedPos$6.resolveCached(this, pos);
};
Node$7.prototype.resolveNoCache = function resolveNoCache2(pos) {
  return ResolvedPos$6.resolve(this, pos);
};
Node$7.prototype.rangeHasMark = function rangeHasMark2(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$f.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$f.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$f.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$f.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$f.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$f.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$f.isAtom.get = function() {
  return this.type.isAtom;
};
Node$7.prototype.toString = function toString9() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$6(this.marks, name);
};
Node$7.prototype.contentMatchAt = function contentMatchAt2(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$7.prototype.canReplace = function canReplace2(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$6.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$7.prototype.canReplaceWith = function canReplaceWith2(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$7.prototype.canAppend = function canAppend2(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$7.prototype.defaultContentType = function defaultContentType2(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$7.prototype.check = function check2() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$7.prototype.toJSON = function toJSON8() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$7.fromJSON = function fromJSON8(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$6.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$7.prototype, prototypeAccessors$f);
var TextNode$6 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$6(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$7);
function wrapMarks$6(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$6 = function ContentMatch2(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$5 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$6.parse = function parse3(string, nodeTypes) {
  var stream = new TokenStream$6(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$6.empty;
  }
  var expr = parseExpr$6(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$6(nfa$6(expr));
  checkForDeadEnds$6(match2, stream);
  return match2;
};
ContentMatch$6.prototype.matchType = function matchType2(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$6.prototype.matchFragment = function matchFragment2(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$5.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$5.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$6.prototype.compatible = function compatible2(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$6.prototype.fillBefore = function fillBefore2(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$6.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$6.prototype.findWrapping = function findWrapping3(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$6.prototype.computeWrapping = function computeWrapping2(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$5.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$6.prototype.edge = function edge2(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$6.prototype.toString = function toString10() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$6.prototype, prototypeAccessors$5$5);
ContentMatch$6.empty = new ContentMatch$6(true);
var TokenStream$6 = function TokenStream2(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$5 = { next: {} };
prototypeAccessors$1$3$5.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$6.prototype.eat = function eat2(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$6.prototype.err = function err2(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$6.prototype, prototypeAccessors$1$3$5);
function parseExpr$6(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$6(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$6(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$6(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$6(stream) {
  var expr = parseExprAtom$6(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$6(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$6(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$6(stream, expr) {
  var min9 = parseNum$6(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$6(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$6(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$6(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$6(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$6(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$6(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$6(a, b) {
  return a - b;
}
function nullFrom$6(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$6);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$6(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$6(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$6(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$6(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$6);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$6(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$6(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$6(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$6(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$6(attrs[name]);
    }
  }
  return result2;
}
var NodeType$9 = function NodeType2(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$6(spec.attrs);
  this.defaultAttrs = defaultAttrs$6(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$5 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$5.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$5.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$5.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$6.empty;
};
prototypeAccessors$4$5.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$9.prototype.hasRequiredAttrs = function hasRequiredAttrs2(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$9.prototype.compatibleContent = function compatibleContent2(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$9.prototype.computeAttrs = function computeAttrs$12(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$6(this.attrs, attrs);
  }
};
NodeType$9.prototype.create = function create3(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$7(this, this.computeAttrs(attrs), Fragment$6.from(content2), Mark$6.setFrom(marks9));
};
NodeType$9.prototype.createChecked = function createChecked2(attrs, content2, marks9) {
  content2 = Fragment$6.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$7(this, this.computeAttrs(attrs), content2, Mark$6.setFrom(marks9));
};
NodeType$9.prototype.createAndFill = function createAndFill2(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$6.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$6.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$7(this, attrs, content2.append(after8), Mark$6.setFrom(marks9));
};
NodeType$9.prototype.validContent = function validContent2(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$9.prototype.allowsMarkType = function allowsMarkType2(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$9.prototype.allowsMarks = function allowsMarks2(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$9.prototype.allowedMarks = function allowedMarks2(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$6.empty;
};
NodeType$9.compile = function compile3(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$9(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$9.prototype, prototypeAccessors$4$5);
var Attribute$6 = function Attribute2(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$5 = { isRequired: {} };
prototypeAccessors$1$2$5.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$6.prototype, prototypeAccessors$1$2$5);
var MarkType$6 = function MarkType2(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$6(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$6(this.attrs);
  this.instance = defaults && new Mark$6(this, defaults);
};
MarkType$6.prototype.create = function create4(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$6(this, computeAttrs$6(this.attrs, attrs));
};
MarkType$6.compile = function compile4(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$6(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$6.prototype.removeFromSet = function removeFromSet4(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$6.prototype.isInSet = function isInSet4(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$6.prototype.excludes = function excludes2(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$6 = function Schema2(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$b.from(spec.nodes);
  this.spec.marks = OrderedMap$b.from(spec.marks);
  this.nodes = NodeType$9.compile(this.spec.nodes, this);
  this.marks = MarkType$6.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$6.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$6(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$6(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$6.prototype.node = function node4(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$9)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$6.prototype.text = function text2(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$6(type, type.defaultAttrs, text$1, Mark$6.setFrom(marks9));
};
Schema$6.prototype.mark = function mark4(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$6.prototype.nodeFromJSON = function nodeFromJSON2(json) {
  return Node$7.fromJSON(this, json);
};
Schema$6.prototype.markFromJSON = function markFromJSON2(json) {
  return Mark$6.fromJSON(this, json);
};
Schema$6.prototype.nodeType = function nodeType2(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$6(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$6 = function DOMParser2(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$6.prototype.parse = function parse4(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$6(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$6.prototype.parseSlice = function parseSlice2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$6(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$6.maxOpen(context.finish());
};
DOMParser$6.prototype.matchTag = function matchTag2(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$6(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$6.prototype.matchStyle = function matchStyle2(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$6.schemaRules = function schemaRules2(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$7(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$7(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$6.fromSchema = function fromSchema3(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$6(schema2, DOMParser$6.schemaRules(schema2)));
};
var blockTags$6 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$6 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$6 = { ol: true, ul: true };
var OPT_PRESERVE_WS$6 = 1;
var OPT_PRESERVE_WS_FULL$6 = 2;
var OPT_OPEN_LEFT$6 = 4;
function wsOptionsFor$6(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$6 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$6 : 0);
}
var NodeContext$6 = function NodeContext2(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$6 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$6.none;
};
NodeContext$6.prototype.findWrapping = function findWrapping4(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$6.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$6.prototype.finish = function finish3(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$6)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$6.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$6.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$6 = function ParseContext2(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$6(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$6 : 0);
  if (topNode) {
    topContext = new NodeContext$6(
      topNode.type,
      topNode.attrs,
      Mark$6.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$6(null, null, Mark$6.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$6(parser.schema.topNodeType, null, Mark$6.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$5 = { top: {}, currentPos: {} };
prototypeAccessors$6$5.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$6.prototype.addDOM = function addDOM2(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$6(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$6.prototype.addTextNode = function addTextNode2(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$6)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$6)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$6.prototype.addElement = function addElement2(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$6.hasOwnProperty(name)) {
    normalizeList$6(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$6.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$6.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$6.prototype.readStyles = function readStyles2(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$6.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$6.prototype.addElementByRule = function addElementByRule2(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$6.prototype.addAll = function addAll2(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$6.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$6.prototype.findPlace = function findPlace2(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$6.prototype.insertNode = function insertNode2(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$6.prototype.applyPendingMarks = function applyPendingMarks2(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$6.prototype.enter = function enter2(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$6.prototype.enterInner = function enterInner2(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$6 : wsOptionsFor$6(preserveWS);
  if (top.options & OPT_OPEN_LEFT$6 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$6;
  }
  this.nodes.push(new NodeContext$6(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$6.prototype.closeExtra = function closeExtra2(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$6.prototype.finish = function finish4() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$6.prototype.sync = function sync2(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$6.prototype.addPendingMark = function addPendingMark2(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$6.prototype.removePendingMark = function removePendingMark2(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$5.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$6.prototype.findAtPoint = function findAtPoint2(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$6.prototype.findInside = function findInside2(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$6.prototype.findAround = function findAround2(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$6.prototype.findInText = function findInText2(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$6.prototype.matchesContext = function matchesContext2(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$6.prototype.textblockFromContext = function textblockFromContext2() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$6.prototype, prototypeAccessors$6$5);
function normalizeList$6(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$6.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$6(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$6(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$7(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$6 = function DOMSerializer2(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$6.prototype.serializeFragment = function serializeFragment2(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$7(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$6.prototype.serializeNode = function serializeNode2(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$6.renderSpec(doc$7(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$6.prototype.serializeNodeAndMarks = function serializeNodeAndMarks2(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$6.prototype.serializeMark = function serializeMark2(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$6.renderSpec(doc$7(options), toDOM4(mark15, inline3));
};
DOMSerializer$6.renderSpec = function renderSpec2(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$6.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$6.fromSchema = function fromSchema4(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$6(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$6.nodesFromSchema = function nodesFromSchema2(schema2) {
  var result2 = gatherToDOM$6(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$6.marksFromSchema = function marksFromSchema2(schema2) {
  return gatherToDOM$6(schema2.marks);
};
function gatherToDOM$6(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$7(options) {
  return options.document || window.document;
}
dist$b.Node = Node$7;
dist$b.ResolvedPos = ResolvedPos$6;
dist$b.NodeRange = NodeRange$6;
dist$b.Fragment = Fragment$6;
dist$b.Slice = Slice$6;
dist$b.ReplaceError = ReplaceError$6;
dist$b.Mark = Mark$6;
dist$b.Schema = Schema$6;
dist$b.NodeType = NodeType$9;
dist$b.MarkType = MarkType$6;
dist$b.ContentMatch = ContentMatch$6;
dist$b.DOMParser = DOMParser$6;
dist$b.DOMSerializer = DOMSerializer$6;
Object.defineProperty(dist$c, "__esModule", { value: true });
var prosemirrorModel$6 = dist$b;
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index8, offset2) {
  return index8 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var MapResult = function MapResult2(pos, deleted, recover2) {
  if (deleted === void 0)
    deleted = false;
  if (recover2 === void 0)
    recover2 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover2;
};
var StepMap = function StepMap2(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap.prototype.recover = function recover(value) {
  var this$1$1 = this;
  var diff = 0, index8 = recoverIndex(value);
  if (!this.inverted) {
    for (var i = 0; i < index8; i++) {
      diff += this$1$1.ranges[i * 3 + 2] - this$1$1.ranges[i * 3 + 1];
    }
  }
  return this.ranges[index8 * 3] + diff + recoverOffset(value);
};
StepMap.prototype.mapResult = function mapResult(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap.prototype.map = function map(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap.prototype._map = function _map(pos, assoc, simple) {
  var this$1$1 = this;
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start16 = this$1$1.ranges[i] - (this$1$1.inverted ? diff : 0);
    if (start16 > pos) {
      break;
    }
    var oldSize = this$1$1.ranges[i + oldIndex], newSize = this$1$1.ranges[i + newIndex], end8 = start16 + oldSize;
    if (pos <= end8) {
      var side = !oldSize ? assoc : pos == start16 ? -1 : pos == end8 ? 1 : assoc;
      var result2 = start16 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover2 = makeRecover(i / 3, pos - start16);
      return new MapResult(result2, assoc < 0 ? pos != start16 : pos != end8, recover2);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff);
};
StepMap.prototype.touches = function touches(pos, recover2) {
  var this$1$1 = this;
  var diff = 0, index8 = recoverIndex(recover2);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start16 = this$1$1.ranges[i] - (this$1$1.inverted ? diff : 0);
    if (start16 > pos) {
      break;
    }
    var oldSize = this$1$1.ranges[i + oldIndex], end8 = start16 + oldSize;
    if (pos <= end8 && i == index8 * 3) {
      return true;
    }
    diff += this$1$1.ranges[i + newIndex] - oldSize;
  }
  return false;
};
StepMap.prototype.forEach = function forEach5(f2) {
  var this$1$1 = this;
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start16 = this$1$1.ranges[i], oldStart = start16 - (this$1$1.inverted ? diff : 0), newStart = start16 + (this$1$1.inverted ? 0 : diff);
    var oldSize = this$1$1.ranges[i + oldIndex], newSize = this$1$1.ranges[i + newIndex];
    f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap.prototype.invert = function invert() {
  return new StepMap(this.ranges, !this.inverted);
};
StepMap.prototype.toString = function toString11() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap.offset = function offset(n2) {
  return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
};
StepMap.empty = new StepMap([]);
var Mapping = function Mapping2(maps, mirror, from12, to) {
  this.maps = maps || [];
  this.from = from12 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping.prototype.slice = function slice3(from12, to) {
  if (from12 === void 0)
    from12 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping(this.maps, this.mirror, from12, to);
};
Mapping.prototype.copy = function copy3() {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping.prototype.appendMap = function appendMap(map19, mirrors) {
  this.to = this.maps.push(map19);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping.prototype.appendMapping = function appendMapping(mapping) {
  var this$1$1 = this;
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this$1$1.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};
Mapping.prototype.getMirror = function getMirror(n2) {
  var this$1$1 = this;
  if (this.mirror) {
    for (var i = 0; i < this.mirror.length; i++) {
      if (this$1$1.mirror[i] == n2) {
        return this$1$1.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping.prototype.setMirror = function setMirror(n2, m2) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n2, m2);
};
Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
  var this$1$1 = this;
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this$1$1.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};
Mapping.prototype.invert = function invert2() {
  var inverse = new Mapping();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping.prototype.map = function map2(pos, assoc) {
  var this$1$1 = this;
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i = this.from; i < this.to; i++) {
    pos = this$1$1.maps[i].map(pos, assoc);
  }
  return pos;
};
Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping.prototype._map = function _map2(pos, assoc, simple) {
  var this$1$1 = this;
  var deleted = false, recoverables = null;
  for (var i = this.from; i < this.to; i++) {
    var map19 = this$1$1.maps[i], rec = recoverables && recoverables[i];
    if (rec != null && map19.touches(pos, rec)) {
      pos = map19.recover(rec);
      continue;
    }
    var result2 = map19.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this$1$1.getMirror(i);
      if (corr != null && corr > i && corr < this$1$1.to) {
        if (result2.deleted) {
          i = corr;
          pos = this$1$1.maps[corr].recover(result2.recover);
          continue;
        } else {
          (recoverables || (recoverables = /* @__PURE__ */ Object.create(null)))[corr] = result2.recover;
        }
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult(pos, deleted);
};
function TransformError(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = TransformError.prototype;
  return err8;
}
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = function Transform2(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping();
};
var prototypeAccessors$e = { before: {}, docChanged: {} };
prototypeAccessors$e.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform.prototype.step = function step(object) {
  var result2 = this.maybeStep(object);
  if (result2.failed) {
    throw new TransformError(result2.failed);
  }
  return this;
};
Transform.prototype.maybeStep = function maybeStep(step3) {
  var result2 = step3.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step3, result2.doc);
  }
  return result2;
};
prototypeAccessors$e.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform.prototype.addStep = function addStep(step3, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step3);
  this.mapping.appendMap(step3.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform.prototype, prototypeAccessors$e);
function mustOverride() {
  throw new Error("Override me");
}
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = function Step2() {
};
Step.prototype.apply = function apply(_doc) {
  return mustOverride();
};
Step.prototype.getMap = function getMap() {
  return StepMap.empty;
};
Step.prototype.invert = function invert3(_doc) {
  return mustOverride();
};
Step.prototype.map = function map3(_mapping) {
  return mustOverride();
};
Step.prototype.merge = function merge(_other) {
  return null;
};
Step.prototype.toJSON = function toJSON9() {
  return mustOverride();
};
Step.fromJSON = function fromJSON9(schema2, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type = stepsByID[json.stepType];
  if (!type) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type.fromJSON(schema2, json);
};
Step.jsonID = function jsonID(id2, stepClass) {
  if (id2 in stepsByID) {
    throw new RangeError("Duplicate use of step JSON ID " + id2);
  }
  stepsByID[id2] = stepClass;
  stepClass.prototype.jsonID = id2;
  return stepClass;
};
var StepResult = function StepResult2(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult.ok = function ok(doc2) {
  return new StepResult(doc2, null);
};
StepResult.fail = function fail(message) {
  return new StepResult(null, message);
};
StepResult.fromReplace = function fromReplace(doc2, from12, to, slice11) {
  try {
    return StepResult.ok(doc2.replace(from12, to, slice11));
  } catch (e) {
    if (e instanceof prosemirrorModel$6.ReplaceError) {
      return StepResult.fail(e.message);
    }
    throw e;
  }
};
var ReplaceStep = function(Step$$1) {
  function ReplaceStep2(from12, to, slice11, structure) {
    Step$$1.call(this);
    this.from = from12;
    this.to = to;
    this.slice = slice11;
    this.structure = !!structure;
  }
  if (Step$$1)
    ReplaceStep2.__proto__ = Step$$1;
  ReplaceStep2.prototype = Object.create(Step$$1 && Step$$1.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to)) {
      return StepResult.fail("Structure replace would overwrite content");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap2() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert4(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map19(mapping) {
    var from12 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from12.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from12.pos, Math.max(from12.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge3(other) {
    if (!(other instanceof ReplaceStep2) || other.structure != this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice11 = this.slice.size + other.slice.size == 0 ? prosemirrorModel$6.Slice.empty : new prosemirrorModel$6.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirrorModel$6.Slice.empty : new prosemirrorModel$6.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON31() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON32(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, prosemirrorModel$6.Slice.fromJSON(schema2, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step);
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = function(Step$$1) {
  function ReplaceAroundStep2(from12, to, gapFrom, gapTo, slice11, insert, structure) {
    Step$$1.call(this);
    this.from = from12;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step$$1)
    ReplaceAroundStep2.__proto__ = Step$$1;
  ReplaceAroundStep2.prototype = Object.create(Step$$1 && Step$$1.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
      return StepResult.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult.fail("Content does not fit in gap");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap2() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert4(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(
      this.from,
      this.from + this.slice.size + gap,
      this.from + this.insert,
      this.from + this.insert + gap,
      doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure
    );
  };
  ReplaceAroundStep2.prototype.map = function map19(mapping) {
    var from12 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from12.deleted && to.deleted || gapFrom < from12.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from12.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON31() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON32(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(
      json.from,
      json.to,
      json.gapFrom,
      json.gapTo,
      prosemirrorModel$6.Slice.fromJSON(schema2, json.slice),
      json.insert,
      !!json.structure
    );
  };
  return ReplaceAroundStep2;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from12, to) {
  var $from = doc2.resolve(from12), dist2 = to - from12, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    var next2 = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next2 || next2.isLeaf) {
        return true;
      }
      next2 = next2.firstChild;
      dist2--;
    }
  }
  return false;
}
function canCut(node18, start16, end8) {
  return (start16 == 0 || node18.canReplace(start16, node18.childCount)) && (end8 == node18.childCount || node18.canReplace(0, end8));
}
function liftTarget(range) {
  var parent = range.parent;
  var content2 = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth; ; --depth) {
    var node18 = range.$from.node(depth);
    var index8 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node18.canReplace(index8, endIndex, content2)) {
      return depth;
    }
    if (depth == 0 || node18.type.spec.isolating || !canCut(node18, index8, endIndex)) {
      break;
    }
  }
}
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start16 = gapStart, end8 = gapEnd;
  var before8 = prosemirrorModel$6.Fragment.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before8 = prosemirrorModel$6.Fragment.from($from.node(d).copy(before8));
      openStart++;
    } else {
      start16--;
    }
  }
  var after8 = prosemirrorModel$6.Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after8 = prosemirrorModel$6.Fragment.from($to.node(d$1).copy(after8));
      openEnd++;
    } else {
      end8++;
    }
  }
  return this.step(new ReplaceAroundStep(
    start16,
    end8,
    gapStart,
    gapEnd,
    new prosemirrorModel$6.Slice(before8.append(after8), openStart, openEnd),
    before8.size - openStart,
    true
  ));
};
function findWrapping5(range, nodeType8, attrs, innerRange) {
  if (innerRange === void 0)
    innerRange = range;
  var around = findWrappingOutside(range, nodeType8);
  var inner = around && findWrappingInside(innerRange, nodeType8);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType8, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
Transform.prototype.wrap = function(range, wrappers) {
  var content2 = prosemirrorModel$6.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content2 = prosemirrorModel$6.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content2));
  }
  var start16 = range.start, end8 = range.end;
  return this.step(new ReplaceAroundStep(start16, end8, start16, end8, new prosemirrorModel$6.Slice(content2, 0, 0), wrappers.length, true));
};
Transform.prototype.setBlockType = function(from12, to, type, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from12;
  if (!type.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isTextblock && !node18.hasMarkup(type, attrs) && canChangeType(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node18.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep(
        startM,
        endM,
        startM + 1,
        endM - 1,
        new prosemirrorModel$6.Slice(prosemirrorModel$6.Fragment.from(type.create(attrs, null, node18.marks)), 0, 0),
        1,
        true
      ));
      return false;
    }
  });
  return this;
};
function canChangeType(doc2, pos, type) {
  var $pos = doc2.resolve(pos), index8 = $pos.index();
  return $pos.parent.canReplaceWith(index8, index8 + 1, type);
}
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks9) {
  var node18 = this.doc.nodeAt(pos);
  if (!node18) {
    throw new RangeError("No node at given position");
  }
  if (!type) {
    type = node18.type;
  }
  var newNode = type.create(attrs, null, marks9 || node18.marks);
  if (node18.isLeaf) {
    return this.replaceWith(pos, pos + node18.nodeSize, newNode);
  }
  if (!type.validContent(node18.content)) {
    throw new RangeError("Invalid content for node type " + type.name);
  }
  return this.step(new ReplaceAroundStep(
    pos,
    pos + node18.nodeSize,
    pos + 1,
    pos + node18.nodeSize - 1,
    new prosemirrorModel$6.Slice(prosemirrorModel$6.Fragment.from(newNode), 0, 0),
    1,
    true
  ));
};
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    var node18 = $pos.node(d), index$1 = $pos.index(d);
    if (node18.type.spec.isolating) {
      return false;
    }
    var rest = node18.content.cutByIndex(index$1, node18.childCount);
    var after8 = typesAfter && typesAfter[i] || node18;
    if (after8 != node18) {
      rest = rest.replaceChild(0, after8.type.create(after8.attrs));
    }
    if (!node18.canReplace(index$1 + 1, node18.childCount) || !after8.type.validContent(rest)) {
      return false;
    }
  }
  var index8 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index8, index8, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
Transform.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before8 = prosemirrorModel$6.Fragment.empty, after8 = prosemirrorModel$6.Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before8 = prosemirrorModel$6.Fragment.from($pos.node(d).copy(before8));
    var typeAfter = typesAfter && typesAfter[i];
    after8 = prosemirrorModel$6.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after8) : $pos.node(d).copy(after8));
  }
  return this.step(new ReplaceStep(pos, pos, new prosemirrorModel$6.Slice(before8.append(after8), depth, depth, true)));
};
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index8 = $pos.index();
  return joinable$6($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index8, index8 + 1);
}
function joinable$6(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b);
}
function joinPoint(doc2, pos, dir) {
  if (dir === void 0)
    dir = -1;
  var $pos = doc2.resolve(pos);
  for (var d = $pos.depth; ; d--) {
    var before8 = void 0, after8 = void 0;
    if (d == $pos.depth) {
      before8 = $pos.nodeBefore;
      after8 = $pos.nodeAfter;
    } else if (dir > 0) {
      before8 = $pos.node(d + 1);
      after8 = $pos.node(d).maybeChild($pos.index(d) + 1);
    } else {
      before8 = $pos.node(d).maybeChild($pos.index(d) - 1);
      after8 = $pos.node(d + 1);
    }
    if (before8 && !before8.isTextblock && joinable$6(before8, after8)) {
      return pos;
    }
    if (d == 0) {
      break;
    }
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
Transform.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step3 = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel$6.Slice.empty, true);
  return this.step(step3);
};
function insertPoint(doc2, pos, nodeType8) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType8)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index8 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index8, index8, nodeType8)) {
        return $pos.before(d + 1);
      }
      if (index8 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType8)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice11) {
  var $pos = doc2.resolve(pos);
  if (!slice11.content.size) {
    return pos;
  }
  var content2 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content2 = content2.firstChild.content;
  }
  for (var pass = 1; pass <= (slice11.openStart == 0 && slice11.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      if (pass == 1 ? $pos.node(d).canReplace(insertPos, insertPos, content2) : $pos.node(d).contentMatchAt(insertPos).findWrapping(content2.firstChild.type)) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
  }
  return null;
}
function mapFragment(fragment, f2, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child15 = fragment.child(i);
    if (child15.content.size) {
      child15 = child15.copy(mapFragment(child15.content, f2, child15));
    }
    if (child15.isInline) {
      child15 = f2(child15, parent, i);
    }
    mapped.push(child15);
  }
  return prosemirrorModel$6.Fragment.fromArray(mapped);
}
var AddMarkStep = function(Step$$1) {
  function AddMarkStep2(from12, to, mark15) {
    Step$$1.call(this);
    this.from = from12;
    this.to = to;
    this.mark = mark15;
  }
  if (Step$$1)
    AddMarkStep2.__proto__ = Step$$1;
  AddMarkStep2.prototype = Object.create(Step$$1 && Step$$1.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice11 = new prosemirrorModel$6.Slice(mapFragment(oldSlice.content, function(node18, parent2) {
      if (!parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node18;
      }
      return node18.mark(this$1$1.mark.addToSet(node18.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice11);
  };
  AddMarkStep2.prototype.invert = function invert4() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map19(mapping) {
    var from12 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from12.deleted && to.deleted || from12.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from12.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(
        Math.min(this.from, other.from),
        Math.max(this.to, other.to),
        this.mark
      );
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON31() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON32(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema2.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step);
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = function(Step$$1) {
  function RemoveMarkStep2(from12, to, mark15) {
    Step$$1.call(this);
    this.from = from12;
    this.to = to;
    this.mark = mark15;
  }
  if (Step$$1)
    RemoveMarkStep2.__proto__ = Step$$1;
  RemoveMarkStep2.prototype = Object.create(Step$$1 && Step$$1.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice11 = new prosemirrorModel$6.Slice(mapFragment(oldSlice.content, function(node18) {
      return node18.mark(this$1$1.mark.removeFromSet(node18.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice11);
  };
  RemoveMarkStep2.prototype.invert = function invert4() {
    return new AddMarkStep(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map19(mapping) {
    var from12 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from12.deleted && to.deleted || from12.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from12.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(
        Math.min(this.from, other.from),
        Math.max(this.to, other.to),
        this.mark
      );
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON31() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON32(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema2.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
Transform.prototype.addMark = function(from12, to, mark15) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from12, to, function(node18, pos, parent) {
    if (!node18.isInline) {
      return;
    }
    var marks9 = node18.marks;
    if (!mark15.isInSet(marks9) && parent.type.allowsMarkType(mark15.type)) {
      var start16 = Math.max(pos, from12), end8 = Math.min(pos + node18.nodeSize, to);
      var newSet = mark15.addToSet(marks9);
      for (var i = 0; i < marks9.length; i++) {
        if (!marks9[i].isInSet(newSet)) {
          if (removing && removing.to == start16 && removing.mark.eq(marks9[i])) {
            removing.to = end8;
          } else {
            removed.push(removing = new RemoveMarkStep(start16, end8, marks9[i]));
          }
        }
      }
      if (adding && adding.to == start16) {
        adding.to = end8;
      } else {
        added.push(adding = new AddMarkStep(start16, end8, mark15));
      }
    }
  });
  removed.forEach(function(s) {
    return this$1$1.step(s);
  });
  added.forEach(function(s) {
    return this$1$1.step(s);
  });
  return this;
};
Transform.prototype.removeMark = function(from12, to, mark15) {
  var this$1$1 = this;
  if (mark15 === void 0)
    mark15 = null;
  var matched = [], step3 = 0;
  this.doc.nodesBetween(from12, to, function(node18, pos) {
    if (!node18.isInline) {
      return;
    }
    step3++;
    var toRemove = null;
    if (mark15 instanceof prosemirrorModel$6.MarkType) {
      var found2 = mark15.isInSet(node18.marks);
      if (found2) {
        toRemove = [found2];
      }
    } else if (mark15) {
      if (mark15.isInSet(node18.marks)) {
        toRemove = [mark15];
      }
    } else {
      toRemove = node18.marks;
    }
    if (toRemove && toRemove.length) {
      var end8 = Math.min(pos + node18.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style2 = toRemove[i], found$12 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m2 = matched[j];
          if (m2.step == step3 - 1 && style2.eq(matched[j].style)) {
            found$12 = m2;
          }
        }
        if (found$12) {
          found$12.to = end8;
          found$12.step = step3;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from12), to: end8, step: step3 });
        }
      }
    }
  });
  matched.forEach(function(m2) {
    return this$1$1.step(new RemoveMarkStep(m2.from, m2.to, m2.style));
  });
  return this;
};
Transform.prototype.clearIncompatible = function(pos, parentType, match2) {
  var this$1$1 = this;
  if (match2 === void 0)
    match2 = parentType.contentMatch;
  var node18 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node18.childCount; i++) {
    var child15 = node18.child(i), end8 = cur + child15.nodeSize;
    var allowed = match2.matchType(child15.type, child15.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end8, prosemirrorModel$6.Slice.empty));
    } else {
      match2 = allowed;
      for (var j = 0; j < child15.marks.length; j++) {
        if (!parentType.allowsMarkType(child15.marks[j].type)) {
          this$1$1.step(new RemoveMarkStep(cur, end8, child15.marks[j]));
        }
      }
    }
    cur = end8;
  }
  if (!match2.validEnd) {
    var fill = match2.fillBefore(prosemirrorModel$6.Fragment.empty, true);
    this.replace(cur, cur, new prosemirrorModel$6.Slice(fill, 0, 0));
  }
  for (var i$12 = delSteps.length - 1; i$12 >= 0; i$12--) {
    this$1$1.step(delSteps[i$12]);
  }
  return this;
};
function replaceStep(doc2, from12, to, slice11) {
  if (to === void 0)
    to = from12;
  if (slice11 === void 0)
    slice11 = prosemirrorModel$6.Slice.empty;
  if (from12 == to && !slice11.size) {
    return null;
  }
  var $from = doc2.resolve(from12), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice11)) {
    return new ReplaceStep(from12, to, slice11);
  }
  var placed = placeSlice($from, slice11);
  var fittedLeft = fitLeft($from, placed);
  var fitted = fitRight($from, $to, fittedLeft);
  if (!fitted) {
    return null;
  }
  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {
    var d = $to.depth, after8 = $to.after(d);
    while (d > 1 && after8 == $to.end(--d)) {
      ++after8;
    }
    var fittedAfter = fitRight($from, doc2.resolve(after8), fittedLeft);
    if (fittedAfter) {
      return new ReplaceAroundStep(from12, after8, to, $to.end(), fittedAfter, fittedLeft.size);
    }
  }
  return fitted.size || from12 != to ? new ReplaceStep(from12, to, fitted) : null;
}
Transform.prototype.replace = function(from12, to, slice11) {
  if (to === void 0)
    to = from12;
  if (slice11 === void 0)
    slice11 = prosemirrorModel$6.Slice.empty;
  var step3 = replaceStep(this.doc, from12, to, slice11);
  if (step3) {
    this.step(step3);
  }
  return this;
};
Transform.prototype.replaceWith = function(from12, to, content2) {
  return this.replace(from12, to, new prosemirrorModel$6.Slice(prosemirrorModel$6.Fragment.from(content2), 0, 0));
};
Transform.prototype.delete = function(from12, to) {
  return this.replace(from12, to, prosemirrorModel$6.Slice.empty);
};
Transform.prototype.insert = function(pos, content2) {
  return this.replaceWith(pos, pos, content2);
};
function fitLeftInner($from, depth, placed, placedBelow) {
  var content2 = prosemirrorModel$6.Fragment.empty, openEnd = 0, placedHere = placed[depth];
  if ($from.depth > depth) {
    var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere);
    openEnd = inner.openEnd + 1;
    content2 = prosemirrorModel$6.Fragment.from($from.node(depth + 1).copy(inner.content));
  }
  if (placedHere) {
    content2 = content2.append(placedHere.content);
    openEnd = placedHere.openEnd;
  }
  if (placedBelow) {
    content2 = content2.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(prosemirrorModel$6.Fragment.empty, true));
    openEnd = 0;
  }
  return { content: content2, openEnd };
}
function fitLeft($from, placed) {
  var ref = fitLeftInner($from, 0, placed, false);
  var content2 = ref.content;
  var openEnd = ref.openEnd;
  return new prosemirrorModel$6.Slice(content2, $from.depth, openEnd || 0);
}
function fitRightJoin(content2, parent, $from, $to, depth, openStart, openEnd) {
  var match2, count = content2.childCount, matchCount = count - (openEnd > 0 ? 1 : 0);
  var parentNode2 = openStart < 0 ? parent : $from.node(depth);
  if (openStart < 0) {
    match2 = parentNode2.contentMatchAt(matchCount);
  } else if (count == 1 && openEnd > 0) {
    match2 = parentNode2.contentMatchAt(openStart ? $from.index(depth) : $from.indexAfter(depth));
  } else {
    match2 = parentNode2.contentMatchAt($from.indexAfter(depth)).matchFragment(content2, count > 0 && openStart ? 1 : 0, matchCount);
  }
  var toNode = $to.node(depth);
  if (openEnd > 0 && depth < $to.depth) {
    var after8 = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content2.lastChild);
    var joinable$12 = match2.fillBefore(after8, true);
    if (joinable$12 && joinable$12.size && openStart > 0 && count == 1) {
      joinable$12 = null;
    }
    if (joinable$12) {
      var inner = fitRightJoin(
        content2.lastChild.content,
        content2.lastChild,
        $from,
        $to,
        depth + 1,
        count == 1 ? openStart - 1 : -1,
        openEnd - 1
      );
      if (inner) {
        var last = content2.lastChild.copy(inner);
        if (joinable$12.size) {
          return content2.cutByIndex(0, count - 1).append(joinable$12).addToEnd(last);
        } else {
          return content2.replaceChild(count - 1, last);
        }
      }
    }
  }
  if (openEnd > 0) {
    match2 = match2.matchType((count == 1 && openStart > 0 ? $from.node(depth + 1) : content2.lastChild).type);
  }
  var toIndex = $to.index(depth);
  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) {
    return null;
  }
  var joinable2 = match2.fillBefore(toNode.content, true, toIndex);
  for (var i = toIndex; joinable2 && i < toNode.content.childCount; i++) {
    if (!parentNode2.type.allowsMarks(toNode.content.child(i).marks)) {
      joinable2 = null;
    }
  }
  if (!joinable2) {
    return null;
  }
  if (openEnd > 0) {
    var closed = fitRightClosed(
      content2.lastChild,
      openEnd - 1,
      $from,
      depth + 1,
      count == 1 ? openStart - 1 : -1
    );
    content2 = content2.replaceChild(count - 1, closed);
  }
  content2 = content2.append(joinable2);
  if ($to.depth > depth) {
    content2 = content2.addToEnd(fitRightSeparate($to, depth + 1));
  }
  return content2;
}
function fitRightClosed(node18, openEnd, $from, depth, openStart) {
  var match2, content2 = node18.content, count = content2.childCount;
  if (openStart >= 0) {
    match2 = $from.node(depth).contentMatchAt($from.indexAfter(depth)).matchFragment(content2, openStart > 0 ? 1 : 0, count);
  } else {
    match2 = node18.contentMatchAt(count);
  }
  if (openEnd > 0) {
    var closed = fitRightClosed(
      content2.lastChild,
      openEnd - 1,
      $from,
      depth + 1,
      count == 1 ? openStart - 1 : -1
    );
    content2 = content2.replaceChild(count - 1, closed);
  }
  return node18.copy(content2.append(match2.fillBefore(prosemirrorModel$6.Fragment.empty, true)));
}
function fitRightSeparate($to, depth) {
  var node18 = $to.node(depth);
  var fill = node18.contentMatchAt(0).fillBefore(node18.content, true, $to.index(depth));
  if ($to.depth > depth) {
    fill = fill.addToEnd(fitRightSeparate($to, depth + 1));
  }
  return node18.copy(fill);
}
function normalizeSlice(content2, openStart, openEnd) {
  while (openStart > 0 && openEnd > 0 && content2.childCount == 1) {
    content2 = content2.firstChild.content;
    openStart--;
    openEnd--;
  }
  return new prosemirrorModel$6.Slice(content2, openStart, openEnd);
}
function fitRight($from, $to, slice11) {
  var fitted = fitRightJoin(slice11.content, $from.node(0), $from, $to, 0, slice11.openStart, slice11.openEnd);
  if (!fitted) {
    return null;
  }
  return normalizeSlice(fitted, slice11.openStart, $to.depth);
}
function fitsTrivially($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
function canMoveText($from, $to, slice11) {
  if (!$to.parent.isTextblock) {
    return false;
  }
  var parent = slice11.openEnd ? nodeRight(slice11.content, slice11.openEnd) : $from.node($from.depth - (slice11.openStart - slice11.openEnd));
  if (!parent.isTextblock) {
    return false;
  }
  for (var i = $to.index(); i < $to.parent.childCount; i++) {
    if (!parent.type.allowsMarks($to.parent.child(i).marks)) {
      return false;
    }
  }
  var match2;
  if (slice11.openEnd) {
    match2 = parent.contentMatchAt(parent.childCount);
  } else {
    match2 = parent.contentMatchAt(parent.childCount);
    if (slice11.size) {
      match2 = match2.matchFragment(slice11.content, slice11.openStart ? 1 : 0);
    }
  }
  match2 = match2.matchFragment($to.parent.content, $to.index());
  return match2 && match2.validEnd;
}
function nodeRight(content2, depth) {
  for (var i = 1; i < depth; i++) {
    content2 = content2.lastChild.content;
  }
  return content2.lastChild;
}
function placeSlice($from, slice11) {
  var frontier = new Frontier($from);
  for (var pass = 1; slice11.size && pass <= 3; pass++) {
    slice11 = frontier.placeSlice(slice11.content, slice11.openStart, slice11.openEnd, pass);
  }
  while (frontier.open.length) {
    frontier.closeNode();
  }
  return frontier.placed;
}
var Frontier = function Frontier2($pos) {
  var this$1$1 = this;
  this.open = [];
  for (var d = 0; d <= $pos.depth; d++) {
    var parent = $pos.node(d), match2 = parent.contentMatchAt($pos.indexAfter(d));
    this$1$1.open.push({ parent, match: match2, content: prosemirrorModel$6.Fragment.empty, wrapper: false, openEnd: 0, depth: d });
  }
  this.placed = [];
};
Frontier.prototype.placeSlice = function placeSlice2(fragment, openStart, openEnd, pass, parent) {
  var this$1$1 = this;
  if (openStart > 0) {
    var first = fragment.firstChild;
    var inner = this.placeSlice(
      first.content,
      Math.max(0, openStart - 1),
      openEnd && fragment.childCount == 1 ? openEnd - 1 : 0,
      pass,
      first
    );
    if (inner.content != first.content) {
      if (inner.content.size) {
        fragment = fragment.replaceChild(0, first.copy(inner.content));
        openStart = inner.openStart + 1;
      } else {
        if (fragment.childCount == 1) {
          openEnd = 0;
        }
        fragment = fragment.cutByIndex(1);
        openStart = 0;
      }
    }
  }
  var result2 = this.placeContent(fragment, openStart, openEnd, pass, parent);
  if (pass > 2 && result2.size && openStart == 0) {
    for (var i = 0; i < result2.content.childCount; i++) {
      var child15 = result2.content.child(i);
      this$1$1.placeContent(
        child15.content,
        0,
        openEnd && i == result2.content.childCount.length - 1 ? openEnd - 1 : 0,
        pass,
        child15
      );
    }
    result2 = prosemirrorModel$6.Fragment.empty;
  }
  return result2;
};
Frontier.prototype.placeContent = function placeContent(fragment, openStart, openEnd, pass, parent) {
  var this$1$1 = this;
  var i = 0;
  for (; i < fragment.childCount; i++) {
    var child15 = fragment.child(i), placed = false, last = i == fragment.childCount - 1;
    for (var d = this.open.length - 1; d >= 0; d--) {
      var open = this$1$1.open[d], wrap2 = void 0;
      if (pass > 1 && (wrap2 = open.match.findWrapping(child15.type)) && !(parent && wrap2.length && wrap2[wrap2.length - 1] == parent.type)) {
        while (this.open.length - 1 > d) {
          this$1$1.closeNode();
        }
        for (var w = 0; w < wrap2.length; w++) {
          open.match = open.match.matchType(wrap2[w]);
          d++;
          open = {
            parent: wrap2[w].create(),
            match: wrap2[w].contentMatch,
            content: prosemirrorModel$6.Fragment.empty,
            wrapper: true,
            openEnd: 0,
            depth: d + w
          };
          this$1$1.open.push(open);
        }
      }
      var match2 = open.match.matchType(child15.type);
      if (!match2) {
        var fill = open.match.fillBefore(prosemirrorModel$6.Fragment.from(child15));
        if (fill) {
          for (var j = 0; j < fill.childCount; j++) {
            var ch2 = fill.child(j);
            this$1$1.addNode(open, ch2, 0);
            match2 = open.match.matchFragment(ch2);
          }
        } else if (parent && open.match.matchType(parent.type)) {
          break;
        } else {
          continue;
        }
      }
      while (this.open.length - 1 > d) {
        this$1$1.closeNode();
      }
      child15 = child15.mark(open.parent.type.allowedMarks(child15.marks));
      if (openStart) {
        child15 = closeNodeStart(child15, openStart, last ? openEnd : 0);
        openStart = 0;
      }
      this$1$1.addNode(open, child15, last ? openEnd : 0);
      open.match = match2;
      if (last) {
        openEnd = 0;
      }
      placed = true;
      break;
    }
    if (!placed) {
      break;
    }
  }
  if (this.open.length > 1 && (i > 0 && i == fragment.childCount || parent && this.open[this.open.length - 1].parent.type == parent.type)) {
    this.closeNode();
  }
  return new prosemirrorModel$6.Slice(fragment.cutByIndex(i), openStart, openEnd);
};
Frontier.prototype.addNode = function addNode(open, node18, openEnd) {
  open.content = closeFragmentEnd(open.content, open.openEnd).addToEnd(node18);
  open.openEnd = openEnd;
};
Frontier.prototype.closeNode = function closeNode() {
  var open = this.open.pop();
  if (open.content.size == 0)
    ;
  else if (open.wrapper) {
    this.addNode(this.open[this.open.length - 1], open.parent.copy(open.content), open.openEnd + 1);
  } else {
    this.placed[open.depth] = { depth: open.depth, content: open.content, openEnd: open.openEnd };
  }
};
function closeNodeStart(node18, openStart, openEnd) {
  var content2 = node18.content;
  if (openStart > 1) {
    var first = closeNodeStart(node18.firstChild, openStart - 1, node18.childCount == 1 ? openEnd - 1 : 0);
    content2 = node18.content.replaceChild(0, first);
  }
  var fill = node18.type.contentMatch.fillBefore(content2, openEnd == 0);
  return node18.copy(fill.append(content2));
}
function closeNodeEnd(node18, depth) {
  var content2 = node18.content;
  if (depth > 1) {
    var last = closeNodeEnd(node18.lastChild, depth - 1);
    content2 = node18.content.replaceChild(node18.childCount - 1, last);
  }
  var fill = node18.contentMatchAt(node18.childCount).fillBefore(prosemirrorModel$6.Fragment.empty, true);
  return node18.copy(content2.append(fill));
}
function closeFragmentEnd(fragment, depth) {
  return depth ? fragment.replaceChild(fragment.childCount - 1, closeNodeEnd(fragment.lastChild, depth)) : fragment;
}
Transform.prototype.replaceRange = function(from12, to, slice11) {
  var this$1$1 = this;
  if (!slice11.size) {
    return this.deleteRange(from12, to);
  }
  var $from = this.doc.resolve(from12), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice11)) {
    return this.step(new ReplaceStep(from12, to, slice11));
  }
  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d) > -1) {
      preferredTarget = d;
    } else if ($from.before(d) == pos) {
      targetDepths.splice(1, 0, -d);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice11.openStart;
  for (var content2 = slice11.content, i = 0; ; i++) {
    var node18 = content2.firstChild;
    leftNodes.push(node18);
    if (i == slice11.openStart) {
      break;
    }
    content2 = node18.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice11.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$12 = 0; i$12 < targetDepths.length; i$12++) {
      var targetDepth = targetDepths[(i$12 + preferredTargetIndex) % targetDepths.length], expand3 = true;
      if (targetDepth < 0) {
        expand3 = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index8 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index8, index8, insert.type, insert.marks)) {
        return this$1$1.replace(
          $from.before(targetDepth),
          expand3 ? $to.after(targetDepth) : to,
          new prosemirrorModel$6.Slice(
            closeFragment(slice11.content, 0, slice11.openStart, openDepth),
            openDepth,
            slice11.openEnd
          )
        );
      }
    }
  }
  return this.replace(from12, to, slice11);
};
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    fragment = parent.contentMatchAt(0).fillBefore(fragment, true).append(fragment);
  }
  return fragment;
}
Transform.prototype.replaceRangeWith = function(from12, to, node18) {
  if (!node18.isInline && from12 == to && this.doc.resolve(from12).parent.content.size) {
    var point = insertPoint(this.doc, from12, node18.type);
    if (point != null) {
      from12 = to = point;
    }
  }
  return this.replaceRange(from12, to, new prosemirrorModel$6.Slice(prosemirrorModel$6.Fragment.from(node18), 0, 0));
};
Transform.prototype.deleteRange = function(from12, to) {
  var this$1$1 = this;
  var $from = this.doc.resolve(from12), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this$1$1.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this$1$1.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d = 1; d <= $from.depth; d++) {
    if (from12 - $from.start(d) == $from.depth - d && to > $from.end(d)) {
      return this$1$1.delete($from.before(d), to);
    }
  }
  return this.delete(from12, to);
};
function coveredDepths($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start16 = $from.start(d);
    if (start16 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start16 == $to.start(d)) {
      result2.push(d);
    }
  }
  return result2;
}
var Transform_1 = dist$c.Transform = Transform;
dist$c.TransformError = TransformError;
dist$c.Step = Step;
dist$c.StepResult = StepResult;
dist$c.joinPoint = joinPoint;
dist$c.canJoin = canJoin;
dist$c.canSplit = canSplit;
dist$c.insertPoint = insertPoint;
var dropPoint_1 = dist$c.dropPoint = dropPoint;
dist$c.liftTarget = liftTarget;
dist$c.findWrapping = findWrapping5;
dist$c.StepMap = StepMap;
dist$c.MapResult = MapResult;
dist$c.Mapping = Mapping;
dist$c.AddMarkStep = AddMarkStep;
dist$c.RemoveMarkStep = RemoveMarkStep;
var ReplaceStep_1 = dist$c.ReplaceStep = ReplaceStep;
var ReplaceAroundStep_1 = dist$c.ReplaceAroundStep = ReplaceAroundStep;
dist$c.replaceStep = replaceStep;
Object.defineProperty(dist$e, "__esModule", { value: true });
var prosemirrorModel$5 = dist$d;
var prosemirrorTransform$6 = dist$c;
var classesById$1 = /* @__PURE__ */ Object.create(null);
var Selection$1 = function Selection($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange$1($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$d = { anchor: {}, head: {}, from: {}, to: {}, $from: {}, $to: {}, empty: {} };
prototypeAccessors$d.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$d.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$d.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$d.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$d.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$d.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$d.empty.get = function() {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    if (ranges[i].$from.pos != ranges[i].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection$1.prototype.content = function content() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection$1.prototype.replace = function replace(tr, content2) {
  if (content2 === void 0)
    content2 = prosemirrorModel$5.Slice.empty;
  var lastNode = content2.content.lastChild, lastParent = null;
  for (var i = 0; i < content2.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$12 = 0; i$12 < ranges.length; i$12++) {
    var ref = ranges[i$12];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$12 ? prosemirrorModel$5.Slice.empty : content2);
    if (i$12 == 0) {
      selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection$1.prototype.replaceWith = function replaceWith(tr, node18) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref = ranges[i];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from12 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from12, to);
    } else {
      tr.replaceRangeWith(from12, to, node18);
      selectionToInsertionEnd$1(tr, mapFrom, node18.isInline ? -1 : 1);
    }
  }
};
Selection$1.findFrom = function findFrom($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection$1($pos) : findSelectionIn$1($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn$1($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn$1($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection$1.near = function near($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection$1($pos.node(0));
};
Selection$1.atStart = function atStart(doc2) {
  return findSelectionIn$1(doc2, doc2, 0, 0, 1) || new AllSelection$1(doc2);
};
Selection$1.atEnd = function atEnd(doc2) {
  return findSelectionIn$1(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection$1(doc2);
};
Selection$1.fromJSON = function fromJSON10(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById$1[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection$1.jsonID = function jsonID2(id2, selectionClass) {
  if (id2 in classesById$1) {
    throw new RangeError("Duplicate use of selection JSON ID " + id2);
  }
  classesById$1[id2] = selectionClass;
  selectionClass.prototype.jsonID = id2;
  return selectionClass;
};
Selection$1.prototype.getBookmark = function getBookmark() {
  return TextSelection$1.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection$1.prototype, prototypeAccessors$d);
Selection$1.prototype.visible = true;
var SelectionRange$1 = function SelectionRange($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection$1 = function(Selection3) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection3.call(this, $anchor, $head);
  }
  if (Selection3)
    TextSelection2.__proto__ = Selection3;
  TextSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: {} };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map19(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection3.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace3(tr, content2) {
    if (content2 === void 0)
      content2 = prosemirrorModel$5.Slice.empty;
    Selection3.prototype.replace.call(this, tr, content2);
    if (content2 == prosemirrorModel$5.Slice.empty) {
      var marks9 = this.$from.marksAcross(this.$to);
      if (marks9) {
        tr.ensureMarks(marks9);
      }
    }
  };
  TextSelection2.prototype.eq = function eq41(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark2() {
    return new TextBookmark$1(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON31() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON32(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create22(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection3.findFrom($head, bias, true) || Selection3.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection3.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection3.findFrom($anchor, -bias, true) || Selection3.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection$1);
Selection$1.jsonID("text", TextSelection$1);
var TextBookmark$1 = function TextBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark$1.prototype.map = function map4(mapping) {
  return new TextBookmark$1(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark$1.prototype.resolve = function resolve5(doc2) {
  return TextSelection$1.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection$1 = function(Selection3) {
  function NodeSelection2($pos) {
    var node18 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node18.nodeSize);
    Selection3.call(this, $pos, $end);
    this.node = node18;
  }
  if (Selection3)
    NodeSelection2.__proto__ = Selection3;
  NodeSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map19(doc2, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection3.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content2() {
    return new prosemirrorModel$5.Slice(prosemirrorModel$5.Fragment.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq41(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON31() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark2() {
    return new NodeBookmark$1(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON32(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create22(doc2, from12) {
    return new this(doc2.resolve(from12));
  };
  NodeSelection2.isSelectable = function isSelectable(node18) {
    return !node18.isText && node18.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection$1);
NodeSelection$1.prototype.visible = false;
Selection$1.jsonID("node", NodeSelection$1);
var NodeBookmark$1 = function NodeBookmark(anchor) {
  this.anchor = anchor;
};
NodeBookmark$1.prototype.map = function map5(mapping) {
  var ref = mapping.mapResult(this.anchor);
  var deleted = ref.deleted;
  var pos = ref.pos;
  return deleted ? new TextBookmark$1(pos, pos) : new NodeBookmark$1(pos);
};
NodeBookmark$1.prototype.resolve = function resolve6(doc2) {
  var $pos = doc2.resolve(this.anchor), node18 = $pos.nodeAfter;
  if (node18 && NodeSelection$1.isSelectable(node18)) {
    return new NodeSelection$1($pos);
  }
  return Selection$1.near($pos);
};
var AllSelection$1 = function(Selection3) {
  function AllSelection2(doc2) {
    Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection3)
    AllSelection2.__proto__ = Selection3;
  AllSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.toJSON = function toJSON31() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON32(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map19(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq41(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark2() {
    return AllBookmark$1;
  };
  return AllSelection2;
}(Selection$1);
Selection$1.jsonID("all", AllSelection$1);
var AllBookmark$1 = {
  map: function map6() {
    return this;
  },
  resolve: function resolve7(doc2) {
    return new AllSelection$1(doc2);
  }
};
function findSelectionIn$1(doc2, node18, pos, index8, dir, text8) {
  if (node18.inlineContent) {
    return TextSelection$1.create(doc2, pos);
  }
  for (var i = index8 - (dir > 0 ? 0 : 1); dir > 0 ? i < node18.childCount : i >= 0; i += dir) {
    var child15 = node18.child(i);
    if (!child15.isAtom) {
      var inner = findSelectionIn$1(doc2, child15, pos + dir, dir < 0 ? child15.childCount : 0, dir, text8);
      if (inner) {
        return inner;
      }
    } else if (!text8 && NodeSelection$1.isSelectable(child15)) {
      return NodeSelection$1.create(doc2, pos - (dir < 0 ? child15.nodeSize : 0));
    }
    pos += child15.nodeSize * dir;
  }
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step3 = tr.steps[last];
  if (!(step3 instanceof prosemirrorTransform$6.ReplaceStep || step3 instanceof prosemirrorTransform$6.ReplaceAroundStep)) {
    return;
  }
  var map19 = tr.mapping.maps[last], end8;
  map19.forEach(function(_from, _to, _newFrom, newTo) {
    if (end8 == null) {
      end8 = newTo;
    }
  });
  tr.setSelection(Selection$1.near(tr.doc.resolve(end8), bias));
}
var UPDATED_SEL$1 = 1;
var UPDATED_MARKS$1 = 2;
var UPDATED_SCROLL$1 = 4;
var Transaction$1 = function(Transform$$1) {
  function Transaction2(state) {
    Transform$$1.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform$$1)
    Transaction2.__proto__ = Transform$$1;
  Transaction2.prototype = Object.create(Transform$$1 && Transform$$1.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: {}, selectionSet: {}, storedMarksSet: {}, isGeneric: {}, scrolledIntoView: {} };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection3(selection) {
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL$1) & ~UPDATED_MARKS$1;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL$1) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks9) {
    this.storedMarks = marks9;
    this.updated |= UPDATED_MARKS$1;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks(marks9) {
    if (!prosemirrorModel$5.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks9)) {
      this.setStoredMarks(marks9);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark15) {
    return this.ensureMarks(mark15.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark15) {
    return this.ensureMarks(mark15.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS$1) > 0;
  };
  Transaction2.prototype.addStep = function addStep2(step3, doc2) {
    Transform$$1.prototype.addStep.call(this, step3, doc2);
    this.updated = this.updated & ~UPDATED_MARKS$1;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice11) {
    this.selection.replace(this, slice11);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node18, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node18 = node18.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel$5.Mark.none));
    }
    selection.replaceWith(this, node18);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text8, from12, to) {
    if (to === void 0)
      to = from12;
    var schema2 = this.doc.type.schema;
    if (from12 == null) {
      if (!text8) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema2.text(text8), true);
    } else {
      if (!text8) {
        return this.deleteRange(from12, to);
      }
      var marks9 = this.storedMarks;
      if (!marks9) {
        var $from = this.doc.resolve(from12);
        marks9 = to == from12 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      return this.replaceRangeWith(from12, to, schema2.text(text8, marks9));
    }
  };
  Transaction2.prototype.setMeta = function setMeta2(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    var this$1$1 = this;
    for (var _ in this$1$1.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView() {
    this.updated |= UPDATED_SCROLL$1;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL$1) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(prosemirrorTransform$6.Transform);
function bind$1(f2, self2) {
  return !self2 || !f2 ? f2 : f2.bind(self2);
}
var FieldDesc$1 = function FieldDesc(name, desc, self2) {
  this.name = name;
  this.init = bind$1(desc.init, self2);
  this.apply = bind$1(desc.apply, self2);
};
var baseFields$1 = [
  new FieldDesc$1("doc", {
    init: function init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply: function apply2(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc$1("selection", {
    init: function init2(config, instance) {
      return config.selection || Selection$1.atStart(instance.doc);
    },
    apply: function apply3(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc$1("storedMarks", {
    init: function init3(config) {
      return config.storedMarks || null;
    },
    apply: function apply4(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc$1("scrollToSelection", {
    init: function init4() {
      return 0;
    },
    apply: function apply5(tr, prev2) {
      return tr.scrolledIntoView ? prev2 + 1 : prev2;
    }
  })
];
var Configuration$1 = function Configuration(schema2, plugins) {
  var this$1$1 = this;
  this.schema = schema2;
  this.fields = baseFields$1.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc$1(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState$1 = function EditorState(config) {
  this.config = config;
};
var prototypeAccessors$1$a = { schema: {}, plugins: {}, tr: {} };
prototypeAccessors$1$a.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$a.plugins.get = function() {
  return this.config.plugins;
};
EditorState$1.prototype.apply = function apply6(tr) {
  return this.applyTransaction(tr).state;
};
EditorState$1.prototype.filterTransaction = function filterTransaction(tr, ignore) {
  var this$1$1 = this;
  if (ignore === void 0)
    ignore = -1;
  for (var i = 0; i < this.config.plugins.length; i++) {
    if (i != ignore) {
      var plugin = this$1$1.config.plugins[i];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this$1$1)) {
        return false;
      }
    }
  }
  return true;
};
EditorState$1.prototype.applyTransaction = function applyTransaction(rootTr) {
  var this$1$1 = this;
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this$1$1.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n2 = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this$1$1;
        var tr = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++) {
              seen.push(j < i ? { state: newState, n: trs.length } : { state: this$1$1, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState$1.prototype.applyInner = function applyInner(tr) {
  var this$1$1 = this;
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState$1(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this$1$1[field.name], this$1$1, newInstance);
  }
  for (var i$12 = 0; i$12 < applyListeners.length; i$12++) {
    applyListeners[i$12](this$1$1, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$a.tr.get = function() {
  return new Transaction$1(this);
};
EditorState$1.create = function create5(config) {
  var $config = new Configuration$1(config.schema || config.doc.type.schema, config.plugins);
  var instance = new EditorState$1($config);
  for (var i = 0; i < $config.fields.length; i++) {
    instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
  }
  return instance;
};
EditorState$1.prototype.reconfigure = function reconfigure(config) {
  var this$1$1 = this;
  var $config = new Configuration$1(config.schema || this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState$1($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this$1$1.hasOwnProperty(name) ? this$1$1[name] : fields[i].init(config, instance);
  }
  return instance;
};
EditorState$1.prototype.toJSON = function toJSON10(pluginFields) {
  var this$1$1 = this;
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m2) {
      return m2.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this$1$1[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState$1.fromJSON = function fromJSON11(config, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration$1(config.schema, config.plugins);
  var instance = new EditorState$1($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = prosemirrorModel$5.Node.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection$1.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance;
};
EditorState$1.addApplyListener = function addApplyListener(f2) {
  applyListeners.push(f2);
};
EditorState$1.removeApplyListener = function removeApplyListener(f2) {
  var found2 = applyListeners.indexOf(f2);
  if (found2 > -1) {
    applyListeners.splice(found2, 1);
  }
};
Object.defineProperties(EditorState$1.prototype, prototypeAccessors$1$a);
var applyListeners = [];
function bindProps(obj, self2, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) {
      val = val.bind(self2);
    } else if (prop == "handleDOMEvents") {
      val = bindProps(val, self2, {});
    }
    target[prop] = val;
  }
  return target;
}
var Plugin = function Plugin2(spec) {
  this.props = {};
  if (spec.props) {
    bindProps(spec.props, this, this.props);
  }
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};
Plugin.prototype.getState = function getState(state) {
  return state[this.key];
};
var keys$2 = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys$2) {
    return name + "$" + ++keys$2[name];
  }
  keys$2[name] = 0;
  return name + "$";
}
var PluginKey = function PluginKey2(name) {
  if (name === void 0)
    name = "key";
  this.key = createKey(name);
};
PluginKey.prototype.get = function get(state) {
  return state.config.pluginsByKey[this.key];
};
PluginKey.prototype.getState = function getState2(state) {
  return state[this.key];
};
var Selection_1 = dist$e.Selection = Selection$1;
dist$e.SelectionRange = SelectionRange$1;
var TextSelection_1 = dist$e.TextSelection = TextSelection$1;
var NodeSelection_1 = dist$e.NodeSelection = NodeSelection$1;
var AllSelection_1 = dist$e.AllSelection = AllSelection$1;
dist$e.Transaction = Transaction$1;
var EditorState_1 = dist$e.EditorState = EditorState$1;
var Plugin_1 = dist$e.Plugin = Plugin;
var PluginKey_1 = dist$e.PluginKey = PluginKey;
function OrderedMap$a(content2) {
  this.content = content2;
}
OrderedMap$a.prototype = {
  constructor: OrderedMap$a,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$a(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$a(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$a([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$a(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$a(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$a.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$a(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$a.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$a(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$a.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$a.from = function(value) {
  if (value instanceof OrderedMap$a)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$a(content2);
};
function findDiffStart$5(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart$5(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$5(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd$5(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
class Fragment$5 {
  constructor(content2, size) {
    this.content = content2;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content2.length; i++)
        this.size += content2[i].nodeSize;
  }
  nodesBetween(from12, to, f2, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child15 = this.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12 && f2(child15, nodeStart + pos, parent || null, i) !== false && child15.content.size) {
        let start16 = pos + 1;
        child15.nodesBetween(Math.max(0, from12 - start16), Math.min(child15.content.size, to - start16), f2, nodeStart + start16);
      }
      pos = end8;
    }
  }
  descendants(f2) {
    this.nodesBetween(0, this.size, f2);
  }
  textBetween(from12, to, blockSeparator, leafText) {
    let text8 = "", separated = true;
    this.nodesBetween(from12, to, (node18, pos) => {
      if (node18.isText) {
        text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node18.isLeaf) {
        if (leafText) {
          text8 += typeof leafText === "function" ? leafText(node18) : leafText;
        } else if (node18.type.spec.leafText) {
          text8 += node18.type.spec.leafText(node18);
        }
        separated = !blockSeparator;
      } else if (!separated && node18.isBlock) {
        text8 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text8;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content2[content2.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content2.push(other.content[i]);
    return new Fragment$5(content2, this.size + other.size);
  }
  cut(from12, to = this.size) {
    if (from12 == 0 && to == this.size)
      return this;
    let result2 = [], size = 0;
    if (to > from12)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child15 = this.content[i], end8 = pos + child15.nodeSize;
        if (end8 > from12) {
          if (pos < from12 || end8 > to) {
            if (child15.isText)
              child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
            else
              child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
          result2.push(child15);
          size += child15.nodeSize;
        }
        pos = end8;
      }
    return new Fragment$5(result2, size);
  }
  cutByIndex(from12, to) {
    if (from12 == to)
      return Fragment$5.empty;
    if (from12 == 0 && to == this.content.length)
      return this;
    return new Fragment$5(this.content.slice(from12, to));
  }
  replaceChild(index8, node18) {
    let current = this.content[index8];
    if (current == node18)
      return this;
    let copy12 = this.content.slice();
    let size = this.size + node18.nodeSize - current.nodeSize;
    copy12[index8] = node18;
    return new Fragment$5(copy12, size);
  }
  addToStart(node18) {
    return new Fragment$5([node18].concat(this.content), this.size + node18.nodeSize);
  }
  addToEnd(node18) {
    return new Fragment$5(this.content.concat(node18), this.size + node18.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index8) {
    let found2 = this.content[index8];
    if (!found2)
      throw new RangeError("Index " + index8 + " out of range for " + this);
    return found2;
  }
  maybeChild(index8) {
    return this.content[index8] || null;
  }
  forEach(f2) {
    for (let i = 0, p2 = 0; i < this.content.length; i++) {
      let child15 = this.content[i];
      f2(child15, p2, i);
      p2 += child15.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart$5(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd$5(this, other, pos, otherPos);
  }
  findIndex(pos, round = -1) {
    if (pos == 0)
      return retIndex$5(0, pos);
    if (pos == this.size)
      return retIndex$5(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end8 = curPos + cur.nodeSize;
      if (end8 >= pos) {
        if (end8 == pos || round > 0)
          return retIndex$5(i + 1, end8);
        return retIndex$5(i, curPos);
      }
      curPos = end8;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  static fromJSON(schema2, value) {
    if (!value)
      return Fragment$5.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment$5(value.map(schema2.nodeFromJSON));
  }
  static fromArray(array) {
    if (!array.length)
      return Fragment$5.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node18 = array[i];
      size += node18.nodeSize;
      if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
      } else if (joined) {
        joined.push(node18);
      }
    }
    return new Fragment$5(joined || array, size);
  }
  static from(nodes2) {
    if (!nodes2)
      return Fragment$5.empty;
    if (nodes2 instanceof Fragment$5)
      return nodes2;
    if (Array.isArray(nodes2))
      return this.fromArray(nodes2);
    if (nodes2.attrs)
      return new Fragment$5([nodes2], nodes2.nodeSize);
    throw new RangeError("Can not convert " + nodes2 + " to a Fragment" + (nodes2.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment$5.empty = new Fragment$5([], 0);
const found$5 = { index: 0, offset: 0 };
function retIndex$5(index8, offset2) {
  found$5.index = index8;
  found$5.offset = offset2;
  return found$5;
}
function compareDeep$5(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep$5(a[i], b[i]))
        return false;
  } else {
    for (let p2 in a)
      if (!(p2 in b) || !compareDeep$5(a[p2], b[p2]))
        return false;
    for (let p2 in b)
      if (!(p2 in a))
        return false;
  }
  return true;
}
class Mark$5 {
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  addToSet(set) {
    let copy12, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy12)
          copy12 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy12)
            copy12 = set.slice(0, i);
          copy12.push(this);
          placed = true;
        }
        if (copy12)
          copy12.push(other);
      }
    }
    if (!copy12)
      copy12 = set.slice();
    if (!placed)
      copy12.push(this);
    return copy12;
  }
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  eq(other) {
    return this == other || this.type == other.type && compareDeep$5(this.attrs, other.attrs);
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  static fromJSON(schema2, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema2.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  static setFrom(marks9) {
    if (!marks9 || Array.isArray(marks9) && marks9.length == 0)
      return Mark$5.none;
    if (marks9 instanceof Mark$5)
      return [marks9];
    let copy12 = marks9.slice();
    copy12.sort((a, b) => a.type.rank - b.type.rank);
    return copy12;
  }
}
Mark$5.none = [];
class ReplaceError$5 extends Error {
}
class Slice$5 {
  constructor(content2, openStart, openEnd) {
    this.content = content2;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment) {
    let content2 = insertInto$5(this.content, pos + this.openStart, fragment);
    return content2 && new Slice$5(content2, this.openStart, this.openEnd);
  }
  removeBetween(from12, to) {
    return new Slice$5(removeRange$5(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema2, json) {
    if (!json)
      return Slice$5.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice$5(Fragment$5.fromJSON(schema2, json.content), openStart, openEnd);
  }
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new Slice$5(fragment, openStart, openEnd);
  }
}
Slice$5.empty = new Slice$5(Fragment$5.empty, 0, 0);
function removeRange$5(content2, from12, to) {
  let { index: index8, offset: offset2 } = content2.findIndex(from12), child15 = content2.maybeChild(index8);
  let { index: indexTo, offset: offsetTo } = content2.findIndex(to);
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content2.replaceChild(index8, child15.copy(removeRange$5(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$5(content2, dist2, insert, parent) {
  let { index: index8, offset: offset2 } = content2.findIndex(dist2), child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert))
      return null;
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  let inner = insertInto$5(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
function replace$6($from, $to, slice11) {
  if (slice11.openStart > $from.depth)
    throw new ReplaceError$5("Inserted content deeper than insertion position");
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd)
    throw new ReplaceError$5("Inconsistent open depths");
  return replaceOuter$5($from, $to, slice11, 0);
}
function replaceOuter$5($from, $to, slice11, depth) {
  let index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    let inner = replaceOuter$5($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$5(node18, replaceTwoWay$5($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content2 = parent.content;
    return close$5(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    let { start: start16, end: end8 } = prepareSliceForReplace$5(slice11, $from);
    return close$5(node18, replaceThreeWay$5($from, start16, end8, $to, depth));
  }
}
function checkJoin$5(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError$5("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$5($before, $after, depth) {
  let node18 = $before.node(depth);
  checkJoin$5(node18, $after.node(depth));
  return node18;
}
function addNode$5(child15, target) {
  let last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last]))
    target[last] = child15.withText(target[last].text + child15.text);
  else
    target.push(child15);
}
function addRange$5($start, $end, depth, target) {
  let node18 = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$5($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode$5(node18.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode$5($end.nodeBefore, target);
}
function close$5(node18, content2) {
  if (!node18.type.validContent(content2))
    throw new ReplaceError$5("Invalid content for node " + node18.type.name);
  return node18.copy(content2);
}
function replaceThreeWay$5($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$5($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$5($end, $to, depth + 1);
  let content2 = [];
  addRange$5(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$5(openStart, openEnd);
    addNode$5(close$5(openStart, replaceThreeWay$5($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart)
      addNode$5(close$5(openStart, replaceTwoWay$5($from, $start, depth + 1)), content2);
    addRange$5($start, $end, depth, content2);
    if (openEnd)
      addNode$5(close$5(openEnd, replaceTwoWay$5($end, $to, depth + 1)), content2);
  }
  addRange$5($to, null, depth, content2);
  return new Fragment$5(content2);
}
function replaceTwoWay$5($from, $to, depth) {
  let content2 = [];
  addRange$5(null, $from, depth, content2);
  if ($from.depth > depth) {
    let type = joinable$5($from, $to, depth + 1);
    addNode$5(close$5(type, replaceTwoWay$5($from, $to, depth + 1)), content2);
  }
  addRange$5($to, null, depth, content2);
  return new Fragment$5(content2);
}
function prepareSliceForReplace$5(slice11, $along) {
  let extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  let node18 = parent.copy(slice11.content);
  for (let i = extra - 1; i >= 0; i--)
    node18 = $along.node(i).copy(Fragment$5.from(node18));
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
class ResolvedPos$5 {
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let parent = this.parent, index8 = this.index(this.depth);
    if (index8 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
    return dOff ? parent.child(index8).cut(dOff) : child15;
  }
  get nodeBefore() {
    let index8 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index8).cut(0, dOff);
    return index8 == 0 ? null : this.parent.child(index8 - 1);
  }
  posAtIndex(index8, depth) {
    depth = this.resolveDepth(depth);
    let node18 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index8; i++)
      pos += node18.child(i).nodeSize;
    return pos;
  }
  marks() {
    let parent = this.parent, index8 = this.index();
    if (parent.content.size == 0)
      return Mark$5.none;
    if (this.textOffset)
      return parent.child(index8).marks;
    let main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks9 = main.marks;
    for (var i = 0; i < marks9.length; i++)
      if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks)))
        marks9 = marks9[i--].removeFromSet(marks9);
    return marks9;
  }
  marksAcross($end) {
    let after8 = this.parent.maybeChild(this.index());
    if (!after8 || !after8.isInline)
      return null;
    let marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks9.length; i++)
      if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks)))
        marks9 = marks9[i--].removeFromSet(marks9);
    return marks9;
  }
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange$5(this, other, d);
    return null;
  }
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start16 = 0, parentOffset = pos;
    for (let node18 = doc2; ; ) {
      let { index: index8, offset: offset2 } = node18.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node18, index8, start16 + offset2);
      if (!rem)
        break;
      node18 = node18.child(index8);
      if (node18.isText)
        break;
      parentOffset = rem - 1;
      start16 += offset2 + 1;
    }
    return new ResolvedPos$5(pos, path, parentOffset);
  }
  static resolveCached(doc2, pos) {
    for (let i = 0; i < resolveCache$5.length; i++) {
      let cached = resolveCache$5[i];
      if (cached.pos == pos && cached.doc == doc2)
        return cached;
    }
    let result2 = resolveCache$5[resolveCachePos$5] = ResolvedPos$5.resolve(doc2, pos);
    resolveCachePos$5 = (resolveCachePos$5 + 1) % resolveCacheSize$5;
    return result2;
  }
}
let resolveCache$5 = [], resolveCachePos$5 = 0, resolveCacheSize$5 = 12;
class NodeRange$5 {
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs$5 = /* @__PURE__ */ Object.create(null);
class Node$6 {
  constructor(type, attrs, content2, marks9 = Mark$5.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks9;
    this.content = content2 || Fragment$5.empty;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(index8) {
    return this.content.child(index8);
  }
  maybeChild(index8) {
    return this.content.maybeChild(index8);
  }
  forEach(f2) {
    this.content.forEach(f2);
  }
  nodesBetween(from12, to, f2, startPos = 0) {
    this.content.nodesBetween(from12, to, f2, startPos, this);
  }
  descendants(f2) {
    this.nodesBetween(0, this.content.size, f2);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  textBetween(from12, to, blockSeparator, leafText) {
    return this.content.textBetween(from12, to, blockSeparator, leafText);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  hasMarkup(type, attrs, marks9) {
    return this.type == type && compareDeep$5(this.attrs, attrs || type.defaultAttrs || emptyAttrs$5) && Mark$5.sameSet(this.marks, marks9 || Mark$5.none);
  }
  copy(content2 = null) {
    if (content2 == this.content)
      return this;
    return new Node$6(this.type, this.attrs, content2, this.marks);
  }
  mark(marks9) {
    return marks9 == this.marks ? this : new Node$6(this.type, this.attrs, this.content, marks9);
  }
  cut(from12, to = this.content.size) {
    if (from12 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from12, to));
  }
  slice(from12, to = this.content.size, includeParents = false) {
    if (from12 == to)
      return Slice$5.empty;
    let $from = this.resolve(from12), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start16 = $from.start(depth), node18 = $from.node(depth);
    let content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
    return new Slice$5(content2, $from.depth - depth, $to.depth - depth);
  }
  replace(from12, to, slice11) {
    return replace$6(this.resolve(from12), this.resolve(to), slice11);
  }
  nodeAt(pos) {
    for (let node18 = this; ; ) {
      let { index: index8, offset: offset2 } = node18.content.findIndex(pos);
      node18 = node18.maybeChild(index8);
      if (!node18)
        return null;
      if (offset2 == pos || node18.isText)
        return node18;
      pos -= offset2 + 1;
    }
  }
  childAfter(pos) {
    let { index: index8, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
  }
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index8, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index8), index: index8, offset: offset2 };
    let node18 = this.content.child(index8 - 1);
    return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
  }
  resolve(pos) {
    return ResolvedPos$5.resolveCached(this, pos);
  }
  resolveNoCache(pos) {
    return ResolvedPos$5.resolve(this, pos);
  }
  rangeHasMark(from12, to, type) {
    let found2 = false;
    if (to > from12)
      this.nodesBetween(from12, to, (node18) => {
        if (type.isInSet(node18.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks$5(this.marks, name);
  }
  contentMatchAt(index8) {
    let match2 = this.type.contentMatch.matchFragment(this.content, 0, index8);
    if (!match2)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match2;
  }
  canReplace(from12, to, replacement = Fragment$5.empty, start16 = 0, end8 = replacement.childCount) {
    let one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start16; i < end8; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  canReplaceWith(from12, to, type, marks9) {
    if (marks9 && !this.type.allowsMarks(marks9))
      return false;
    let start16 = this.contentMatchAt(from12).matchType(type);
    let end8 = start16 && start16.matchFragment(this.content, to);
    return end8 ? end8.validEnd : false;
  }
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  check() {
    if (!this.type.validContent(this.content))
      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`);
    let copy12 = Mark$5.none;
    for (let i = 0; i < this.marks.length; i++)
      copy12 = this.marks[i].addToSet(copy12);
    if (!Mark$5.sameSet(copy12, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m2) => m2.type.name)}`);
    this.content.forEach((node18) => node18.check());
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  static fromJSON(schema2, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks9 = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks9 = json.marks.map(schema2.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema2.text(json.text, marks9);
    }
    let content2 = Fragment$5.fromJSON(schema2, json.content);
    return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
  }
}
Node$6.prototype.text = void 0;
class TextNode$5 extends Node$6 {
  constructor(type, attrs, content2, marks9) {
    super(type, attrs, null, marks9);
    if (!content2)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content2;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks$5(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from12, to) {
    return this.text.slice(from12, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks9) {
    return marks9 == this.marks ? this : new TextNode$5(this.type, this.attrs, this.text, marks9);
  }
  withText(text8) {
    if (text8 == this.text)
      return this;
    return new TextNode$5(this.type, this.attrs, text8, this.marks);
  }
  cut(from12 = 0, to = this.text.length) {
    if (from12 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from12, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks$5(marks9, str) {
  for (let i = marks9.length - 1; i >= 0; i--)
    str = marks9[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch$5 {
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  static parse(string, nodeTypes) {
    let stream = new TokenStream$5(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch$5.empty;
    let expr = parseExpr$5(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match2 = dfa$5(nfa$5(expr));
    checkForDeadEnds$5(match2, stream);
    return match2;
  }
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  matchFragment(frag, start16 = 0, end8 = frag.childCount) {
    let cur = this;
    for (let i = start16; cur && i < end8; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  get inlineContent() {
    return this.next.length && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  fillBefore(after8, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match2, types) {
      let finished = match2.matchFragment(after8, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment$5.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next: next2 } = match2.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
          seen.push(next2);
          let found2 = search(next2, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match2 = current.match;
      if (match2.matchType(target)) {
        let result2 = [];
        for (let obj = current; obj.type; obj = obj.via)
          result2.push(obj.type);
        return result2.reverse();
      }
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next: next2 } = match2.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next2.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  toString() {
    let seen = [];
    function scan(m2) {
      seen.push(m2);
      for (let i = 0; i < m2.next.length; i++)
        if (seen.indexOf(m2.next[i].next) == -1)
          scan(m2.next[i].next);
    }
    scan(this);
    return seen.map((m2, i) => {
      let out = i + (m2.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m2.next.length; i2++)
        out += (i2 ? ", " : "") + m2.next[i2].type.name + "->" + seen.indexOf(m2.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch$5.empty = new ContentMatch$5(true);
class TokenStream$5 {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr$5(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq$5(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$5(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript$5(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$5(stream) {
  let expr = parseExprAtom$5(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange$5(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum$5(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$5(stream, expr) {
  let min9 = parseNum$5(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max9 = parseNum$5(stream);
    else
      max9 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$5(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result2 = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result2.push(type2);
  }
  if (result2.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result2;
}
function parseExprAtom$5(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr$5(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName$5(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$5(expr) {
  let nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    let edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach((edge9) => edge9.to = to);
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile16(expr3, from12)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1)
          return next2;
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      let loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      let loop = node18();
      connect(compile16(expr2.expr, from12), loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      let cur = from12;
      for (let i = 0; i < expr2.min; i++) {
        let next2 = node18();
        connect(compile16(expr2.expr, cur), next2);
        cur = next2;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next2 = node18();
          edge8(cur, next2);
          connect(compile16(expr2.expr, cur), next2);
          cur = next2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp$5(a, b) {
  return b - a;
}
function nullFrom$5(nfa2, node18) {
  let result2 = [];
  scan(node18);
  return result2.sort(cmp$5);
  function scan(node19) {
    let edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result2.push(node19);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result2.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa$5(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$5(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node18) => {
      nfa2[node18].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom$5(nfa2, to).forEach((node19) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node19) == -1)
            set.push(node19);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch$5(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp$5);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds$5(match2, stream) {
  for (let i = 0, work = [match2]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes2 = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next: next2 } = state.next[j];
      nodes2.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next2) == -1)
        work.push(next2);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs$5(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$5(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$5(attrs) {
  let result2 = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result2[name] = new Attribute$5(attrs[name]);
  return result2;
}
class NodeType$8 {
  constructor(name, schema2, spec) {
    this.name = name;
    this.schema = schema2;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs$5(spec.attrs);
    this.defaultAttrs = defaultAttrs$5(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == ContentMatch$5.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs$5(this.attrs, attrs);
  }
  create(attrs = null, content2, marks9) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$6(this, this.computeAttrs(attrs), Fragment$5.from(content2), Mark$5.setFrom(marks9));
  }
  createChecked(attrs = null, content2, marks9) {
    content2 = Fragment$5.from(content2);
    if (!this.validContent(content2))
      throw new RangeError("Invalid content for node " + this.name);
    return new Node$6(this, this.computeAttrs(attrs), content2, Mark$5.setFrom(marks9));
  }
  createAndFill(attrs = null, content2, marks9) {
    attrs = this.computeAttrs(attrs);
    content2 = Fragment$5.from(content2);
    if (content2.size) {
      let before8 = this.contentMatch.fillBefore(content2);
      if (!before8)
        return null;
      content2 = before8.append(content2);
    }
    let matched = this.contentMatch.matchFragment(content2);
    let after8 = matched && matched.fillBefore(Fragment$5.empty, true);
    if (!after8)
      return null;
    return new Node$6(this, attrs, content2.append(after8), Mark$5.setFrom(marks9));
  }
  validContent(content2) {
    let result2 = this.contentMatch.matchFragment(content2);
    if (!result2 || !result2.validEnd)
      return false;
    for (let i = 0; i < content2.childCount; i++)
      if (!this.allowsMarks(content2.child(i).marks))
        return false;
    return true;
  }
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  allowsMarks(marks9) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks9.length; i++)
      if (!this.allowsMarkType(marks9[i].type))
        return false;
    return true;
  }
  allowedMarks(marks9) {
    if (this.markSet == null)
      return marks9;
    let copy12;
    for (let i = 0; i < marks9.length; i++) {
      if (!this.allowsMarkType(marks9[i].type)) {
        if (!copy12)
          copy12 = marks9.slice(0, i);
      } else if (copy12) {
        copy12.push(marks9[i]);
      }
    }
    return !copy12 ? marks9 : copy12.length ? copy12 : Mark$5.none;
  }
  static compile(nodes2, schema2) {
    let result2 = /* @__PURE__ */ Object.create(null);
    nodes2.forEach((name, spec) => result2[name] = new NodeType$8(name, schema2, spec));
    let topType = schema2.spec.topNode || "doc";
    if (!result2[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result2.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result2.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result2;
  }
}
class Attribute$5 {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType$5 {
  constructor(name, rank, schema2, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema2;
    this.spec = spec;
    this.attrs = initAttrs$5(spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs$5(this.attrs);
    this.instance = defaults ? new Mark$5(this, defaults) : null;
  }
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$5(this, computeAttrs$5(this.attrs, attrs));
  }
  static compile(marks9, schema2) {
    let result2 = /* @__PURE__ */ Object.create(null), rank = 0;
    marks9.forEach((name, spec) => result2[name] = new MarkType$5(name, rank++, schema2, spec));
    return result2;
  }
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema$5 {
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    this.spec = {
      nodes: OrderedMap$a.from(spec.nodes),
      marks: OrderedMap$a.from(spec.marks || {}),
      topNode: spec.topNode
    };
    this.nodes = NodeType$8.compile(this.spec.nodes, this);
    this.marks = MarkType$5.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$5.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$5(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks$5(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  node(type, attrs = null, content2, marks9) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$8))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content2, marks9);
  }
  text(text8, marks9) {
    let type = this.nodes.text;
    return new TextNode$5(type, type.defaultAttrs, text8, Mark$5.setFrom(marks9));
  }
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  nodeFromJSON(json) {
    return Node$6.fromJSON(this, json);
  }
  markFromJSON(json) {
    return Mark$5.fromJSON(this, json);
  }
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks$5(schema2, marks9) {
  let found2 = [];
  for (let i = 0; i < marks9.length; i++) {
    let name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (let prop in schema2.marks) {
        let mark16 = schema2.marks[prop];
        if (name == "_" || mark16.spec.group && mark16.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok3 = mark16);
      }
    }
    if (!ok3)
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
  }
  return found2;
}
class DOMParser$5 {
  constructor(schema2, rules) {
    this.schema = schema2;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node18 = schema2.nodes[r2.node];
      return node18.contentMatch.matchType(node18);
    });
  }
  parse(dom, options = {}) {
    let context = new ParseContext$5(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  parseSlice(dom, options = {}) {
    let context = new ParseContext$5(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice$5.maxOpen(context.finish());
  }
  matchTag(dom, context, after8) {
    for (let i = after8 ? this.tags.indexOf(after8) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches$5(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result2 = rule.getAttrs(dom);
          if (result2 === false)
            continue;
          rule.attrs = result2 || void 0;
        }
        return rule;
      }
    }
  }
  matchStyle(prop, value, context, after8) {
    for (let i = after8 ? this.styles.indexOf(after8) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result2 = rule.getAttrs(value);
        if (result2 === false)
          continue;
        rule.attrs = result2 || void 0;
      }
      return rule;
    }
  }
  static schemaRules(schema2) {
    let result2 = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result2.length; i++) {
        let next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
        if (nextPriority < priority)
          break;
      }
      result2.splice(i, 0, rule);
    }
    for (let name in schema2.marks) {
      let rules = schema2.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy$6(rule));
          rule.mark = name;
        });
    }
    for (let name in schema2.nodes) {
      let rules = schema2.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy$6(rule));
          rule.node = name;
        });
    }
    return result2;
  }
  static fromSchema(schema2) {
    return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$5(schema2, DOMParser$5.schemaRules(schema2)));
  }
}
const blockTags$5 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags$5 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags$5 = { ol: true, ul: true };
const OPT_PRESERVE_WS$5 = 1, OPT_PRESERVE_WS_FULL$5 = 2, OPT_OPEN_LEFT$5 = 4;
function wsOptionsFor$5(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS$5 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$5 : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS$5 | OPT_PRESERVE_WS_FULL$5 : base2 & ~OPT_OPEN_LEFT$5;
}
class NodeContext$5 {
  constructor(type, attrs, marks9, pendingMarks, solid, match2, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks9;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$5.none;
    this.stashMarks = [];
    this.match = match2 || (options & OPT_OPEN_LEFT$5 ? null : type.contentMatch);
  }
  findWrapping(node18) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment$5.from(node18));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start16 = this.type.contentMatch, wrap2;
        if (wrap2 = start16.findWrapping(node18.type)) {
          this.match = start16;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node18.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS$5)) {
      let last = this.content[this.content.length - 1], m2;
      if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text8 = last;
        if (last.text.length == m2[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text8.withText(text8.text.slice(0, text8.text.length - m2[0].length));
      }
    }
    let content2 = Fragment$5.from(this.content);
    if (!openEnd && this.match)
      content2 = content2.append(this.match.fillBefore(Fragment$5.empty, true));
    return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
  }
  popFromStashMark(mark15) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark15.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark15 = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark15.type) : markMayApply(mark15.type, nextType)) && !mark15.isInSet(this.activeMarks)) {
        this.activeMarks = mark15.addToSet(this.activeMarks);
        this.pendingMarks = mark15.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node18) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node18.parentNode && !blockTags$5.hasOwnProperty(node18.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext$5 {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor$5(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT$5 : 0);
    if (topNode)
      topContext = new NodeContext$5(topNode.type, topNode.attrs, Mark$5.none, Mark$5.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext$5(null, null, Mark$5.none, Mark$5.none, true, null, topOptions);
    else
      topContext = new NodeContext$5(parser.schema.topNodeType, null, Mark$5.none, Mark$5.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(dom) {
    if (dom.nodeType == 3) {
      this.addTextNode(dom);
    } else if (dom.nodeType == 1) {
      let style2 = dom.getAttribute("style");
      let marks9 = style2 ? this.readStyles(parseStyles$5(style2)) : null, top = this.top;
      if (marks9 != null)
        for (let i = 0; i < marks9.length; i++)
          this.addPendingMark(marks9[i]);
      this.addElement(dom);
      if (marks9 != null)
        for (let i = 0; i < marks9.length; i++)
          this.removePendingMark(marks9[i], top);
    }
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top = this.top;
    if (top.options & OPT_PRESERVE_WS_FULL$5 || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top.options & OPT_PRESERVE_WS$5)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top.options & OPT_PRESERVE_WS_FULL$5)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags$5.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList$5(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags$5.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync8, top = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags$5.hasOwnProperty(name)) {
        sync8 = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      this.addAll(dom);
      if (sync8)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
    }
  }
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  readStyles(styles2) {
    let marks9 = Mark$5.none;
    style:
      for (let i = 0; i < styles2.length; i += 2) {
        for (let after8 = void 0; ; ) {
          let rule = this.parser.matchStyle(styles2[i], styles2[i + 1], this, after8);
          if (!rule)
            continue style;
          if (rule.ignore)
            return null;
          marks9 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
          if (rule.consuming === false)
            after8 = rule;
          else
            break;
        }
      }
    return marks9;
  }
  addElementByRule(dom, rule, continueAfter) {
    let sync8, nodeType8, mark15;
    if (rule.node) {
      nodeType8 = this.parser.schema.nodes[rule.node];
      if (!nodeType8.isLeaf) {
        sync8 = this.enter(nodeType8, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType8.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark15 = markType.create(rule.attrs);
      this.addPendingMark(mark15);
    }
    let startIn = this.top;
    if (nodeType8 && nodeType8.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node18) => this.insertNode(node18));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync8 && this.sync(startIn))
      this.open--;
    if (mark15)
      this.removePendingMark(mark15, startIn);
  }
  addAll(parent, startIndex, endIndex) {
    let index8 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
      this.findAtPoint(parent, index8);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index8);
  }
  findPlace(node18) {
    let route, sync8;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node18);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync8 = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync8);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  insertNode(node18) {
    if (node18.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node18)) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(node18.type);
      if (top.match)
        top.match = top.match.matchType(node18.type);
      let marks9 = top.activeMarks;
      for (let i = 0; i < node18.marks.length; i++)
        if (!top.type || top.type.allowsMarkType(node18.marks[i].type))
          marks9 = node18.marks[i].addToSet(marks9);
      top.content.push(node18.mark(marks9));
      return true;
    }
    return false;
  }
  enter(type, attrs, preserveWS) {
    let ok3 = this.findPlace(type.create(attrs));
    if (ok3)
      this.enterInner(type, attrs, true, preserveWS);
    return ok3;
  }
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.applyPending(type);
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor$5(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT$5 && top.content.length == 0)
      options |= OPT_OPEN_LEFT$5;
    this.nodes.push(new NodeContext$5(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
    this.open++;
  }
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content2 = this.nodes[i].content;
      for (let j = content2.length - 1; j >= 0; j--)
        pos += content2[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content2, before8) {
    if (parent != content2 && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content2.compareDocumentPosition(this.find[i].node);
          if (pos & (before8 ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match2 = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i - 1, depth))
              return true;
          return false;
        } else {
          let next2 = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match2(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark15) {
    let found2 = findSameMarkInSet(mark15, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark15.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark15, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark15);
      if (found2 > -1) {
        level.pendingMarks = mark15.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark15.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark15);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
}
function normalizeList$5(dom) {
  for (let child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    let name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$5.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$5(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$5(style2) {
  let re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2))
    result2.push(m2[1], m2[2].trim());
  return result2;
}
function copy$6(obj) {
  let copy12 = {};
  for (let prop in obj)
    copy12[prop] = obj[prop];
  return copy12;
}
function markMayApply(markType, nodeType8) {
  let nodes2 = nodeType8.schema.nodes;
  for (let name in nodes2) {
    let parent = nodes2[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match2) => {
      seen.push(match2);
      for (let i = 0; i < match2.edgeCount; i++) {
        let { type, next: next2 } = match2.edge(i);
        if (type == nodeType8)
          return true;
        if (seen.indexOf(next2) < 0 && scan(next2))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark15, set) {
  for (let i = 0; i < set.length; i++) {
    if (mark15.eq(set[i]))
      return set[i];
  }
}
class DOMSerializer$5 {
  constructor(nodes2, marks9) {
    this.nodes = nodes2;
    this.marks = marks9;
  }
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$6(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node18) => {
      if (active.length || node18.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node18.marks.length) {
          let next2 = node18.marks[rendered];
          if (!this.marks[next2.type.name]) {
            rendered++;
            continue;
          }
          if (!next2.eq(active[keep][0]) || next2.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node18.marks.length) {
          let add4 = node18.marks[rendered++];
          let markDOM = this.serializeMark(add4, node18.isInline, options);
          if (markDOM) {
            active.push([add4, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node18, options));
    });
    return target;
  }
  serializeNodeInner(node18, options) {
    let { dom, contentDOM } = DOMSerializer$5.renderSpec(doc$6(options), this.nodes[node18.type.name](node18));
    if (contentDOM) {
      if (node18.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node18.content, options, contentDOM);
    }
    return dom;
  }
  serializeNode(node18, options = {}) {
    let dom = this.serializeNodeInner(node18, options);
    for (let i = node18.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node18.marks[i], node18.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  serializeMark(mark15, inline3, options = {}) {
    let toDOM4 = this.marks[mark15.type.name];
    return toDOM4 && DOMSerializer$5.renderSpec(doc$6(options), toDOM4(mark15, inline3));
  }
  static renderSpec(doc2, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc2.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space2 = tagName.indexOf(" ");
    if (space2 > 0) {
      xmlNS = tagName.slice(0, space2);
      tagName = tagName.slice(space2 + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    let attrs = structure[1], start16 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start16 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space3 = name.indexOf(" ");
          if (space3 > 0)
            dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start16; i < structure.length; i++) {
      let child15 = structure[i];
      if (child15 === 0) {
        if (i < structure.length - 1 || i > start16)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = DOMSerializer$5.renderSpec(doc2, child15, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  static fromSchema(schema2) {
    return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$5(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
  }
  static nodesFromSchema(schema2) {
    let result2 = gatherToDOM$5(schema2.nodes);
    if (!result2.text)
      result2.text = (node18) => node18.text;
    return result2;
  }
  static marksFromSchema(schema2) {
    return gatherToDOM$5(schema2.marks);
  }
}
function gatherToDOM$5(obj) {
  let result2 = {};
  for (let name in obj) {
    let toDOM4 = obj[name].spec.toDOM;
    if (toDOM4)
      result2[name] = toDOM4;
  }
  return result2;
}
function doc$6(options) {
  return options.document || window.document;
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc$5 = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge$2 = /Edge\/(\d+)/.exec(agent);
const ie_upto10$2 = /MSIE \d/.exec(agent);
const ie_11up$2 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$3 = !!(ie_upto10$2 || ie_11up$2 || ie_edge$2);
const ie_version = ie_upto10$2 ? document.documentMode : ie_11up$2 ? +ie_11up$2[1] : ie_edge$2 ? +ie_edge$2[1] : 0;
const gecko$3 = !ie$3 && /gecko\/(\d+)/i.test(agent);
gecko$3 && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$3 && /Chrome\/(\d+)/.exec(agent);
const chrome$4 = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari$2 = !ie$3 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari$2 && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$6 = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc$5 && "webkitFontSmoothing" in doc$5.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
const domIndex$2 = function(node18) {
  for (var index8 = 0; ; index8++) {
    node18 = node18.previousSibling;
    if (!node18)
      return index8;
  }
};
const parentNode$2 = function(node18) {
  let parent = node18.assignedSlot || node18.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange$2 = function(node18, from12, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node18, to == null ? node18.nodeValue.length : to);
  range.setStart(node18, from12 || 0);
  return range;
};
const isEquivalentPosition$2 = function(node18, off, targetNode, targetOff) {
  return targetNode && (scanFor$2(node18, off, targetNode, targetOff, -1) || scanFor$2(node18, off, targetNode, targetOff, 1));
};
const atomElements$2 = /^(img|br|input|textarea|hr)$/i;
function scanFor$2(node18, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node18 == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize$2(node18))) {
      let parent = node18.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc$2(node18) || atomElements$2.test(node18.nodeName) || node18.contentEditable == "false")
        return false;
      off = domIndex$2(node18) + (dir < 0 ? 0 : 1);
      node18 = parent;
    } else if (node18.nodeType == 1) {
      node18 = node18.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node18.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize$2(node18) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize$2(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function isOnEdge(node18, offset2, parent) {
  for (let atStart2 = offset2 == 0, atEnd2 = offset2 == nodeSize$2(node18); atStart2 || atEnd2; ) {
    if (node18 == parent)
      return true;
    let index8 = domIndex$2(node18);
    node18 = node18.parentNode;
    if (!node18)
      return false;
    atStart2 = atStart2 && index8 == 0;
    atEnd2 = atEnd2 && index8 == nodeSize$2(node18);
  }
}
function hasBlockDesc$2(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed$2 = function(domSel) {
  let collapsed = domSel.isCollapsed;
  if (collapsed && chrome$4 && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    collapsed = false;
  return collapsed;
};
function keyEvent$2(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function windowRect$2(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node18) {
  let rect = node18.getBoundingClientRect();
  let scaleX = rect.width / node18.offsetWidth || 1;
  let scaleY = rect.height / node18.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node18.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node18.clientHeight * scaleY
  };
}
function scrollRectIntoView$2(view2, rect, startDOM) {
  let scrollThreshold = view2.someProp("scrollThreshold") || 0, scrollMargin = view2.someProp("scrollMargin") || 5;
  let doc2 = view2.dom.ownerDocument;
  for (let parent = startDOM || view2.dom; ; parent = parentNode$2(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect$2(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop)
      break;
  }
}
function storeScrollPos$2(view2) {
  let rect = view2.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    let dom = view2.root.elementFromPoint(x2, y2);
    if (!dom || dom == view2.dom || !view2.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view2.dom) };
}
function scrollStack(dom) {
  let stack = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode$2(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack;
}
function resetScrollPos$2({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top, left } = stack[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode$2(node18, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  for (let child15 = node18.firstChild, childIndex = 0; child15; child15 = child15.nextSibling, childIndex++) {
    let rects;
    if (child15.nodeType == 1)
      rects = child15.getClientRects();
    else if (child15.nodeType == 3)
      rects = textRange$2(child15).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child15;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child15.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText$2(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node: node18, offset: offset2 };
  return findOffsetInNode$2(closest, coordsClosest);
}
function findOffsetInText$2(node18, coords) {
  let len = node18.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node18, i + 1);
    range.setStart(node18, i);
    let rect = singleRect$2(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node: node18, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node: node18, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge$2(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement$2(view2, elt, coords) {
  let { node: node18, offset: offset2 } = findOffsetInNode$2(elt, coords), bias = -1;
  if (node18.nodeType == 1 && !node18.firstChild) {
    let rect = node18.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view2.docView.posFromDOM(node18, offset2, bias);
}
function posFromCaret$2(view2, node18, offset2, coords) {
  let outside = -1;
  for (let cur = node18; ; ) {
    if (cur == view2.dom)
      break;
    let desc = view2.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.node.isBlock && desc.parent) {
      let rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top)
        outside = desc.posBefore;
      else if (rect.right < coords.left || rect.bottom < coords.top)
        outside = desc.posAfter;
      else
        break;
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view2.docView.posFromDOM(node18, offset2, 1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child15 = element.childNodes[i];
      if (child15.nodeType == 1) {
        let rects = child15.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child15, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords$2(view2, coords) {
  let doc2 = view2.dom.ownerDocument, node18, offset2 = 0;
  if (doc2.caretPositionFromPoint) {
    try {
      let pos2 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos2)
        ({ offsetNode: node18, offset: offset2 } = pos2);
    } catch (_) {
    }
  }
  if (!node18 && doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range)
      ({ startContainer: node18, startOffset: offset2 } = range);
  }
  let elt = (view2.root.elementFromPoint ? view2.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view2.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view2.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view2.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari$2) {
    for (let p2 = elt; node18 && p2; p2 = parentNode$2(p2))
      if (p2.draggable)
        node18 = void 0;
  }
  elt = targetKludge$2(elt, coords);
  if (node18) {
    if (gecko$3 && node18.nodeType == 1) {
      offset2 = Math.min(offset2, node18.childNodes.length);
      if (offset2 < node18.childNodes.length) {
        let next2 = node18.childNodes[offset2], box;
        if (next2.nodeName == "IMG" && (box = next2.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    if (node18 == view2.dom && offset2 == node18.childNodes.length - 1 && node18.lastChild.nodeType == 1 && coords.top > node18.lastChild.getBoundingClientRect().bottom)
      pos = view2.state.doc.content.size;
    else if (offset2 == 0 || node18.nodeType != 1 || node18.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret$2(view2, node18, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement$2(view2, elt, coords);
  let desc = view2.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect$2(target, bias) {
  let rects = target.getClientRects();
  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos$2(view2, pos, side) {
  let { node: node18, offset: offset2, atom } = view2.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko$3;
  if (node18.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node18.nodeValue) || (side < 0 ? !offset2 : offset2 == node18.nodeValue.length))) {
      let rect = singleRect$2(textRange$2(node18, offset2, offset2), side);
      if (gecko$3 && offset2 && /\s/.test(node18.nodeValue[offset2 - 1]) && offset2 < node18.nodeValue.length) {
        let rectBefore = singleRect$2(textRange$2(node18, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect$2(textRange$2(node18, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from12 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node18.nodeValue.length) {
        from12--;
        takeSide = 1;
      } else if (side < 0) {
        from12--;
      } else {
        to++;
      }
      return flattenV(singleRect$2(textRange$2(node18, from12, to), 1), takeSide < 0);
    }
  }
  let $dom = view2.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize$2(node18))) {
      let before8 = node18.childNodes[offset2 - 1];
      if (before8.nodeType == 1)
        return flattenH(before8.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize$2(node18)) {
      let after8 = node18.childNodes[offset2];
      if (after8.nodeType == 1)
        return flattenH(after8.getBoundingClientRect(), true);
    }
    return flattenH(node18.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize$2(node18))) {
    let before8 = node18.childNodes[offset2 - 1];
    let target = before8.nodeType == 3 ? textRange$2(before8, nodeSize$2(before8) - (supportEmptyRange ? 0 : 1)) : before8.nodeType == 1 && (before8.nodeName != "BR" || !before8.nextSibling) ? before8 : null;
    if (target)
      return flattenV(singleRect$2(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize$2(node18)) {
    let after8 = node18.childNodes[offset2];
    while (after8.pmViewDesc && after8.pmViewDesc.ignoreForCoords)
      after8 = after8.nextSibling;
    let target = !after8 ? null : after8.nodeType == 3 ? textRange$2(after8, 0, supportEmptyRange ? 0 : 1) : after8.nodeType == 1 ? after8 : null;
    if (target)
      return flattenV(singleRect$2(target, -1), true);
  }
  return flattenV(singleRect$2(node18.nodeType == 3 ? textRange$2(node18) : node18, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x2 = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y2 = top ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState$2(view2, state, f2) {
  let viewState = view2.state, active = view2.root.activeElement;
  if (viewState != state)
    view2.updateState(state);
  if (active != view2.dom)
    view2.focus();
  try {
    return f2();
  } finally {
    if (viewState != state)
      view2.updateState(viewState);
    if (active != view2.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical$2(view2, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState$2(view2, state, () => {
    let { node: dom } = view2.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view2.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos$2(view2, $pos.pos, 1);
    for (let child15 = dom.firstChild; child15; child15 = child15.nextSibling) {
      let boxes;
      if (child15.nodeType == 1)
        boxes = child15.getClientRects();
      else if (child15.nodeType == 3)
        boxes = textRange$2(child15, 0, child15.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL$2 = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal$2(view2, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  let sel = view2.domSelection();
  if (!maybeRTL$2.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  return withFlushedState$2(view2, state, () => {
    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view2.docView.domAfterPos($head.before()) : view2.dom;
    let result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result2;
  });
}
let cachedState$2 = null;
let cachedDir$2 = null;
let cachedResult$2 = false;
function endOfTextblock$2(view2, state, dir) {
  if (cachedState$2 == state && cachedDir$2 == dir)
    return cachedResult$2;
  cachedState$2 = state;
  cachedDir$2 = dir;
  return cachedResult$2 = dir == "up" || dir == "down" ? endOfTextblockVertical$2(view2, state, dir) : endOfTextblockHorizontal$2(view2, state, dir);
}
const NOT_DIRTY$2 = 0, CHILD_DIRTY$2 = 1, CONTENT_DIRTY$2 = 2, NODE_DIRTY$2 = 3;
class ViewDesc$2 {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY$2;
    dom.pmViewDesc = this;
  }
  matchesWidget(widget3) {
    return false;
  }
  matchesMark(mark15) {
    return false;
  }
  matchesNode(node18, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  parseRule() {
    return null;
  }
  stopEvent(event) {
    return false;
  }
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child15) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child15)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd2;
    if (dom == this.dom && this.contentDOM) {
      atEnd2 = offset2 > domIndex$2(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd2 = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd2 == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd2 = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child15 = this.children[i], end8 = offset2 + child15.size;
      if (offset2 == pos && end8 != offset2) {
        while (!child15.border && child15.children.length)
          child15 = child15.children[0];
        return child15;
      }
      if (pos < end8)
        return child15.descAt(pos - offset2 - child15.border);
      offset2 = end8;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child15 = this.children[i], end8 = curPos + child15.size;
      if (end8 > pos || child15 instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end8;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev2; i && !(prev2 = this.children[i - 1]).size && prev2 instanceof WidgetViewDesc$2 && prev2.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev2, enter8 = true;
      for (; ; i--, enter8 = false) {
        prev2 = i ? this.children[i - 1] : null;
        if (!prev2 || prev2.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev2 && side && enter8 && !prev2.border && !prev2.domAtom)
        return prev2.domFromPos(prev2.size, side);
      return { node: this.contentDOM, offset: prev2 ? domIndex$2(prev2.dom) + 1 : 0 };
    } else {
      let next2, enter8 = true;
      for (; ; i++, enter8 = false) {
        next2 = i < this.children.length ? this.children[i] : null;
        if (!next2 || next2.dom.parentNode == this.contentDOM)
          break;
      }
      if (next2 && enter8 && !next2.border && !next2.domAtom)
        return next2.domFromPos(0, side);
      return { node: this.contentDOM, offset: next2 ? domIndex$2(next2.dom) : this.contentDOM.childNodes.length };
    }
  }
  parseRange(from12, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from12, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child15 = this.children[i], end8 = offset2 + child15.size;
      if (fromOffset == -1 && from12 <= end8) {
        let childBase = offset2 + child15.border;
        if (from12 >= childBase && to <= end8 - child15.border && child15.node && child15.contentDOM && this.contentDOM.contains(child15.contentDOM))
          return child15.parseRange(from12, to, childBase);
        from12 = offset2;
        for (let j = i; j > 0; j--) {
          let prev2 = this.children[j - 1];
          if (prev2.size && prev2.dom.parentNode == this.contentDOM && !prev2.emptyChildAt(1)) {
            fromOffset = domIndex$2(prev2.dom) + 1;
            break;
          }
          from12 -= prev2.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end8 > to || i == this.children.length - 1)) {
        to = end8;
        for (let j = i + 1; j < this.children.length; j++) {
          let next2 = this.children[j];
          if (next2.size && next2.dom.parentNode == this.contentDOM && !next2.emptyChildAt(-1)) {
            toOffset = domIndex$2(next2.dom);
            break;
          }
          to += next2.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end8;
    }
    return { node: this.contentDOM, from: from12, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child15 = this.children[side < 0 ? 0 : this.children.length - 1];
    return child15.size == 0 || child15.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node: node18, offset: offset2 } = this.domFromPos(pos, 0);
    if (node18.nodeType != 1 || offset2 == node18.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node18.childNodes[offset2];
  }
  setSelection(anchor, head, root2, force = false) {
    let from12 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child15 = this.children[i], end8 = offset2 + child15.size;
      if (from12 > offset2 && to < end8)
        return child15.setSelection(anchor - offset2 - child15.border, head - offset2 - child15.border, root2, force);
      offset2 = end8;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root2.getSelection();
    let brKludge = false;
    if ((gecko$3 || safari$2) && anchor == head) {
      let { node: node18, offset: offset2 } = anchorDOM;
      if (node18.nodeType == 3) {
        brKludge = !!(offset2 && node18.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node18.nodeValue.length) {
          for (let scan = node18, after8; scan; scan = scan.parentNode) {
            if (after8 = scan.nextSibling) {
              if (after8.nodeName == "BR")
                anchorDOM = headDOM = { node: after8.parentNode, offset: domIndex$2(after8) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev2 = node18.childNodes[offset2 - 1];
        brKludge = prev2 && (prev2.nodeName == "BR" || prev2.contentEditable == "false");
      }
    }
    if (gecko$3 && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after8 = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after8 && after8.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari$2) && isEquivalentPosition$2(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition$2(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (err8) {
        if (!(err8 instanceof DOMException))
          throw err8;
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  markDirty(from12, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child15 = this.children[i], end8 = offset2 + child15.size;
      if (offset2 == end8 ? from12 <= end8 && to >= offset2 : from12 < end8 && to > offset2) {
        let startInside = offset2 + child15.border, endInside = end8 - child15.border;
        if (from12 >= startInside && to <= endInside) {
          this.dirty = from12 == offset2 || to == end8 ? CONTENT_DIRTY$2 : CHILD_DIRTY$2;
          if (from12 == startInside && to == endInside && (child15.contentLost || child15.dom.parentNode != this.contentDOM))
            child15.dirty = NODE_DIRTY$2;
          else
            child15.markDirty(from12 - startInside, to - startInside);
          return;
        } else {
          child15.dirty = child15.dom == child15.contentDOM && child15.dom.parentNode == this.contentDOM && !child15.children.length ? CONTENT_DIRTY$2 : NODE_DIRTY$2;
        }
      }
      offset2 = end8;
    }
    this.dirty = CONTENT_DIRTY$2;
  }
  markParentsDirty() {
    let level = 1;
    for (let node18 = this.parent; node18; node18 = node18.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY$2 : CHILD_DIRTY$2;
      if (node18.dirty < dirty)
        node18.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
}
class WidgetViewDesc$2 extends ViewDesc$2 {
  constructor(parent, widget3, view2, pos) {
    let self2, dom = widget3.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view2, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget3.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget3;
    this.widget = widget3;
    self2 = this;
  }
  matchesWidget(widget3) {
    return this.dirty == NOT_DIRTY$2 && widget3.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop7 = this.widget.spec.stopEvent;
    return stop7 ? stop7(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc$2 {
  constructor(parent, dom, textDOM, text8) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text8;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc$2 extends ViewDesc$2 {
  constructor(parent, mark15, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark15;
  }
  static create(parent, mark15, inline3, view2) {
    let custom = view2.nodeViews[mark15.type.name];
    let spec = custom && custom(mark15, view2, inline3);
    if (!spec || !spec.dom)
      spec = DOMSerializer$5.renderSpec(document, mark15.type.spec.toDOM(mark15, inline3));
    return new MarkViewDesc$2(parent, mark15, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY$2 || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(mark15) {
    return this.dirty != NODE_DIRTY$2 && this.mark.eq(mark15);
  }
  markDirty(from12, to) {
    super.markDirty(from12, to);
    if (this.dirty != NOT_DIRTY$2) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY$2;
    }
  }
  slice(from12, to, view2) {
    let copy12 = MarkViewDesc$2.create(this.parent, this.mark, true, view2);
    let nodes2 = this.children, size = this.size;
    if (to < size)
      nodes2 = replaceNodes(nodes2, to, size, view2);
    if (from12 > 0)
      nodes2 = replaceNodes(nodes2, 0, from12, view2);
    for (let i = 0; i < nodes2.length; i++)
      nodes2[i].parent = copy12;
    copy12.children = nodes2;
    return copy12;
  }
}
class NodeViewDesc$2 extends ViewDesc$2 {
  constructor(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node18;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
    if (contentDOM)
      this.updateChildren(view2, pos);
  }
  static create(parent, node18, outerDeco, innerDeco, view2, pos) {
    let custom = view2.nodeViews[node18.type.name], descObj;
    let spec = custom && custom(node18, view2, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node18.isText) {
      if (!dom)
        dom = document.createTextNode(node18.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer$5.renderSpec(document, node18.type.spec.toDOM(node18)));
    }
    if (!contentDOM && !node18.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node18.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco$2(dom, outerDeco, node18);
    if (spec)
      return descObj = new CustomNodeViewDesc$2(parent, node18, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view2, pos + 1);
    else if (node18.isText)
      return new TextViewDesc$2(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2);
    else
      return new NodeViewDesc$2(parent, node18, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view2, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child15 = this.children[i];
        if (this.dom.contains(child15.dom.parentNode)) {
          rule.contentElement = child15.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment$5.empty;
    }
    return rule;
  }
  matchesNode(node18, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY$2 && node18.eq(this.node) && sameOuterDeco$2(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(view2, pos) {
    let inline3 = this.node.inlineContent, off = pos;
    let composition = view2.composing ? this.localCompositionInfo(view2, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater$2(this, localComposition && localComposition.node, view2);
    iterDeco$2(this.node, this.innerDeco, (widget3, i, insideNode) => {
      if (widget3.spec.marks)
        updater.syncToMarks(widget3.spec.marks, inline3, view2);
      else if (widget3.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$5.none : this.node.child(i).marks, inline3, view2);
      updater.placeWidget(widget3, view2, off);
    }, (child15, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child15.marks, inline3, view2);
      let compIndex;
      if (updater.findNodeMatch(child15, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view2.state.selection.from > off && view2.state.selection.to < off + child15.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child15, outerDeco, innerDeco, compIndex, view2))
        ;
      else if (updater.updateNextNode(child15, outerDeco, innerDeco, view2, i))
        ;
      else {
        updater.addNode(child15, outerDeco, innerDeco, view2, off);
      }
      off += child15.nodeSize;
    });
    updater.syncToMarks([], inline3, view2);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY$2) {
      if (localComposition)
        this.protectLocalComposition(view2, localComposition);
      renderDescs$2(this.contentDOM, this.children, view2);
      if (ios)
        iosHacks$2(this.dom);
    }
  }
  localCompositionInfo(view2, pos) {
    let { from: from12, to } = view2.state.selection;
    if (!(view2.state.selection instanceof TextSelection_1) || from12 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view2.domSelection();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text8 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text8, from12 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text8 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view2, { node: node18, pos, text: text8 }) {
    if (this.getDesc(node18))
      return;
    let topNode = node18;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node18, text8);
    view2.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text8.length, view2, desc);
  }
  update(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY$2 || !node18.sameMarkup(this.node))
      return false;
    this.updateInner(node18, outerDeco, innerDeco, view2);
    return true;
  }
  updateInner(node18, outerDeco, innerDeco, view2) {
    this.updateOuterDeco(outerDeco);
    this.node = node18;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view2, this.posAtStart);
    this.dirty = NOT_DIRTY$2;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco$2(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco$2(this.dom, this.nodeDOM, computeOuterDeco$2(this.outerDeco, this.node, needsWrap), computeOuterDeco$2(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc$2(doc2, outerDeco, innerDeco, dom, view2) {
  applyOuterDeco$2(dom, outerDeco, doc2);
  return new NodeViewDesc$2(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view2, 0);
}
class TextViewDesc$2 extends NodeViewDesc$2 {
  constructor(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2) {
    super(parent, node18, outerDeco, innerDeco, dom, null, nodeDOM, view2, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY$2 || this.dirty != NOT_DIRTY$2 && !this.inParent() || !node18.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY$2 || node18.text != this.node.text) && node18.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node18.text;
      if (view2.trackWrites == this.nodeDOM)
        view2.trackWrites = null;
    }
    this.node = node18;
    this.dirty = NOT_DIRTY$2;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from12, to, view2) {
    let node18 = this.node.cut(from12, to), dom = document.createTextNode(node18.text);
    return new TextViewDesc$2(this.parent, node18, this.outerDeco, this.innerDeco, dom, dom, view2);
  }
  markDirty(from12, to) {
    super.markDirty(from12, to);
    if (this.dom != this.nodeDOM && (from12 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY$2;
  }
  get domAtom() {
    return false;
  }
}
class TrailingHackViewDesc extends ViewDesc$2 {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY$2 && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc$2 extends NodeViewDesc$2 {
  constructor(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view2, pos) {
    super(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2, pos);
    this.spec = spec;
  }
  update(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY$2)
      return false;
    if (this.spec.update) {
      let result2 = this.spec.update(node18, outerDeco, innerDeco);
      if (result2)
        this.updateInner(node18, outerDeco, innerDeco, view2);
      return result2;
    } else if (!this.contentDOM && !node18.isLeaf) {
      return false;
    } else {
      return super.update(node18, outerDeco, innerDeco, view2);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : super.setSelection(anchor, head, root2, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs$2(parentDOM, descs, view2) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm$2(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc$2) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs$2(desc.contentDOM, desc.children, view2);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm$2(dom);
    written = true;
  }
  if (written && view2.trackWrites == parentDOM)
    view2.trackWrites = null;
}
const OuterDecoLevel$2 = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel$2.prototype = /* @__PURE__ */ Object.create(null);
const noDeco$2 = [new OuterDecoLevel$2()];
function computeOuterDeco$2(outerDeco, node18, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco$2;
  let top = needsWrap ? noDeco$2[0] : new OuterDecoLevel$2(), result2 = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result2.push(top = new OuterDecoLevel$2(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result2.length == 1)
        result2.push(top = new OuterDecoLevel$2(node18.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result2;
}
function patchOuterDeco$2(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco$2 && curComputed == noDeco$2)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev2 = prevComputed[i];
    if (i) {
      let parent;
      if (prev2 && prev2.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev2 = noDeco$2[0];
        curDOM = parent;
      }
    }
    patchAttributes$2(curDOM, prev2 || noDeco$2[0], deco);
  }
  return curDOM;
}
function patchAttributes$2(dom, prev2, cur) {
  for (let name in prev2)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev2[name])
      dom.setAttribute(name, cur[name]);
  if (prev2.class != cur.class) {
    let prevList = prev2.class ? prev2.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev2.style != cur.style) {
    if (prev2.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev2.style))
        dom.style.removeProperty(m2[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco$2(dom, deco, node18) {
  return patchOuterDeco$2(dom, dom, noDeco$2, computeOuterDeco$2(deco, node18, dom.nodeType != 1));
}
function sameOuterDeco$2(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm$2(dom) {
  let next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
class ViewTreeUpdater$2 {
  constructor(top, lock, view2) {
    this.lock = lock;
    this.view = view2;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch$2(top.node.content, top);
  }
  destroyBetween(start16, end8) {
    if (start16 == end8)
      return;
    for (let i = start16; i < end8; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start16, end8 - start16);
    this.changed = true;
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(marks9, inline3, view2) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks9.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks9[keep]) && marks9[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY$2;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks9.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        if (this.top.children[i].matchesMark(marks9[depth])) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc$2.create(this.top, marks9[depth], inline3, view2);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  findNodeMatch(node18, outerDeco, innerDeco, index8) {
    let found2 = -1, targetDesc;
    if (index8 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index8 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node18, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child15 = this.top.children[i];
        if (child15.matchesNode(node18, outerDeco, innerDeco) && !this.preMatch.matched.has(child15)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node18, outerDeco, innerDeco, index8, view2) {
    let child15 = this.top.children[index8];
    if (child15.dirty == NODE_DIRTY$2 && child15.dom == child15.contentDOM)
      child15.dirty = CONTENT_DIRTY$2;
    if (!child15.update(node18, outerDeco, innerDeco, view2))
      return false;
    this.destroyBetween(this.index, index8);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  updateNextNode(node18, outerDeco, innerDeco, view2, index8) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next2 = this.top.children[i];
      if (next2 instanceof NodeViewDesc$2) {
        let preMatch2 = this.preMatch.matched.get(next2);
        if (preMatch2 != null && preMatch2 != index8)
          return false;
        let nextDOM = next2.dom;
        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node18.isText && next2.node && next2.node.isText && next2.nodeDOM.nodeValue == node18.text && next2.dirty != NODE_DIRTY$2 && sameOuterDeco$2(outerDeco, next2.outerDeco));
        if (!locked && next2.update(node18, outerDeco, innerDeco, view2)) {
          this.destroyBetween(this.index, i);
          if (next2.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  addNode(node18, outerDeco, innerDeco, view2, pos) {
    this.top.children.splice(this.index++, 0, NodeViewDesc$2.create(this.top, node18, outerDeco, innerDeco, view2, pos));
    this.changed = true;
  }
  placeWidget(widget3, view2, pos) {
    let next2 = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next2 && next2.matchesWidget(widget3) && (widget3 == next2.widget || !next2.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc$2(this.top, widget3, view2, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc$2) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || !(lastChild instanceof TextViewDesc$2) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari$2 || chrome$4) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
}
function preMatch$2(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next2 = curDesc.children[descI - 1];
          if (next2 instanceof MarkViewDesc$2) {
            curDesc = next2;
            descI = next2.children.length;
          } else {
            desc = next2;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node18 = desc.node;
      if (!node18)
        continue;
      if (node18 != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide$2(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco$2(parent, deco, onWidget, onNode) {
  let locals5 = deco.locals(parent), offset2 = 0;
  if (locals5.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child15 = parent.child(i);
      onNode(child15, locals5, deco.forChild(offset2, child15), i);
      offset2 += child15.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    if (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
      let widget3 = locals5[decoIndex++], widgets;
      while (decoIndex < locals5.length && locals5[decoIndex].to == offset2)
        (widgets || (widgets = [widget3])).push(locals5[decoIndex++]);
      if (widgets) {
        widgets.sort(compareSide$2);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget3, parentIndex, !!restNode);
      }
    }
    let child15, index8;
    if (restNode) {
      index8 = -1;
      child15 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index8 = parentIndex;
      child15 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals5.length && locals5[decoIndex].from <= offset2 && locals5[decoIndex].to > offset2)
      active.push(locals5[decoIndex++]);
    let end8 = offset2 + child15.nodeSize;
    if (child15.isText) {
      let cutAt = end8;
      if (decoIndex < locals5.length && locals5[decoIndex].from < cutAt)
        cutAt = locals5[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end8) {
        restNode = child15.cut(cutAt - offset2);
        child15 = child15.cut(0, cutAt - offset2);
        end8 = cutAt;
        index8 = -1;
      }
    }
    let outerDeco = child15.isInline && !child15.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child15, outerDeco, deco.forChild(offset2, child15), index8);
    offset2 = end8;
  }
}
function iosHacks$2(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node18, offset2) {
  for (; ; ) {
    if (node18.nodeType == 3)
      return node18;
    if (node18.nodeType == 1 && offset2 > 0) {
      if (node18.childNodes.length > offset2 && node18.childNodes[offset2].nodeType == 3)
        return node18.childNodes[offset2];
      node18 = node18.childNodes[offset2 - 1];
      offset2 = nodeSize$2(node18);
    } else if (node18.nodeType == 1 && offset2 < node18.childNodes.length) {
      node18 = node18.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text8, from12, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child15 = frag.child(i++), childStart = pos;
    pos += child15.nodeSize;
    if (!child15.isText)
      continue;
    let str = child15.text;
    while (i < frag.childCount) {
      let next2 = frag.child(i++);
      pos += next2.nodeSize;
      if (!next2.isText)
        break;
      str += next2.text;
    }
    if (pos >= from12) {
      let found2 = childStart < to ? str.lastIndexOf(text8, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text8.length + childStart >= from12)
        return childStart + found2;
      if (from12 == to && str.length >= to + text8.length - childStart && str.slice(to - childStart, to - childStart + text8.length) == text8)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes2, from12, to, view2, replacement) {
  let result2 = [];
  for (let i = 0, off = 0; i < nodes2.length; i++) {
    let child15 = nodes2[i], start16 = off, end8 = off += child15.size;
    if (start16 >= to || end8 <= from12) {
      result2.push(child15);
    } else {
      if (start16 < from12)
        result2.push(child15.slice(0, from12 - start16, view2));
      if (replacement) {
        result2.push(replacement);
        replacement = void 0;
      }
      if (end8 > to)
        result2.push(child15.slice(to - start16, child15.size, view2));
    }
  }
  return result2;
}
function selectionFromDOM(view2, origin = null) {
  let domSel = view2.domSelection(), doc2 = view2.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc3 = view2.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc3 && nearestDesc3.size == 0;
  let head = view2.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed$2(domSel)) {
    $anchor = $head;
    while (nearestDesc3 && !nearestDesc3.node)
      nearestDesc3 = nearestDesc3.parent;
    let nearestDescNode = nearestDesc3.node;
    if (nearestDesc3 && nearestDescNode.isAtom && NodeSelection_1.isSelectable(nearestDescNode) && nearestDesc3.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc3.dom))) {
      let pos = nearestDesc3.posBefore;
      selection = new NodeSelection_1(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    let anchor = view2.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view2.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween$2(view2, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view2) {
  return view2.editable ? view2.hasFocus() : hasSelection$2(view2) && document.activeElement && document.activeElement.contains(view2.dom);
}
function selectionToDOM$2(view2, force = false) {
  let sel = view2.state.selection;
  syncNodeSelection$2(view2, sel);
  if (!editorOwnsSelection(view2))
    return;
  if (!force && view2.input.mouseDown && view2.input.mouseDown.allowDefault && chrome$4) {
    let domSel = view2.domSelection(), curSel = view2.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition$2(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view2.input.mouseDown.delayedSelectionSync = true;
      view2.domObserver.setCurSelection();
      return;
    }
  }
  view2.domObserver.disconnectSelection();
  if (view2.cursorWrapper) {
    selectCursorWrapper$2(view2);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable$2 && !(sel instanceof TextSelection_1)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear$2(view2, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear$2(view2, sel.to);
    }
    view2.docView.setSelection(anchor, head, view2.root, force);
    if (brokenSelectBetweenUneditable$2) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view2.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view2.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange$2(view2);
    }
  }
  view2.domObserver.setCurSelection();
  view2.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable$2 = safari$2 || chrome$4 && chrome_version < 63;
function temporarilyEditableNear$2(view2, pos) {
  let { node: node18, offset: offset2 } = view2.docView.domFromPos(pos, 0);
  let after8 = offset2 < node18.childNodes.length ? node18.childNodes[offset2] : null;
  let before8 = offset2 ? node18.childNodes[offset2 - 1] : null;
  if (safari$2 && after8 && after8.contentEditable == "false")
    return setEditable(after8);
  if ((!after8 || after8.contentEditable == "false") && (!before8 || before8.contentEditable == "false")) {
    if (after8)
      return setEditable(after8);
    else if (before8)
      return setEditable(before8);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari$2 && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange$2(view2) {
  let doc2 = view2.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view2.input.hideSelectionGuard);
  let domSel = view2.domSelection();
  let node18 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view2.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node18 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view2.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view2) || view2.state.selection.visible)
          view2.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper$2(view2) {
  let domSel = view2.domSelection(), range = document.createRange();
  let node18 = view2.cursorWrapper.dom, img = node18.nodeName == "IMG";
  if (img)
    range.setEnd(node18.parentNode, domIndex$2(node18) + 1);
  else
    range.setEnd(node18, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view2.state.selection.visible && ie$3 && ie_version <= 11) {
    node18.disabled = true;
    node18.disabled = false;
  }
}
function syncNodeSelection$2(view2, sel) {
  if (sel instanceof NodeSelection_1) {
    let desc = view2.docView.descAt(sel.from);
    if (desc != view2.lastSelectedViewDesc) {
      clearNodeSelection$2(view2);
      if (desc)
        desc.selectNode();
      view2.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection$2(view2);
  }
}
function clearNodeSelection$2(view2) {
  if (view2.lastSelectedViewDesc) {
    if (view2.lastSelectedViewDesc.parent)
      view2.lastSelectedViewDesc.deselectNode();
    view2.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween$2(view2, $anchor, $head, bias) {
  return view2.someProp("createSelectionBetween", (f2) => f2(view2, $anchor, $head)) || TextSelection_1.between($anchor, $head, bias);
}
function hasFocusAndSelection$2(view2) {
  if (view2.editable && !view2.hasFocus())
    return false;
  return hasSelection$2(view2);
}
function hasSelection$2(view2) {
  let sel = view2.domSelection();
  if (!sel.anchorNode)
    return false;
  try {
    return view2.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view2.editable || view2.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view2) {
  let anchorDOM = view2.docView.domFromPos(view2.state.selection.anchor, 0);
  let domSel = view2.domSelection();
  return isEquivalentPosition$2(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock$2(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection_1.findFrom($start, dir);
}
function apply$4(view2, sel) {
  view2.dispatch(view2.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally$2(view2, dir, mods) {
  let sel = view2.state.selection;
  if (sel instanceof TextSelection_1) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view2.endOfTextblock(dir > 0 ? "right" : "left")) {
      let next2 = moveSelectionBlock$2(view2.state, dir);
      if (next2 && next2 instanceof NodeSelection_1)
        return apply$4(view2, next2);
      return false;
    } else if (!(mac$6 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node18 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node18 || node18.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node18.nodeSize : $head.pos;
      if (!(node18.isAtom || (desc = view2.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection_1.isSelectable(node18)) {
        return apply$4(view2, new NodeSelection_1(dir < 0 ? view2.state.doc.resolve($head.pos - node18.nodeSize) : $head));
      } else if (webkit) {
        return apply$4(view2, new TextSelection_1(view2.state.doc.resolve(dir < 0 ? nodePos : nodePos + node18.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection_1 && sel.node.isInline) {
    return apply$4(view2, new TextSelection_1(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next2 = moveSelectionBlock$2(view2.state, dir);
    if (next2)
      return apply$4(view2, next2);
    return false;
  }
}
function nodeLen$2(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function isIgnorable$2(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft$2(view2) {
  let sel = view2.domSelection();
  let node18 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node18)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko$3 && node18.nodeType == 1 && offset2 < nodeLen$2(node18) && isIgnorable$2(node18.childNodes[offset2]))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node18.nodeType != 1) {
        break;
      } else {
        let before8 = node18.childNodes[offset2 - 1];
        if (isIgnorable$2(before8)) {
          moveNode = node18;
          moveOffset = --offset2;
        } else if (before8.nodeType == 3) {
          node18 = before8;
          offset2 = node18.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode$2(node18)) {
      break;
    } else {
      let prev2 = node18.previousSibling;
      while (prev2 && isIgnorable$2(prev2)) {
        moveNode = node18.parentNode;
        moveOffset = domIndex$2(prev2);
        prev2 = prev2.previousSibling;
      }
      if (!prev2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom)
          break;
        offset2 = 0;
      } else {
        node18 = prev2;
        offset2 = nodeLen$2(node18);
      }
    }
  }
  if (force)
    setSelFocus(view2, sel, node18, offset2);
  else if (moveNode)
    setSelFocus(view2, sel, moveNode, moveOffset);
}
function skipIgnoredNodesRight$2(view2) {
  let sel = view2.domSelection();
  let node18 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node18)
    return;
  let len = nodeLen$2(node18);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node18.nodeType != 1)
        break;
      let after8 = node18.childNodes[offset2];
      if (isIgnorable$2(after8)) {
        moveNode = node18;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode$2(node18)) {
      break;
    } else {
      let next2 = node18.nextSibling;
      while (next2 && isIgnorable$2(next2)) {
        moveNode = next2.parentNode;
        moveOffset = domIndex$2(next2) + 1;
        next2 = next2.nextSibling;
      }
      if (!next2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom)
          break;
        offset2 = len = 0;
      } else {
        node18 = next2;
        offset2 = 0;
        len = nodeLen$2(node18);
      }
    }
  }
  if (moveNode)
    setSelFocus(view2, sel, moveNode, moveOffset);
}
function isBlockNode$2(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view2, sel, node18, offset2) {
  if (selectionCollapsed$2(sel)) {
    let range = document.createRange();
    range.setEnd(node18, offset2);
    range.setStart(node18, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node18, offset2);
  }
  view2.domObserver.setCurSelection();
  let { state } = view2;
  setTimeout(() => {
    if (view2.state == state)
      selectionToDOM$2(view2);
  }, 50);
}
function selectVertically$2(view2, dir, mods) {
  let sel = view2.state.selection;
  if (sel instanceof TextSelection_1 && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$6 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view2.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next2 = moveSelectionBlock$2(view2.state, dir);
    if (next2 && next2 instanceof NodeSelection_1)
      return apply$4(view2, next2);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection_1 ? Selection_1.near(side, dir) : Selection_1.findFrom(side, dir);
    return beyond ? apply$4(view2, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete$2(view2, dir) {
  if (!(view2.state.selection instanceof TextSelection_1))
    return true;
  let { $head, $anchor, empty: empty2 } = view2.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view2.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view2.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view2.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view2, node18, state) {
  view2.domObserver.stop();
  node18.contentEditable = state;
  view2.domObserver.start();
}
function safariDownArrowBug(view2) {
  if (!safari$2 || view2.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view2.domSelection();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child15 = focusNode.firstChild;
    switchEditable(view2, child15, "true");
    setTimeout(() => switchEditable(view2, child15, "false"), 20);
  }
  return false;
}
function getMods$2(event) {
  let result2 = "";
  if (event.ctrlKey)
    result2 += "c";
  if (event.metaKey)
    result2 += "m";
  if (event.altKey)
    result2 += "a";
  if (event.shiftKey)
    result2 += "s";
  return result2;
}
function captureKeyDown$2(view2, event) {
  let code = event.keyCode, mods = getMods$2(event);
  if (code == 8 || mac$6 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete$2(view2, -1) || skipIgnoredNodesLeft$2(view2);
  } else if (code == 46 || mac$6 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete$2(view2, 1) || skipIgnoredNodesRight$2(view2);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$6 && code == 66 && mods == "c") {
    return selectHorizontally$2(view2, -1, mods) || skipIgnoredNodesLeft$2(view2);
  } else if (code == 39 || mac$6 && code == 70 && mods == "c") {
    return selectHorizontally$2(view2, 1, mods) || skipIgnoredNodesRight$2(view2);
  } else if (code == 38 || mac$6 && code == 80 && mods == "c") {
    return selectVertically$2(view2, -1, mods) || skipIgnoredNodesLeft$2(view2);
  } else if (code == 40 || mac$6 && code == 78 && mods == "c") {
    return safariDownArrowBug(view2) || selectVertically$2(view2, 1, mods) || skipIgnoredNodesRight$2(view2);
  } else if (mods == (mac$6 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard$2(view2, slice11) {
  view2.someProp("transformCopied", (f2) => {
    slice11 = f2(slice11);
  });
  let context = [], { content: content2, openStart, openEnd } = slice11;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node18 = content2.firstChild;
    context.push(node18.type.name, node18.attrs != node18.type.defaultAttrs ? node18.attrs : null);
    content2 = node18.content;
  }
  let serializer = view2.someProp("clipboardSerializer") || DOMSerializer$5.fromSchema(view2.state.schema);
  let doc2 = detachedDoc$2(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content2, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap$2[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text8 = view2.someProp("clipboardTextSerializer", (f2) => f2(slice11)) || slice11.content.textBetween(0, slice11.content.size, "\n\n");
  return { dom: wrap2, text: text8 };
}
function parseFromClipboard$2(view2, text8, html2, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice11;
  if (!html2 && !text8)
    return null;
  let asText = text8 && (plainText || inCode || !html2);
  if (asText) {
    view2.someProp("transformPastedText", (f2) => {
      text8 = f2(text8, inCode || plainText);
    });
    if (inCode)
      return text8 ? new Slice$5(Fragment$5.from(view2.state.schema.text(text8.replace(/\r\n?/g, "\n"))), 0, 0) : Slice$5.empty;
    let parsed = view2.someProp("clipboardTextParser", (f2) => f2(text8, $context, plainText));
    if (parsed) {
      slice11 = parsed;
    } else {
      let marks9 = $context.marks();
      let { schema: schema2 } = view2.state, serializer = DOMSerializer$5.fromSchema(schema2);
      dom = document.createElement("div");
      text8.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p2 = dom.appendChild(document.createElement("p"));
        if (block)
          p2.appendChild(serializer.serializeNode(schema2.text(block, marks9)));
      });
    }
  } else {
    view2.someProp("transformPastedHTML", (f2) => {
      html2 = f2(html2);
    });
    dom = readHTML$2(html2);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0 && dom.firstChild; i--)
      dom = dom.firstChild;
  if (!slice11) {
    let parser = view2.someProp("clipboardParser") || view2.someProp("domParser") || DOMParser$5.fromSchema(view2.state.schema);
    slice11 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice11 = addContext$2(closeSlice(slice11, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice11 = Slice$5.maxOpen(normalizeSiblings$2(slice11.content, $context), true);
    if (slice11.openStart || slice11.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node18 = slice11.content.firstChild; openStart < slice11.openStart && !node18.type.spec.isolating; openStart++, node18 = node18.firstChild) {
      }
      for (let node18 = slice11.content.lastChild; openEnd < slice11.openEnd && !node18.type.spec.isolating; openEnd++, node18 = node18.lastChild) {
      }
      slice11 = closeSlice(slice11, openStart, openEnd);
    }
  }
  view2.someProp("transformPasted", (f2) => {
    slice11 = f2(slice11);
  });
  return slice11;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings$2(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match2 = parent.contentMatchAt($context.index(d));
    let lastWrap, result2 = [];
    fragment.forEach((node18) => {
      if (!result2)
        return;
      let wrap2 = match2.findWrapping(node18.type), inLast;
      if (!wrap2)
        return result2 = null;
      if (inLast = result2.length && lastWrap.length && addToSibling$2(wrap2, lastWrap, node18, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length)
          result2[result2.length - 1] = closeRight$2(result2[result2.length - 1], lastWrap.length);
        let wrapped = withWrappers$2(node18, wrap2);
        result2.push(wrapped);
        match2 = match2.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result2)
      return Fragment$5.from(result2);
  }
  return fragment;
}
function withWrappers$2(node18, wrap2, from12 = 0) {
  for (let i = wrap2.length - 1; i >= from12; i--)
    node18 = wrap2[i].create(null, Fragment$5.from(node18));
  return node18;
}
function addToSibling$2(wrap2, lastWrap, node18, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling$2(wrap2, lastWrap, node18, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node18.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment$5.from(withWrappers$2(node18, wrap2, depth + 1))));
  }
}
function closeRight$2(node18, depth) {
  if (depth == 0)
    return node18;
  let fragment = node18.content.replaceChild(node18.childCount - 1, closeRight$2(node18.lastChild, depth - 1));
  let fill = node18.contentMatchAt(node18.childCount).fillBefore(Fragment$5.empty, true);
  return node18.copy(fragment.append(fill));
}
function closeRange(fragment, side, from12, to, depth, openEnd) {
  let node18 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node18.content;
  if (depth < to - 1)
    inner = closeRange(inner, side, from12, to, depth + 1, openEnd);
  if (depth >= from12)
    inner = side < 0 ? node18.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node18.contentMatchAt(node18.childCount).fillBefore(Fragment$5.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node18.copy(inner));
}
function closeSlice(slice11, openStart, openEnd) {
  if (openStart < slice11.openStart)
    slice11 = new Slice$5(closeRange(slice11.content, -1, openStart, slice11.openStart, 0, slice11.openEnd), openStart, slice11.openEnd);
  if (openEnd < slice11.openEnd)
    slice11 = new Slice$5(closeRange(slice11.content, 1, openEnd, slice11.openEnd, 0, 0), slice11.openStart, openEnd);
  return slice11;
}
const wrapMap$2 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc$2() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML$2(html2) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas)
    html2 = html2.slice(metas[0].length);
  let elt = detachedDoc$2().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap$2[firstTag[1].toLowerCase()])
    html2 = wrap2.map((n2) => "<" + n2 + ">").join("") + html2 + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = html2;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes2 = dom.querySelectorAll(chrome$4 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes2.length; i++) {
    let node18 = nodes2[i];
    if (node18.childNodes.length == 1 && node18.textContent == "\xA0" && node18.parentNode)
      node18.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node18);
  }
}
function addContext$2(slice11, context) {
  if (!slice11.size)
    return slice11;
  let schema2 = slice11.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice11;
  }
  let { content: content2, openStart, openEnd } = slice11;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema2.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content2 = Fragment$5.from(type.create(array[i + 1], content2));
    openStart++;
    openEnd++;
  }
  return new Slice$5(content2, openStart, openEnd);
}
const handlers$2 = {};
const editHandlers$2 = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput$2(view2) {
  for (let event in handlers$2) {
    let handler = handlers$2[event];
    view2.dom.addEventListener(event, view2.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView$2(view2, event2) && !runCustomHandler$2(view2, event2) && (view2.editable || !(event2.type in editHandlers$2)))
        handler(view2, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari$2)
    view2.dom.addEventListener("input", () => null);
  ensureListeners$2(view2);
}
function setSelectionOrigin(view2, origin) {
  view2.input.lastSelectionOrigin = origin;
  view2.input.lastSelectionTime = Date.now();
}
function destroyInput$2(view2) {
  view2.domObserver.stop();
  for (let type in view2.input.eventHandlers)
    view2.dom.removeEventListener(type, view2.input.eventHandlers[type]);
  clearTimeout(view2.input.composingTimeout);
  clearTimeout(view2.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners$2(view2) {
  view2.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view2.input.eventHandlers[type])
        view2.dom.addEventListener(type, view2.input.eventHandlers[type] = (event) => runCustomHandler$2(view2, event));
  });
}
function runCustomHandler$2(view2, event) {
  return view2.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view2, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView$2(view2, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node18 = event.target; node18 != view2.dom; node18 = node18.parentNode)
    if (!node18 || node18.nodeType == 11 || node18.pmViewDesc && node18.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent$2(view2, event) {
  if (!runCustomHandler$2(view2, event) && handlers$2[event.type] && (view2.editable || !(event.type in editHandlers$2)))
    handlers$2[event.type](view2, event);
}
editHandlers$2.keydown = (view2, _event) => {
  let event = _event;
  view2.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view2, event))
    return;
  view2.input.lastKeyCode = event.keyCode;
  view2.input.lastKeyCodeTime = Date.now();
  if (android && chrome$4 && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view2.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view2.input.lastIOSEnter = now2;
    view2.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view2.input.lastIOSEnter == now2) {
        view2.someProp("handleKeyDown", (f2) => f2(view2, keyEvent$2(13, "Enter")));
        view2.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view2.someProp("handleKeyDown", (f2) => f2(view2, event)) || captureKeyDown$2(view2, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view2, "key");
  }
};
editHandlers$2.keyup = (view2, event) => {
  if (event.keyCode == 16)
    view2.input.shiftKey = false;
};
editHandlers$2.keypress = (view2, _event) => {
  let event = _event;
  if (inOrNearComposition(view2, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$6 && event.metaKey)
    return;
  if (view2.someProp("handleKeyPress", (f2) => f2(view2, event))) {
    event.preventDefault();
    return;
  }
  let sel = view2.state.selection;
  if (!(sel instanceof TextSelection_1) || !sel.$from.sameParent(sel.$to)) {
    let text8 = String.fromCharCode(event.charCode);
    if (!view2.someProp("handleTextInput", (f2) => f2(view2, sel.$from.pos, sel.$to.pos, text8)))
      view2.dispatch(view2.state.tr.insertText(text8).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords$2(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear$2(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext$2(view2, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view2.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view2.someProp(propName, (f2) => i > $pos.depth ? f2(view2, pos, $pos.nodeAfter, $pos.before(i), event, true) : f2(view2, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection$2(view2, selection, origin) {
  if (!view2.focused)
    view2.focus();
  let tr = view2.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view2.dispatch(tr);
}
function selectClickedLeaf$2(view2, inside) {
  if (inside == -1)
    return false;
  let $pos = view2.state.doc.resolve(inside), node18 = $pos.nodeAfter;
  if (node18 && node18.isAtom && NodeSelection_1.isSelectable(node18)) {
    updateSelection$2(view2, new NodeSelection_1($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode$2(view2, inside) {
  if (inside == -1)
    return false;
  let sel = view2.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection_1)
    selectedNode = sel.node;
  let $pos = view2.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection_1.isSelectable(node18)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection$2(view2, NodeSelection_1.create(view2.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick$2(view2, pos, inside, event, selectNode) {
  return runHandlerOnContext$2(view2, "handleClickOn", pos, inside, event) || view2.someProp("handleClick", (f2) => f2(view2, pos, event)) || (selectNode ? selectClickedNode$2(view2, inside) : selectClickedLeaf$2(view2, inside));
}
function handleDoubleClick$2(view2, pos, inside, event) {
  return runHandlerOnContext$2(view2, "handleDoubleClickOn", pos, inside, event) || view2.someProp("handleDoubleClick", (f2) => f2(view2, pos, event));
}
function handleTripleClick$2(view2, pos, inside, event) {
  return runHandlerOnContext$2(view2, "handleTripleClickOn", pos, inside, event) || view2.someProp("handleTripleClick", (f2) => f2(view2, pos, event)) || defaultTripleClick$2(view2, inside, event);
}
function defaultTripleClick$2(view2, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view2.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection$2(view2, TextSelection_1.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node18.inlineContent)
      updateSelection$2(view2, TextSelection_1.create(doc2, nodePos + 1, nodePos + 1 + node18.content.size), "pointer");
    else if (NodeSelection_1.isSelectable(node18))
      updateSelection$2(view2, NodeSelection_1.create(doc2, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush$2(view2) {
  return endComposition(view2);
}
const selectNodeModifier$2 = mac$6 ? "metaKey" : "ctrlKey";
handlers$2.mousedown = (view2, _event) => {
  let event = _event;
  view2.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush$2(view2);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view2.input.lastClick.time < 500 && isNear$2(event, view2.input.lastClick) && !event[selectNodeModifier$2]) {
    if (view2.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view2.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view2.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view2.posAtCoords(eventCoords$2(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view2.input.mouseDown)
      view2.input.mouseDown.done();
    view2.input.mouseDown = new MouseDown$2(view2, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick$2 : handleTripleClick$2)(view2, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view2, "pointer");
  }
};
class MouseDown$2 {
  constructor(view2, pos, event, flushed) {
    this.view = view2;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view2.state.doc;
    this.selectNode = !!event[selectNodeModifier$2];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view2.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view2.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view2.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view2.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection_1 && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko$3 && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view2.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view2.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view2, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM$2(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords$2(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick$2(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || safari$2 && this.mightDrag && !this.mightDrag.node.isAtom || chrome$4 && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection$2(this.view, Selection_1.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers$2.touchstart = (view2) => {
  view2.input.lastTouch = Date.now();
  forceDOMFlush$2(view2);
  setSelectionOrigin(view2, "pointer");
};
handlers$2.touchmove = (view2) => {
  view2.input.lastTouch = Date.now();
  setSelectionOrigin(view2, "pointer");
};
handlers$2.contextmenu = (view2) => forceDOMFlush$2(view2);
function inOrNearComposition(view2, event) {
  if (view2.composing)
    return true;
  if (safari$2 && Math.abs(event.timeStamp - view2.input.compositionEndedAt) < 500) {
    view2.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers$2.compositionstart = editHandlers$2.compositionupdate = (view2) => {
  if (!view2.composing) {
    view2.domObserver.flush();
    let { state } = view2, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m2) => m2.type.spec.inclusive === false))) {
      view2.markCursor = view2.state.storedMarks || $pos.marks();
      endComposition(view2, true);
      view2.markCursor = null;
    } else {
      endComposition(view2);
      if (gecko$3 && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view2.domSelection();
        for (let node18 = sel.focusNode, offset2 = sel.focusOffset; node18 && node18.nodeType == 1 && offset2 != 0; ) {
          let before8 = offset2 < 0 ? node18.lastChild : node18.childNodes[offset2 - 1];
          if (!before8)
            break;
          if (before8.nodeType == 3) {
            sel.collapse(before8, before8.nodeValue.length);
            break;
          } else {
            node18 = before8;
            offset2 = -1;
          }
        }
      }
    }
    view2.input.composing = true;
  }
  scheduleComposeEnd(view2, timeoutComposition);
};
editHandlers$2.compositionend = (view2, event) => {
  if (view2.composing) {
    view2.input.composing = false;
    view2.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view2, 20);
  }
};
function scheduleComposeEnd(view2, delay) {
  clearTimeout(view2.input.composingTimeout);
  if (delay > -1)
    view2.input.composingTimeout = setTimeout(() => endComposition(view2), delay);
}
function clearComposition(view2) {
  if (view2.composing) {
    view2.input.composing = false;
    view2.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view2.input.compositionNodes.length > 0)
    view2.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view2, forceUpdate = false) {
  if (android && view2.domObserver.flushingSoon >= 0)
    return;
  view2.domObserver.forceFlush();
  clearComposition(view2);
  if (forceUpdate || view2.docView && view2.docView.dirty) {
    let sel = selectionFromDOM(view2);
    if (sel && !sel.eq(view2.state.selection))
      view2.dispatch(view2.state.tr.setSelection(sel));
    else
      view2.updateState(view2.state);
    return true;
  }
  return false;
}
function captureCopy$2(view2, dom) {
  if (!view2.dom.parentNode)
    return;
  let wrap2 = view2.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view2.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view2.focus();
  }, 50);
}
const brokenClipboardAPI$2 = ie$3 && ie_version < 15 || ios && webkit_version < 604;
handlers$2.copy = editHandlers$2.cut = (view2, _event) => {
  let event = _event;
  let sel = view2.state.selection, cut15 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI$2 ? null : event.clipboardData;
  let slice11 = sel.content(), { dom, text: text8 } = serializeForClipboard$2(view2, slice11);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text8);
  } else {
    captureCopy$2(view2, dom);
  }
  if (cut15)
    view2.dispatch(view2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode$2(slice11) {
  return slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1 ? slice11.content.firstChild : null;
}
function capturePaste$2(view2, event) {
  if (!view2.dom.parentNode)
    return;
  let plainText = view2.input.shiftKey || view2.state.selection.$from.parent.type.spec.code;
  let target = view2.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view2.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste$2(view2, target.value, null, event);
    else
      doPaste$2(view2, target.textContent, target.innerHTML, event);
  }, 50);
}
function doPaste$2(view2, text8, html2, event) {
  let slice11 = parseFromClipboard$2(view2, text8, html2, view2.input.shiftKey, view2.state.selection.$from);
  if (view2.someProp("handlePaste", (f2) => f2(view2, event, slice11 || Slice$5.empty)))
    return true;
  if (!slice11)
    return false;
  let singleNode = sliceSingleNode$2(slice11);
  let tr = singleNode ? view2.state.tr.replaceSelectionWith(singleNode, view2.input.shiftKey) : view2.state.tr.replaceSelection(slice11);
  view2.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers$2.paste = (view2, _event) => {
  let event = _event;
  if (view2.composing && !android)
    return;
  let data = brokenClipboardAPI$2 ? null : event.clipboardData;
  if (data && doPaste$2(view2, data.getData("text/plain"), data.getData("text/html"), event))
    event.preventDefault();
  else
    capturePaste$2(view2, event);
};
class Dragging$2 {
  constructor(slice11, move3) {
    this.slice = slice11;
    this.move = move3;
  }
}
const dragCopyModifier$2 = mac$6 ? "altKey" : "ctrlKey";
handlers$2.dragstart = (view2, _event) => {
  let event = _event;
  let mouseDown = view2.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view2.state.selection;
  let pos = sel.empty ? null : view2.posAtCoords(eventCoords$2(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection_1 ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view2.dispatch(view2.state.tr.setSelection(NodeSelection_1.create(view2.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view2.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view2.docView)
      view2.dispatch(view2.state.tr.setSelection(NodeSelection_1.create(view2.state.doc, desc.posBefore)));
  }
  let slice11 = view2.state.selection.content(), { dom, text: text8 } = serializeForClipboard$2(view2, slice11);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI$2 ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI$2)
    event.dataTransfer.setData("text/plain", text8);
  view2.dragging = new Dragging$2(slice11, !event[dragCopyModifier$2]);
};
handlers$2.dragend = (view2) => {
  let dragging = view2.dragging;
  window.setTimeout(() => {
    if (view2.dragging == dragging)
      view2.dragging = null;
  }, 50);
};
editHandlers$2.dragover = editHandlers$2.dragenter = (_, e) => e.preventDefault();
editHandlers$2.drop = (view2, _event) => {
  let event = _event;
  let dragging = view2.dragging;
  view2.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view2.posAtCoords(eventCoords$2(event));
  if (!eventPos)
    return;
  let $mouse = view2.state.doc.resolve(eventPos.pos);
  let slice11 = dragging && dragging.slice;
  if (slice11) {
    view2.someProp("transformPasted", (f2) => {
      slice11 = f2(slice11);
    });
  } else {
    slice11 = parseFromClipboard$2(view2, event.dataTransfer.getData(brokenClipboardAPI$2 ? "Text" : "text/plain"), brokenClipboardAPI$2 ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move3 = !!(dragging && !event[dragCopyModifier$2]);
  if (view2.someProp("handleDrop", (f2) => f2(view2, event, slice11 || Slice$5.empty, move3))) {
    event.preventDefault();
    return;
  }
  if (!slice11)
    return;
  event.preventDefault();
  let insertPos = slice11 ? dropPoint_1(view2.state.doc, $mouse.pos, slice11) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view2.state.tr;
  if (move3)
    tr.deleteSelection();
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice11.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice11);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection_1.isSelectable(slice11.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice11.content.firstChild)) {
    tr.setSelection(new NodeSelection_1($pos));
  } else {
    let end8 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end8 = newTo);
    tr.setSelection(selectionBetween$2(view2, $pos, tr.doc.resolve(end8)));
  }
  view2.focus();
  view2.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers$2.focus = (view2) => {
  view2.input.lastFocus = Date.now();
  if (!view2.focused) {
    view2.domObserver.stop();
    view2.dom.classList.add("ProseMirror-focused");
    view2.domObserver.start();
    view2.focused = true;
    setTimeout(() => {
      if (view2.docView && view2.hasFocus() && !view2.domObserver.currentSelection.eq(view2.domSelection()))
        selectionToDOM$2(view2);
    }, 20);
  }
};
handlers$2.blur = (view2, _event) => {
  let event = _event;
  if (view2.focused) {
    view2.domObserver.stop();
    view2.dom.classList.remove("ProseMirror-focused");
    view2.domObserver.start();
    if (event.relatedTarget && view2.dom.contains(event.relatedTarget))
      view2.domObserver.currentSelection.clear();
    view2.focused = false;
  }
};
handlers$2.beforeinput = (view2, _event) => {
  let event = _event;
  if (chrome$4 && android && event.inputType == "deleteContentBackward") {
    view2.domObserver.flushSoon();
    let { domChangeCount } = view2.input;
    setTimeout(() => {
      if (view2.input.domChangeCount != domChangeCount)
        return;
      view2.dom.blur();
      view2.focus();
      if (view2.someProp("handleKeyDown", (f2) => f2(view2, keyEvent$2(8, "Backspace"))))
        return;
      let { $cursor } = view2.state.selection;
      if ($cursor && $cursor.pos > 0)
        view2.dispatch(view2.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers$2)
  handlers$2[prop] = editHandlers$2[prop];
function compareObjs$2(a, b) {
  if (a == b)
    return true;
  for (let p2 in a)
    if (a[p2] !== b[p2])
      return false;
  for (let p2 in b)
    if (!(p2 in a))
      return false;
  return true;
}
class WidgetType$2 {
  constructor(toDOM4, spec) {
    this.toDOM = toDOM4;
    this.spec = spec || noSpec$2;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration$2(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType$2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs$2(this.spec, other.spec));
  }
  destroy(node18) {
    if (this.spec.destroy)
      this.spec.destroy(node18);
  }
}
class InlineType$2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec$2;
  }
  map(mapping, span, offset2, oldOffset) {
    let from12 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from12 >= to ? null : new Decoration$2(from12, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType$2 && compareObjs$2(this.attrs, other.attrs) && compareObjs$2(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType$2;
  }
  destroy() {
  }
}
class NodeType$7 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec$2;
  }
  map(mapping, span, offset2, oldOffset) {
    let from12 = mapping.mapResult(span.from + oldOffset, 1);
    if (from12.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from12.pos)
      return null;
    return new Decoration$2(from12.pos - offset2, to.pos - offset2, this);
  }
  valid(node18, span) {
    let { index: index8, offset: offset2 } = node18.content.findIndex(span.from), child15;
    return offset2 == span.from && !(child15 = node18.child(index8)).isText && offset2 + child15.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType$7 && compareObjs$2(this.attrs, other.attrs) && compareObjs$2(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration$2 {
  constructor(from12, to, type) {
    this.from = from12;
    this.to = to;
    this.type = type;
  }
  copy(from12, to) {
    return new Decoration$2(from12, to, this.type);
  }
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  static widget(pos, toDOM4, spec) {
    return new Decoration$2(pos, pos, new WidgetType$2(toDOM4, spec));
  }
  static inline(from12, to, attrs, spec) {
    return new Decoration$2(from12, to, new InlineType$2(attrs, spec));
  }
  static node(from12, to, attrs, spec) {
    return new Decoration$2(from12, to, new NodeType$7(attrs, spec));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof InlineType$2;
  }
}
const none$2 = [], noSpec$2 = {};
class DecorationSet$2 {
  constructor(local, children) {
    this.local = local.length ? local : none$2;
    this.children = children.length ? children : none$2;
  }
  static create(doc2, decorations) {
    return decorations.length ? buildTree$2(decorations, doc2, 0, noSpec$2) : empty$2;
  }
  find(start16, end8, predicate) {
    let result2 = [];
    this.findInner(start16 == null ? 0 : start16, end8 == null ? 1e9 : end8, result2, 0, predicate);
    return result2;
  }
  findInner(start16, end8, result2, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end8 && span.to >= start16 && (!predicate || predicate(span.spec)))
        result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end8 && this.children[i + 1] > start16) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start16 - childOff, end8 - childOff, result2, offset2 + childOff, predicate);
      }
    }
  }
  map(mapping, doc2, options) {
    if (this == empty$2 || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec$2);
  }
  mapInner(mapping, node18, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node18, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren$2(this.children, newLocal || [], mapping, node18, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet$2(newLocal.sort(byPos$2), none$2) : empty$2;
  }
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty$2)
      return DecorationSet$2.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode$2(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree$2(found2, childNode, baseOffset + 1, noSpec$2));
      childIndex += 3;
    });
    let local = moveSpans$2(childIndex ? withoutNulls$2(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet$2(local.length ? this.local.concat(local).sort(byPos$2) : this.local, children || this.children);
  }
  remove(decorations) {
    if (decorations.length == 0 || this == empty$2)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from12 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from12 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from12 + 1);
      if (removed != empty$2) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet$2(local, children) : empty$2;
  }
  forChild(offset2, node18) {
    if (this == empty$2)
      return this;
    if (node18.isLeaf)
      return DecorationSet$2.empty;
    let child15, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child15 = this.children[i + 2];
        break;
      }
    let start16 = offset2 + 1, end8 = start16 + node18.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end8 && dec.to > start16 && dec.type instanceof InlineType$2) {
        let from12 = Math.max(start16, dec.from) - start16, to = Math.min(end8, dec.to) - start16;
        if (from12 < to)
          (local || (local = [])).push(dec.copy(from12, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet$2(local.sort(byPos$2), none$2);
      return child15 ? new DecorationGroup$2([localSet, child15]) : localSet;
    }
    return child15 || empty$2;
  }
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet$2) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  locals(node18) {
    return removeOverlap$2(this.localsInner(node18));
  }
  localsInner(node18) {
    if (this == empty$2)
      return none$2;
    if (node18.inlineContent || !this.local.some(InlineType$2.is))
      return this.local;
    let result2 = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType$2))
        result2.push(this.local[i]);
    }
    return result2;
  }
}
DecorationSet$2.empty = new DecorationSet$2([], []);
DecorationSet$2.removeOverlap = removeOverlap$2;
const empty$2 = DecorationSet$2.empty;
class DecorationGroup$2 {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec$2));
    return DecorationGroup$2.from(mappedDecos);
  }
  forChild(offset2, child15) {
    if (child15.isLeaf)
      return DecorationSet$2.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result2 = this.members[i].forChild(offset2, child15);
      if (result2 == empty$2)
        continue;
      if (result2 instanceof DecorationGroup$2)
        found2 = found2.concat(result2.members);
      else
        found2.push(result2);
    }
    return DecorationGroup$2.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup$2) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node18) {
    let result2, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals5 = this.members[i].localsInner(node18);
      if (!locals5.length)
        continue;
      if (!result2) {
        result2 = locals5;
      } else {
        if (sorted) {
          result2 = result2.slice();
          sorted = false;
        }
        for (let j = 0; j < locals5.length; j++)
          result2.push(locals5[j]);
      }
    }
    return result2 ? removeOverlap$2(sorted ? result2 : result2.sort(byPos$2)) : none$2;
  }
  static from(members) {
    switch (members.length) {
      case 0:
        return empty$2;
      case 1:
        return members[0];
      default:
        return new DecorationGroup$2(members);
    }
  }
}
function mapChildren$2(oldChildren, newLocal, mapping, node18, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end8 = children[i2 + 1];
        if (end8 < 0 || oldStart > end8 + baseOffset - moved)
          continue;
        let start16 = children[i2] + baseOffset - moved;
        if (oldEnd >= start16) {
          children[i2 + 1] = oldStart <= start16 ? -2 : -1;
        } else if (newStart >= offset2 && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from12 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from12 - offset2;
      if (fromLocal < 0 || fromLocal >= node18.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index8, offset: childOffset } = node18.content.findIndex(fromLocal);
      let childNode = node18.maybeChild(index8);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from12 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty$2) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations$2(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree$2(decorations, node18, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from12 = built.children[i];
      while (j < children.length && children[j] < from12)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet$2(newLocal.sort(byPos$2), children);
}
function moveSpans$2(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result2 = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result2.push(new Decoration$2(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations$2(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode$2(spans, node18, offset2) {
  if (node18.isLeaf)
    return null;
  let end8 = offset2 + node18.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end8) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls$2(array) {
  let result2 = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result2.push(array[i]);
  return result2;
}
function buildTree$2(spans, node18, offset2, options) {
  let children = [], hasNulls = false;
  node18.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode$2(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree$2(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty$2)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals5 = moveSpans$2(hasNulls ? withoutNulls$2(spans) : spans, -offset2).sort(byPos$2);
  for (let i = 0; i < locals5.length; i++)
    if (!locals5[i].type.valid(node18, locals5[i])) {
      if (options.onRemove)
        options.onRemove(locals5[i].spec);
      locals5.splice(i--, 1);
    }
  return locals5.length || children.length ? new DecorationSet$2(locals5, children) : empty$2;
}
function byPos$2(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap$2(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next2 = working[j];
        if (next2.from == span.from) {
          if (next2.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next2.copy(next2.from, span.to);
            insertAhead$2(working, j + 1, next2.copy(span.to, next2.to));
          }
          continue;
        } else {
          if (next2.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next2.from);
            insertAhead$2(working, j, span.copy(next2.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead$2(array, i, deco) {
  while (i < array.length && byPos$2(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations$2(view2) {
  let found2 = [];
  view2.someProp("decorations", (f2) => {
    let result2 = f2(view2.state);
    if (result2 && result2 != empty$2)
      found2.push(result2);
  });
  if (view2.cursorWrapper)
    found2.push(DecorationSet$2.create(view2.state.doc, [view2.cursorWrapper.deco]));
  return DecorationGroup$2.from(found2);
}
const observeOptions$2 = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData$2 = ie$3 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver$2 {
  constructor(view2, handleDOMChange) {
    this.view = view2;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$3 && ie_version <= 11 && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData$2) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions$2);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection$2(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM$2(this.view);
    if (ie$3 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelection();
      if (sel.focusNode && isEquivalentPosition$2(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelection());
  }
  ignoreSelectionChange(sel) {
    if (sel.rangeCount == 0)
      return true;
    let container = sel.getRangeAt(0).commonAncestorContainer;
    let desc = this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  flush() {
    let { view: view2 } = this;
    if (!view2.docView || this.flushingSoon > -1)
      return;
    let mutations = this.observer ? this.observer.takeRecords() : [];
    if (this.queue.length) {
      mutations = this.queue.concat(mutations);
      this.queue.length = 0;
    }
    let sel = view2.domSelection();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection$2(view2) && !this.ignoreSelectionChange(sel);
    let from12 = -1, to = -1, typeOver = false, added = [];
    if (view2.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result2 = this.registerMutation(mutations[i], added);
        if (result2) {
          from12 = from12 < 0 ? result2.from : Math.min(result2.from, from12);
          to = to < 0 ? result2.to : Math.max(result2.to, to);
          if (result2.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko$3 && added.length > 1) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    let readSel = null;
    if (from12 < 0 && newSel && view2.input.lastFocus > Date.now() - 200 && view2.input.lastTouch < Date.now() - 300 && selectionCollapsed$2(sel) && (readSel = selectionFromDOM(view2)) && readSel.eq(Selection_1.near(view2.state.doc.resolve(0), 1))) {
      view2.input.lastFocus = 0;
      selectionToDOM$2(view2);
      this.currentSelection.set(sel);
      view2.scrollToSelection();
    } else if (from12 > -1 || newSel) {
      if (from12 > -1) {
        view2.docView.markDirty(from12, to);
        checkCSS(view2);
      }
      this.handleDOMChange(from12, to, typeOver, added);
      if (view2.docView && view2.docView.dirty)
        view2.updateState(view2.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM$2(view2);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++)
        added.push(mut.addedNodes[i]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev2 = mut.previousSibling, next2 = mut.nextSibling;
      if (ie$3 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev2 = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next2 = nextSibling;
        }
      }
      let fromOffset = prev2 && prev2.parentNode == mut.target ? domIndex$2(prev2) + 1 : 0;
      let from12 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next2 && next2.parentNode == mut.target ? domIndex$2(next2) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from12, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view2) {
  if (cssChecked.has(view2))
    return;
  cssChecked.set(view2, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view2.dom).whiteSpace) !== -1) {
    view2.requiresGeckoHackNode = gecko$3;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function parseBetween$2(view2, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from12, to } = view2.docView.parseRange(from_, to_);
  let domSel = view2.domSelection();
  let find5;
  let anchor = domSel.anchorNode;
  if (anchor && view2.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find5 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed$2(domSel))
      find5.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome$4 && view2.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node18 = parent.childNodes[off - 1], desc = node18.pmViewDesc;
      if (node18.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view2.state.doc;
  let parser = view2.someProp("domParser") || DOMParser$5.fromSchema(view2.state.schema);
  let $from = startDoc.resolve(from12);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find5,
    ruleFromNode: ruleFromNode$2,
    context: $from
  });
  if (find5 && find5[0].pos != null) {
    let anchor2 = find5[0].pos, head = find5[1] && find5[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from12, head: head + from12 };
  }
  return { doc: doc2, sel, from: from12, to };
}
function ruleFromNode$2(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari$2 && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari$2 && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
function readDOMChange$2(view2, from12, to, typeOver, addedNodes) {
  if (from12 < 0) {
    let origin = view2.input.lastSelectionTime > Date.now() - 50 ? view2.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view2, origin);
    if (newSel && !view2.state.selection.eq(newSel)) {
      let tr2 = view2.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      view2.dispatch(tr2);
    }
    return;
  }
  let $before = view2.state.doc.resolve(from12);
  let shared2 = $before.sharedDepth(to);
  from12 = $before.before(shared2 + 1);
  to = view2.state.doc.resolve(to).after(shared2 + 1);
  let sel = view2.state.selection;
  let parse16 = parseBetween$2(view2, from12, to);
  let doc2 = view2.state.doc, compare = doc2.slice(parse16.from, parse16.to);
  let preferredPos, preferredSide;
  if (view2.input.lastKeyCode === 8 && Date.now() - 100 < view2.input.lastKeyCodeTime) {
    preferredPos = view2.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view2.state.selection.from;
    preferredSide = "start";
  }
  view2.input.lastKeyCode = null;
  let change = findDiff$2(compare.content, parse16.doc.content, parse16.from, preferredPos, preferredSide);
  if ((ios && view2.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P") && (!change || change.endA >= change.endB) && view2.someProp("handleKeyDown", (f2) => f2(view2, keyEvent$2(13, "Enter")))) {
    view2.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection_1 && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view2.composing && !(parse16.sel && parse16.sel.anchor != parse16.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse16.sel) {
        let sel2 = resolveSelection$2(view2, view2.state.doc, parse16.sel);
        if (sel2 && !sel2.eq(view2.state.selection))
          view2.dispatch(view2.state.tr.setSelection(sel2));
      }
      return;
    }
  }
  if (chrome$4 && view2.cursorWrapper && parse16.sel && parse16.sel.anchor == view2.cursorWrapper.deco.from && parse16.sel.head == parse16.sel.anchor) {
    let size = change.endB - change.start;
    parse16.sel = { anchor: parse16.sel.anchor + size, head: parse16.sel.anchor + size };
  }
  view2.input.domChangeCount++;
  if (view2.state.selection.from < view2.state.selection.to && change.start == change.endB && view2.state.selection instanceof TextSelection_1) {
    if (change.start > view2.state.selection.from && change.start <= view2.state.selection.from + 2 && view2.state.selection.from >= parse16.from) {
      change.start = view2.state.selection.from;
    } else if (change.endA < view2.state.selection.to && change.endA >= view2.state.selection.to - 2 && view2.state.selection.to <= parse16.to) {
      change.endB += view2.state.selection.to - change.endA;
      change.endA = view2.state.selection.to;
    }
  }
  if (ie$3 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse16.from && parse16.doc.textBetween(change.start - parse16.from - 1, change.start - parse16.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse16.doc.resolveNoCache(change.start - parse16.from);
  let $to = parse16.doc.resolveNoCache(change.endB - parse16.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view2.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse16.doc.content.size && (nextSel = Selection_1.findFrom(parse16.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view2.someProp("handleKeyDown", (f2) => f2(view2, keyEvent$2(13, "Enter")))) {
    view2.input.lastIOSEnter = 0;
    return;
  }
  if (view2.state.selection.anchor > change.start && looksLikeJoin$2(doc2, change.start, change.endA, $from, $to) && view2.someProp("handleKeyDown", (f2) => f2(view2, keyEvent$2(8, "Backspace")))) {
    if (android && chrome$4)
      view2.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome$4 && android && change.endB == change.start)
    view2.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse16.sel && parse16.sel.anchor == parse16.sel.head && parse16.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse16.doc.resolveNoCache(change.endB - parse16.from);
    setTimeout(() => {
      view2.someProp("handleKeyDown", function(f2) {
        return f2(view2, keyEvent$2(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$3 && ie_version <= 11 && $from.parentOffset == 0) {
        view2.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM$2(view2), 20);
      }
      tr = view2.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange$2($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view2.state.tr;
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text8 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view2.someProp("handleTextInput", (f2) => f2(view2, chFrom, chTo, text8)))
        return;
      tr = view2.state.tr.insertText(text8, chFrom, chTo);
    }
  }
  if (!tr)
    tr = view2.state.tr.replace(chFrom, chTo, parse16.doc.slice(change.start - parse16.from, change.endB - parse16.from));
  if (parse16.sel) {
    let sel2 = resolveSelection$2(view2, tr.doc, parse16.sel);
    if (sel2 && !(chrome$4 && android && view2.composing && sel2.empty && (change.start != change.endB || view2.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$3 && sel2.empty && sel2.head == chFrom))
      tr.setSelection(sel2);
  }
  if (storedMarks)
    tr.ensureMarks(storedMarks);
  view2.dispatch(tr.scrollIntoView());
}
function resolveSelection$2(view2, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween$2(view2, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange$2(cur, prev2) {
  let curMarks = cur.firstChild.marks, prevMarks = prev2.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark15, update4;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark15 = added[0];
    type = "add";
    update4 = (node18) => node18.mark(mark15.addToSet(node18.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark15 = removed[0];
    type = "remove";
    update4 = (node18) => node18.mark(mark15.removeFromSet(node18.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev2.childCount; i++)
    updated.push(update4(prev2.child(i)));
  if (Fragment$5.from(updated).eq(cur))
    return { mark: mark15, type };
}
function looksLikeJoin$2(old, start16, end8, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end8 - start16 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening$2($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start16);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening$2($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end8 || skipClosingAndOpening$2($next, true, false) < end8)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening$2($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end8 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end8++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next2 && !next2.isLeaf) {
      next2 = next2.firstChild;
      end8++;
    }
  }
  return end8;
}
function findDiff$2(a, b, pos, preferredPos, preferredSide) {
  let start16 = a.findDiffStart(b, pos);
  if (start16 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start16 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start16;
  }
  if (endA < start16 && a.size < b.size) {
    let move3 = preferredPos <= start16 && preferredPos >= endA ? start16 - preferredPos : 0;
    start16 -= move3;
    endB = start16 + (endB - endA);
    endA = start16;
  } else if (endB < start16) {
    let move3 = preferredPos <= start16 && preferredPos >= endB ? start16 - preferredPos : 0;
    start16 -= move3;
    endA = start16 + (endA - endB);
    endB = start16;
  }
  return { start: start16, endA, endB };
}
class EditorView$2 {
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable$2(this);
    updateCursorWrapper$2(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc$2(this.state.doc, computeDocDeco$2(this), viewDecorations$2(this), this.dom, this);
    this.domObserver = new DOMObserver$2(this, (from12, to, typeOver, added) => readDOMChange$2(this, from12, to, typeOver, added));
    this.domObserver.start();
    initInput$2(this);
    this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let prev2 = this._props;
      this._props = {};
      for (let name in prev2)
        this._props[name] = prev2[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners$2(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    let prev2 = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev2.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners$2(this);
    }
    this.editable = getEditable$2(this);
    updateCursorWrapper$2(this);
    let innerDeco = viewDecorations$2(this), outerDeco = computeDocDeco$2(this);
    let scroll = prev2.plugins != state.plugins && !prev2.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev2.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev2.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos$2(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$3 || chrome$4) && !this.composing && !prev2.selection.empty && !state.selection.empty && selectionContextChanged(prev2.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome$4 ? this.trackWrites = this.domSelection().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc$2(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && anchorInRightPlace(this))) {
        selectionToDOM$2(this, forceSelUpdate);
      } else {
        syncNodeSelection$2(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev2);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos$2(oldScrollPos);
    }
  }
  scrollToSelection() {
    let startDOM = this.domSelection().focusNode;
    if (this.someProp("handleScrollToSelection", (f2) => f2(this)))
      ;
    else if (this.state.selection instanceof NodeSelection_1) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView$2(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView$2(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view2;
    while (view2 = this.pluginViews.pop())
      if (view2.destroy)
        view2.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  someProp(propName, f2) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f2 ? f2(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
          return value;
      }
  }
  hasFocus() {
    if (ie$3) {
      let node18 = this.root.activeElement;
      if (node18 == this.dom)
        return true;
      if (!node18 || !this.dom.contains(node18))
        return false;
      while (node18 && this.dom != node18 && this.dom.contains(node18)) {
        if (node18.contentEditable == "false")
          return false;
        node18 = node18.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM$2(this);
    this.domObserver.start();
  }
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  posAtCoords(coords) {
    return posAtCoords$2(this, coords);
  }
  coordsAtPos(pos, side = 1) {
    return coordsAtPos$2(this, pos, side);
  }
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  posAtDOM(node18, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node18, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  endOfTextblock(dir, state) {
    return endOfTextblock$2(this, state || this.state, dir);
  }
  destroy() {
    if (!this.docView)
      return;
    destroyInput$2(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations$2(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(event) {
    return dispatchEvent$2(this, event);
  }
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  }
  domSelection() {
    return this.root.getSelection();
  }
}
function computeDocDeco$2(view2) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view2.editable);
  attrs.translate = "no";
  view2.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view2.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  return [Decoration$2.node(0, view2.state.doc.content.size, attrs)];
}
function updateCursorWrapper$2(view2) {
  if (view2.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view2.cursorWrapper = { dom, deco: Decoration$2.widget(view2.state.selection.head, dom, { raw: true, marks: view2.markCursor }) };
  } else {
    view2.cursorWrapper = null;
  }
}
function getEditable$2(view2) {
  return !view2.someProp("editable", (value) => value(view2.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view2) {
  let result2 = /* @__PURE__ */ Object.create(null);
  function add4(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result2, prop))
        result2[prop] = obj[prop];
  }
  view2.someProp("nodeViews", add4);
  view2.someProp("markViews", add4);
  return result2;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
const pDOM = ["p", 0], blockquoteDOM = ["blockquote", 0], hrDOM = ["hr"], preDOM = ["pre", ["code", 0]], brDOM = ["br"];
const nodes = {
  doc: {
    content: "block+"
  },
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{ tag: "p" }],
    toDOM() {
      return pDOM;
    }
  },
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{ tag: "blockquote" }],
    toDOM() {
      return blockquoteDOM;
    }
  },
  horizontal_rule: {
    group: "block",
    parseDOM: [{ tag: "hr" }],
    toDOM() {
      return hrDOM;
    }
  },
  heading: {
    attrs: { level: { default: 1 } },
    content: "inline*",
    group: "block",
    defining: true,
    parseDOM: [
      { tag: "h1", attrs: { level: 1 } },
      { tag: "h2", attrs: { level: 2 } },
      { tag: "h3", attrs: { level: 3 } },
      { tag: "h4", attrs: { level: 4 } },
      { tag: "h5", attrs: { level: 5 } },
      { tag: "h6", attrs: { level: 6 } }
    ],
    toDOM(node18) {
      return ["h" + node18.attrs.level, 0];
    }
  },
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
    toDOM() {
      return preDOM;
    }
  },
  text: {
    group: "inline"
  },
  image: {
    inline: true,
    attrs: {
      src: {},
      alt: { default: null },
      title: { default: null }
    },
    group: "inline",
    draggable: true,
    parseDOM: [{ tag: "img[src]", getAttrs(dom) {
      return {
        src: dom.getAttribute("src"),
        title: dom.getAttribute("title"),
        alt: dom.getAttribute("alt")
      };
    } }],
    toDOM(node18) {
      let { src: src2, alt, title } = node18.attrs;
      return ["img", { src: src2, alt, title }];
    }
  },
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{ tag: "br" }],
    toDOM() {
      return brDOM;
    }
  }
};
const emDOM = ["em", 0], strongDOM = ["strong", 0], codeDOM = ["code", 0];
const marks3 = {
  link: {
    attrs: {
      href: {},
      title: { default: null }
    },
    inclusive: false,
    parseDOM: [{ tag: "a[href]", getAttrs(dom) {
      return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
    } }],
    toDOM(node18) {
      let { href, title } = node18.attrs;
      return ["a", { href, title }, 0];
    }
  },
  em: {
    parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }],
    toDOM() {
      return emDOM;
    }
  },
  strong: {
    parseDOM: [
      { tag: "strong" },
      { tag: "b", getAttrs: (node18) => node18.style.fontWeight != "normal" && null },
      { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
    ],
    toDOM() {
      return strongDOM;
    }
  },
  code: {
    parseDOM: [{ tag: "code" }],
    toDOM() {
      return codeDOM;
    }
  }
};
const schema = new Schema$5({ nodes, marks: marks3 });
var schemaList = {};
var dist$a = {};
function OrderedMap$9(content2) {
  this.content = content2;
}
OrderedMap$9.prototype = {
  constructor: OrderedMap$9,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$9(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$9(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$9([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$9(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$9(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$9.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$9(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$9.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$9(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$9.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$9.from = function(value) {
  if (value instanceof OrderedMap$9)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$9(content2);
};
var orderedmap$4 = OrderedMap$9;
Object.defineProperty(dist$a, "__esModule", { value: true });
function _interopDefault$8(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$8 = _interopDefault$8(orderedmap$4);
function findDiffStart$4(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$4(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$4(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$4(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$4 = function Fragment3(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$9 = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$4.prototype.nodesBetween = function nodesBetween5(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$4.prototype.descendants = function descendants5(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$4.prototype.textBetween = function textBetween5(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$4.prototype.append = function append3(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$4(content2, this.size + other.size);
};
Fragment$4.prototype.cut = function cut5(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$4(result2, size);
};
Fragment$4.prototype.cutByIndex = function cutByIndex3(from12, to) {
  if (from12 == to) {
    return Fragment$4.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$4(this.content.slice(from12, to));
};
Fragment$4.prototype.replaceChild = function replaceChild3(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$4(copy12, size);
};
Fragment$4.prototype.addToStart = function addToStart3(node18) {
  return new Fragment$4([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$4.prototype.addToEnd = function addToEnd3(node18) {
  return new Fragment$4(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$4.prototype.eq = function eq9(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$9.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$9.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$9.childCount.get = function() {
  return this.content.length;
};
Fragment$4.prototype.child = function child5(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$4.prototype.maybeChild = function maybeChild5(index8) {
  return this.content[index8];
};
Fragment$4.prototype.forEach = function forEach6(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$4.prototype.findDiffStart = function findDiffStart$13(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$4(this, other, pos);
};
Fragment$4.prototype.findDiffEnd = function findDiffEnd$13(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$4(this, other, pos, otherPos);
};
Fragment$4.prototype.findIndex = function findIndex3(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$4(0, pos);
  }
  if (pos == this.size) {
    return retIndex$4(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$4(i + 1, end8);
      }
      return retIndex$4(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$4.prototype.toString = function toString12() {
  return "<" + this.toStringInner() + ">";
};
Fragment$4.prototype.toStringInner = function toStringInner3() {
  return this.content.join(", ");
};
Fragment$4.prototype.toJSON = function toJSON11() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$4.fromJSON = function fromJSON12(schema2, value) {
  if (!value) {
    return Fragment$4.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$4(value.map(schema2.nodeFromJSON));
};
Fragment$4.fromArray = function fromArray3(array) {
  if (!array.length) {
    return Fragment$4.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$4(joined || array, size);
};
Fragment$4.from = function from3(nodes2) {
  if (!nodes2) {
    return Fragment$4.empty;
  }
  if (nodes2 instanceof Fragment$4) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$4([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$4.prototype, prototypeAccessors$1$9);
var found$4 = { index: 0, offset: 0 };
function retIndex$4(index8, offset2) {
  found$4.index = index8;
  found$4.offset = offset2;
  return found$4;
}
Fragment$4.empty = new Fragment$4([], 0);
function compareDeep$4(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$4(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$4(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$4 = function Mark3(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$4.prototype.addToSet = function addToSet3(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$4.prototype.removeFromSet = function removeFromSet5(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$4.prototype.isInSet = function isInSet5(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$4.prototype.eq = function eq10(other) {
  return this == other || this.type == other.type && compareDeep$4(this.attrs, other.attrs);
};
Mark$4.prototype.toJSON = function toJSON12() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$4.fromJSON = function fromJSON13(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$4.sameSet = function sameSet3(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$4.setFrom = function setFrom3(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$4.none;
  }
  if (marks9 instanceof Mark$4) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$4.none = [];
function ReplaceError$4(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$4.prototype;
  return err8;
}
ReplaceError$4.prototype = Object.create(Error.prototype);
ReplaceError$4.prototype.constructor = ReplaceError$4;
ReplaceError$4.prototype.name = "ReplaceError";
var Slice$4 = function Slice3(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$6 = { size: {} };
prototypeAccessors$2$6.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$4.prototype.insertAt = function insertAt3(pos, fragment) {
  var content2 = insertInto$4(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$4(content2, this.openStart, this.openEnd);
};
Slice$4.prototype.removeBetween = function removeBetween3(from12, to) {
  return new Slice$4(removeRange$4(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$4.prototype.eq = function eq11(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$4.prototype.toString = function toString13() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$4.prototype.toJSON = function toJSON13() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$4.fromJSON = function fromJSON14(schema2, json) {
  if (!json) {
    return Slice$4.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$4(Fragment$4.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$4.maxOpen = function maxOpen3(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$4(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$4.prototype, prototypeAccessors$2$6);
function removeRange$4(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$4(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$4(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$4(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$4.empty = new Slice$4(Fragment$4.empty, 0, 0);
function replace$5($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$4("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$4("Inconsistent open depths");
  }
  return replaceOuter$4($from, $to, slice11, 0);
}
function replaceOuter$4($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$4($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$4(node18, replaceTwoWay$4($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$4(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$4(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$4(node18, replaceThreeWay$4($from, start16, end8, $to, depth));
  }
}
function checkJoin$4(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$4("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$4($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$4(node18, $after.node(depth));
  return node18;
}
function addNode$4(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$4($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$4($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$4(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$4($end.nodeBefore, target);
  }
}
function close$4(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$4("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$4($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$4($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$4($end, $to, depth + 1);
  var content2 = [];
  addRange$4(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$4(openStart, openEnd);
    addNode$4(close$4(openStart, replaceThreeWay$4($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$4(close$4(openStart, replaceTwoWay$4($from, $start, depth + 1)), content2);
    }
    addRange$4($start, $end, depth, content2);
    if (openEnd) {
      addNode$4(close$4(openEnd, replaceTwoWay$4($end, $to, depth + 1)), content2);
    }
  }
  addRange$4($to, null, depth, content2);
  return new Fragment$4(content2);
}
function replaceTwoWay$4($from, $to, depth) {
  var content2 = [];
  addRange$4(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$4($from, $to, depth + 1);
    addNode$4(close$4(type, replaceTwoWay$4($from, $to, depth + 1)), content2);
  }
  addRange$4($to, null, depth, content2);
  return new Fragment$4(content2);
}
function prepareSliceForReplace$4(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$4.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$4 = function ResolvedPos3(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$4 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$4.prototype.resolveDepth = function resolveDepth3(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$4.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$4.doc.get = function() {
  return this.node(0);
};
ResolvedPos$4.prototype.node = function node5(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$4.prototype.index = function index3(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$4.prototype.indexAfter = function indexAfter3(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$4.prototype.start = function start3(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$4.prototype.end = function end3(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$4.prototype.before = function before3(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$4.prototype.after = function after3(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$4.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$4.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$4.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$4.prototype.marks = function marks4() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$4.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$4.prototype.marksAcross = function marksAcross3($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$4.prototype.sharedDepth = function sharedDepth3(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$4.prototype.blockRange = function blockRange3(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$4(this$1$1, other, d);
    }
  }
};
ResolvedPos$4.prototype.sameParent = function sameParent3(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$4.prototype.max = function max3(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$4.prototype.min = function min3(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$4.prototype.toString = function toString14() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$4.resolve = function resolve8(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$4(pos, path, parentOffset);
};
ResolvedPos$4.resolveCached = function resolveCached3(doc2, pos) {
  for (var i = 0; i < resolveCache$4.length; i++) {
    var cached = resolveCache$4[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$4[resolveCachePos$4] = ResolvedPos$4.resolve(doc2, pos);
  resolveCachePos$4 = (resolveCachePos$4 + 1) % resolveCacheSize$4;
  return result2;
};
Object.defineProperties(ResolvedPos$4.prototype, prototypeAccessors$3$4);
var resolveCache$4 = [];
var resolveCachePos$4 = 0;
var resolveCacheSize$4 = 12;
var NodeRange$4 = function NodeRange3($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$4 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$4.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$4.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$4.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$4.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$4.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$4.prototype, prototypeAccessors$1$1$4);
var emptyAttrs$4 = /* @__PURE__ */ Object.create(null);
var Node$5 = function Node4(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$4.empty;
  this.marks = marks9 || Mark$4.none;
};
var prototypeAccessors$c = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$c.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$c.childCount.get = function() {
  return this.content.childCount;
};
Node$5.prototype.child = function child6(index8) {
  return this.content.child(index8);
};
Node$5.prototype.maybeChild = function maybeChild6(index8) {
  return this.content.maybeChild(index8);
};
Node$5.prototype.forEach = function forEach7(f2) {
  this.content.forEach(f2);
};
Node$5.prototype.nodesBetween = function nodesBetween6(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$5.prototype.descendants = function descendants6(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$c.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$5.prototype.textBetween = function textBetween6(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$c.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$c.lastChild.get = function() {
  return this.content.lastChild;
};
Node$5.prototype.eq = function eq12(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$5.prototype.sameMarkup = function sameMarkup3(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$5.prototype.hasMarkup = function hasMarkup3(type, attrs, marks9) {
  return this.type == type && compareDeep$4(this.attrs, attrs || type.defaultAttrs || emptyAttrs$4) && Mark$4.sameSet(this.marks, marks9 || Mark$4.none);
};
Node$5.prototype.copy = function copy4(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$5.prototype.mark = function mark5(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$5.prototype.cut = function cut6(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$5.prototype.slice = function slice4(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$4.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$4(content2, $from.depth - depth, $to.depth - depth);
};
Node$5.prototype.replace = function replace$13(from12, to, slice11) {
  return replace$5(this.resolve(from12), this.resolve(to), slice11);
};
Node$5.prototype.nodeAt = function nodeAt3(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$5.prototype.childAfter = function childAfter3(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$5.prototype.childBefore = function childBefore3(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$5.prototype.resolve = function resolve9(pos) {
  return ResolvedPos$4.resolveCached(this, pos);
};
Node$5.prototype.resolveNoCache = function resolveNoCache3(pos) {
  return ResolvedPos$4.resolve(this, pos);
};
Node$5.prototype.rangeHasMark = function rangeHasMark3(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$c.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$c.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$c.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$c.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$c.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$c.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$c.isAtom.get = function() {
  return this.type.isAtom;
};
Node$5.prototype.toString = function toString15() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$4(this.marks, name);
};
Node$5.prototype.contentMatchAt = function contentMatchAt3(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$5.prototype.canReplace = function canReplace3(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$4.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$5.prototype.canReplaceWith = function canReplaceWith3(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$5.prototype.canAppend = function canAppend3(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$5.prototype.defaultContentType = function defaultContentType3(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$5.prototype.check = function check3() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$5.prototype.toJSON = function toJSON14() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$5.fromJSON = function fromJSON15(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$4.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$5.prototype, prototypeAccessors$c);
var TextNode$4 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$4(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$5);
function wrapMarks$4(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$4 = function ContentMatch3(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$4 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$4.parse = function parse5(string, nodeTypes) {
  var stream = new TokenStream$4(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$4.empty;
  }
  var expr = parseExpr$4(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$4(nfa$4(expr));
  checkForDeadEnds$4(match2, stream);
  return match2;
};
ContentMatch$4.prototype.matchType = function matchType3(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$4.prototype.matchFragment = function matchFragment3(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$4.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$4.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$4.prototype.compatible = function compatible3(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$4.prototype.fillBefore = function fillBefore3(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$4.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$4.prototype.findWrapping = function findWrapping6(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$4.prototype.computeWrapping = function computeWrapping3(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$4.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$4.prototype.edge = function edge3(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$4.prototype.toString = function toString16() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$4.prototype, prototypeAccessors$5$4);
ContentMatch$4.empty = new ContentMatch$4(true);
var TokenStream$4 = function TokenStream3(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$4 = { next: {} };
prototypeAccessors$1$3$4.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$4.prototype.eat = function eat3(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$4.prototype.err = function err3(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$4.prototype, prototypeAccessors$1$3$4);
function parseExpr$4(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$4(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$4(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$4(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$4(stream) {
  var expr = parseExprAtom$4(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$4(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$4(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$4(stream, expr) {
  var min9 = parseNum$4(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$4(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$4(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$4(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$4(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$4(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$4(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$4(a, b) {
  return a - b;
}
function nullFrom$4(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$4);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$4(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$4(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$4(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$4(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$4);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$4(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$4(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$4(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$4(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$4(attrs[name]);
    }
  }
  return result2;
}
var NodeType$6 = function NodeType3(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$4(spec.attrs);
  this.defaultAttrs = defaultAttrs$4(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$4 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$4.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$4.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$4.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$4.empty;
};
prototypeAccessors$4$4.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$6.prototype.hasRequiredAttrs = function hasRequiredAttrs3(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$6.prototype.compatibleContent = function compatibleContent3(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$6.prototype.computeAttrs = function computeAttrs$13(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$4(this.attrs, attrs);
  }
};
NodeType$6.prototype.create = function create6(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$5(this, this.computeAttrs(attrs), Fragment$4.from(content2), Mark$4.setFrom(marks9));
};
NodeType$6.prototype.createChecked = function createChecked3(attrs, content2, marks9) {
  content2 = Fragment$4.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$5(this, this.computeAttrs(attrs), content2, Mark$4.setFrom(marks9));
};
NodeType$6.prototype.createAndFill = function createAndFill3(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$4.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$4.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$5(this, attrs, content2.append(after8), Mark$4.setFrom(marks9));
};
NodeType$6.prototype.validContent = function validContent3(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$6.prototype.allowsMarkType = function allowsMarkType3(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$6.prototype.allowsMarks = function allowsMarks3(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$6.prototype.allowedMarks = function allowedMarks3(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$4.empty;
};
NodeType$6.compile = function compile5(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$6(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$6.prototype, prototypeAccessors$4$4);
var Attribute$4 = function Attribute3(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$4 = { isRequired: {} };
prototypeAccessors$1$2$4.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$4.prototype, prototypeAccessors$1$2$4);
var MarkType$4 = function MarkType3(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$4(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$4(this.attrs);
  this.instance = defaults && new Mark$4(this, defaults);
};
MarkType$4.prototype.create = function create7(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$4(this, computeAttrs$4(this.attrs, attrs));
};
MarkType$4.compile = function compile6(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$4(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$4.prototype.removeFromSet = function removeFromSet6(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$4.prototype.isInSet = function isInSet6(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$4.prototype.excludes = function excludes3(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$4 = function Schema3(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$8.from(spec.nodes);
  this.spec.marks = OrderedMap$8.from(spec.marks);
  this.nodes = NodeType$6.compile(this.spec.nodes, this);
  this.marks = MarkType$4.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$4.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$4(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$4(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$4.prototype.node = function node6(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$6)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$4.prototype.text = function text3(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$4(type, type.defaultAttrs, text$1, Mark$4.setFrom(marks9));
};
Schema$4.prototype.mark = function mark6(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$4.prototype.nodeFromJSON = function nodeFromJSON3(json) {
  return Node$5.fromJSON(this, json);
};
Schema$4.prototype.markFromJSON = function markFromJSON3(json) {
  return Mark$4.fromJSON(this, json);
};
Schema$4.prototype.nodeType = function nodeType3(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$4(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$4 = function DOMParser3(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$4.prototype.parse = function parse6(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$4(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$4.prototype.parseSlice = function parseSlice3(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$4(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$4.maxOpen(context.finish());
};
DOMParser$4.prototype.matchTag = function matchTag3(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$4(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$4.prototype.matchStyle = function matchStyle3(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$4.schemaRules = function schemaRules3(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$5(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$5(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$4.fromSchema = function fromSchema5(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$4(schema2, DOMParser$4.schemaRules(schema2)));
};
var blockTags$4 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$4 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$4 = { ol: true, ul: true };
var OPT_PRESERVE_WS$4 = 1;
var OPT_PRESERVE_WS_FULL$4 = 2;
var OPT_OPEN_LEFT$4 = 4;
function wsOptionsFor$4(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$4 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$4 : 0);
}
var NodeContext$4 = function NodeContext3(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$4 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$4.none;
};
NodeContext$4.prototype.findWrapping = function findWrapping7(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$4.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$4.prototype.finish = function finish5(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$4)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$4.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$4.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$4 = function ParseContext3(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$4(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$4 : 0);
  if (topNode) {
    topContext = new NodeContext$4(
      topNode.type,
      topNode.attrs,
      Mark$4.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$4(null, null, Mark$4.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$4(parser.schema.topNodeType, null, Mark$4.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$4 = { top: {}, currentPos: {} };
prototypeAccessors$6$4.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$4.prototype.addDOM = function addDOM3(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$4(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$4.prototype.addTextNode = function addTextNode3(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$4)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$4)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$4.prototype.addElement = function addElement3(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$4.hasOwnProperty(name)) {
    normalizeList$4(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$4.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$4.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$4.prototype.readStyles = function readStyles3(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$4.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$4.prototype.addElementByRule = function addElementByRule3(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$4.prototype.addAll = function addAll3(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$4.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$4.prototype.findPlace = function findPlace3(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$4.prototype.insertNode = function insertNode3(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$4.prototype.applyPendingMarks = function applyPendingMarks3(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$4.prototype.enter = function enter3(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$4.prototype.enterInner = function enterInner3(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$4 : wsOptionsFor$4(preserveWS);
  if (top.options & OPT_OPEN_LEFT$4 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$4;
  }
  this.nodes.push(new NodeContext$4(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$4.prototype.closeExtra = function closeExtra3(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$4.prototype.finish = function finish6() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$4.prototype.sync = function sync3(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$4.prototype.addPendingMark = function addPendingMark3(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$4.prototype.removePendingMark = function removePendingMark3(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$4.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$4.prototype.findAtPoint = function findAtPoint3(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$4.prototype.findInside = function findInside3(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$4.prototype.findAround = function findAround3(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$4.prototype.findInText = function findInText3(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$4.prototype.matchesContext = function matchesContext3(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$4.prototype.textblockFromContext = function textblockFromContext3() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$4.prototype, prototypeAccessors$6$4);
function normalizeList$4(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$4.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$4(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$4(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$5(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$4 = function DOMSerializer3(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$4.prototype.serializeFragment = function serializeFragment3(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$4(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$4.prototype.serializeNode = function serializeNode3(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$4.renderSpec(doc$4(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$4.prototype.serializeNodeAndMarks = function serializeNodeAndMarks3(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$4.prototype.serializeMark = function serializeMark3(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$4.renderSpec(doc$4(options), toDOM4(mark15, inline3));
};
DOMSerializer$4.renderSpec = function renderSpec3(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$4.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$4.fromSchema = function fromSchema6(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$4(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$4.nodesFromSchema = function nodesFromSchema3(schema2) {
  var result2 = gatherToDOM$4(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$4.marksFromSchema = function marksFromSchema3(schema2) {
  return gatherToDOM$4(schema2.marks);
};
function gatherToDOM$4(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$4(options) {
  return options.document || window.document;
}
dist$a.Node = Node$5;
dist$a.ResolvedPos = ResolvedPos$4;
dist$a.NodeRange = NodeRange$4;
dist$a.Fragment = Fragment$4;
dist$a.Slice = Slice$4;
dist$a.ReplaceError = ReplaceError$4;
dist$a.Mark = Mark$4;
dist$a.Schema = Schema$4;
dist$a.NodeType = NodeType$6;
dist$a.MarkType = MarkType$4;
dist$a.ContentMatch = ContentMatch$4;
dist$a.DOMParser = DOMParser$4;
dist$a.DOMSerializer = DOMSerializer$4;
Object.defineProperty(schemaList, "__esModule", { value: true });
var prosemirrorTransform$5 = dist$c;
var prosemirrorModel$4 = dist$a;
var orderedList = {
  attrs: { order: { default: 1 } },
  parseDOM: [{ tag: "ol", getAttrs: function getAttrs(dom) {
    return { order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1 };
  } }],
  toDOM: function toDOM(node18) {
    return ["ol", { start: node18.attrs.order == 1 ? null : node18.attrs.order }, 0];
  }
};
var bulletList = {
  parseDOM: [{ tag: "ul" }],
  toDOM: function toDOM2() {
    return ["ul", 0];
  }
};
var listItem = {
  parseDOM: [{ tag: "li" }],
  toDOM: function toDOM3() {
    return ["li", 0];
  },
  defining: true
};
function add(obj, props) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  for (var prop$1 in props) {
    copy12[prop$1] = props[prop$1];
  }
  return copy12;
}
function addListNodes(nodes2, itemContent, listGroup) {
  return nodes2.append({
    ordered_list: add(orderedList, { content: "list_item+", group: listGroup }),
    bullet_list: add(bulletList, { content: "list_item+", group: listGroup }),
    list_item: add(listItem, { content: itemContent })
  });
}
function wrapInList(listType, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range) {
      return false;
    }
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0) {
        return false;
      }
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirrorModel$4.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) {
        range = new prosemirrorModel$4.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      }
      doJoin = true;
    }
    var wrap2 = prosemirrorTransform$5.findWrapping(outerRange, listType, attrs, range);
    if (!wrap2) {
      return false;
    }
    if (dispatch3) {
      dispatch3(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    }
    return true;
  };
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content2 = prosemirrorModel$4.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content2 = prosemirrorModel$4.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content2));
  }
  tr.step(new prosemirrorTransform$5.ReplaceAroundStep(
    range.start - (joinBefore ? 2 : 0),
    range.end,
    range.start,
    range.end,
    new prosemirrorModel$4.Slice(content2, 0, 0),
    wrappers.length,
    true
  ));
  var found2 = 0;
  for (var i$12 = 0; i$12 < wrappers.length; i$12++) {
    if (wrappers[i$12].type == listType) {
      found2 = i$12 + 1;
    }
  }
  var splitDepth = wrappers.length - found2;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {
    if (!first && prosemirrorTransform$5.canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
    }
    splitPos += parent.child(i$2).nodeSize + (first ? 0 : 2 * splitDepth);
  }
  return tr;
}
function splitListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var node18 = ref.node;
    if (node18 && node18.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) {
      return false;
    }
    if ($from.parent.content.size == 0) {
      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch3) {
        var wrap2 = prosemirrorModel$4.Fragment.empty, keepItem = $from.index(-1) > 0;
        for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) {
          wrap2 = prosemirrorModel$4.Fragment.from($from.node(d).copy(wrap2));
        }
        wrap2 = wrap2.append(prosemirrorModel$4.Fragment.from(itemType.createAndFill()));
        var tr$1 = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new prosemirrorModel$4.Slice(wrap2, keepItem ? 3 : 2, 2));
        tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));
        dispatch3(tr$1.scrollIntoView());
      }
      return true;
    }
    var nextType = $to.pos == $from.end() ? grandParent.defaultContentType(0) : null;
    var tr = state.tr.delete($from.pos, $to.pos);
    var types = nextType && [null, { type: nextType }];
    if (!prosemirrorTransform$5.canSplit(tr.doc, $from.pos, 2, types)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(tr.split($from.pos, 2, types).scrollIntoView());
    }
    return true;
  };
}
function liftListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node18) {
      return node18.childCount && node18.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    if (!dispatch3) {
      return true;
    }
    if ($from.node(range.depth - 1).type == itemType) {
      return liftToOuterList(state, dispatch3, itemType, range);
    } else {
      return liftOutOfList(state, dispatch3, range);
    }
  };
}
function liftToOuterList(state, dispatch3, itemType, range) {
  var tr = state.tr, end8 = range.end, endOfList = range.$to.end(range.depth);
  if (end8 < endOfList) {
    tr.step(new prosemirrorTransform$5.ReplaceAroundStep(
      end8 - 1,
      endOfList,
      end8,
      endOfList,
      new prosemirrorModel$4.Slice(prosemirrorModel$4.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0),
      1,
      true
    ));
    range = new prosemirrorModel$4.NodeRange(tr.doc.resolveNoCache(range.$from.pos), tr.doc.resolveNoCache(endOfList), range.depth);
  }
  dispatch3(tr.lift(range, prosemirrorTransform$5.liftTarget(range)).scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch3, range) {
  var tr = state.tr, list = range.parent;
  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  var atStart2 = range.startIndex == 0, atEnd2 = range.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(
    indexBefore + (atStart2 ? 0 : 1),
    indexBefore + 1,
    item.content.append(atEnd2 ? prosemirrorModel$4.Fragment.empty : prosemirrorModel$4.Fragment.from(list))
  )) {
    return false;
  }
  var start16 = $start.pos, end8 = start16 + item.nodeSize;
  tr.step(new prosemirrorTransform$5.ReplaceAroundStep(
    start16 - (atStart2 ? 1 : 0),
    end8 + (atEnd2 ? 1 : 0),
    start16 + 1,
    end8 - 1,
    new prosemirrorModel$4.Slice(
      (atStart2 ? prosemirrorModel$4.Fragment.empty : prosemirrorModel$4.Fragment.from(list.copy(prosemirrorModel$4.Fragment.empty))).append(atEnd2 ? prosemirrorModel$4.Fragment.empty : prosemirrorModel$4.Fragment.from(list.copy(prosemirrorModel$4.Fragment.empty))),
      atStart2 ? 0 : 1,
      atEnd2 ? 0 : 1
    ),
    atStart2 ? 0 : 1
  ));
  dispatch3(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node18) {
      return node18.childCount && node18.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    var startIndex = range.startIndex;
    if (startIndex == 0) {
      return false;
    }
    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) {
      return false;
    }
    if (dispatch3) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirrorModel$4.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice11 = new prosemirrorModel$4.Slice(
        prosemirrorModel$4.Fragment.from(itemType.create(null, prosemirrorModel$4.Fragment.from(parent.copy(inner)))),
        nestedBefore ? 3 : 1,
        0
      );
      var before8 = range.start, after8 = range.end;
      dispatch3(state.tr.step(new prosemirrorTransform$5.ReplaceAroundStep(
        before8 - (nestedBefore ? 3 : 1),
        after8,
        before8,
        after8,
        slice11,
        1,
        true
      )).scrollIntoView());
    }
    return true;
  };
}
schemaList.orderedList = orderedList;
schemaList.bulletList = bulletList;
schemaList.listItem = listItem;
var addListNodes_1 = schemaList.addListNodes = addListNodes;
var wrapInList_1 = schemaList.wrapInList = wrapInList;
var splitListItem_1 = schemaList.splitListItem = splitListItem;
var liftListItem_1 = schemaList.liftListItem = liftListItem;
var sinkListItem_1 = schemaList.sinkListItem = sinkListItem;
var keymap$3 = {};
var base$1 = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift$1 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ";",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$3 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari$1 = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko$2 = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$5 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var brokenModifierNames$1 = chrome$3 && (mac$5 || +chrome$3[1] < 57) || gecko$2 && mac$5;
for (var i$3 = 0; i$3 < 10; i$3++)
  base$1[48 + i$3] = base$1[96 + i$3] = String(i$3);
for (var i$3 = 1; i$3 <= 24; i$3++)
  base$1[i$3 + 111] = "F" + i$3;
for (var i$3 = 65; i$3 <= 90; i$3++) {
  base$1[i$3] = String.fromCharCode(i$3 + 32);
  shift$1[i$3] = String.fromCharCode(i$3);
}
for (var code$1 in base$1)
  if (!shift$1.hasOwnProperty(code$1))
    shift$1[code$1] = base$1[code$1];
function keyName$3(event) {
  var ignoreKey = brokenModifierNames$1 && (event.ctrlKey || event.altKey || event.metaKey) || safari$1 && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift$1 : base$1)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var w3cKeyname$1 = keyName$3;
keyName$3.base = base$1;
keyName$3.shift = shift$1;
Object.defineProperty(keymap$3, "__esModule", { value: true });
function _interopDefault$7(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var keyName$2 = _interopDefault$7(w3cKeyname$1);
var prosemirrorState$9 = dist$e;
var mac$4 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta2;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta2 = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac$4) {
        meta2 = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta2) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize$1(map19) {
  var copy12 = /* @__PURE__ */ Object.create(null);
  for (var prop in map19) {
    copy12[normalizeKeyName$1(prop)] = map19[prop];
  }
  return copy12;
}
function modifiers$1(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap$2(bindings) {
  return new prosemirrorState$9.Plugin({ props: { handleKeyDown: keydownHandler$1(bindings) } });
}
function keydownHandler$1(bindings) {
  var map19 = normalize$1(bindings);
  return function(view2, event) {
    var name = keyName$2(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map19[modifiers$1(name, event, !isChar)];
    if (direct && direct(view2.state, view2.dispatch, view2)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = keyName$2.base[event.keyCode]) && baseName != name) {
      var fromCode = map19[modifiers$1(baseName, event, true)];
      if (fromCode && fromCode(view2.state, view2.dispatch, view2)) {
        return true;
      }
    }
    return false;
  };
}
var keymap_2 = keymap$3.keymap = keymap$2;
keymap$3.keydownHandler = keydownHandler$1;
var history$1 = {};
var GOOD_LEAF_SIZE = 200;
var RopeSequence$1 = function RopeSequence() {
};
RopeSequence$1.prototype.append = function append4(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence$1.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence$1.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence$1.from(other).append(this);
};
RopeSequence$1.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence$1.prototype.slice = function slice5(from12, to) {
  if (from12 === void 0)
    from12 = 0;
  if (to === void 0)
    to = this.length;
  if (from12 >= to) {
    return RopeSequence$1.empty;
  }
  return this.sliceInner(Math.max(0, from12), Math.min(this.length, to));
};
RopeSequence$1.prototype.get = function get2(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence$1.prototype.forEach = function forEach8(f2, from12, to) {
  if (from12 === void 0)
    from12 = 0;
  if (to === void 0)
    to = this.length;
  if (from12 <= to) {
    this.forEachInner(f2, from12, to, 0);
  } else {
    this.forEachInvertedInner(f2, from12, to, 0);
  }
};
RopeSequence$1.prototype.map = function map7(f2, from12, to) {
  if (from12 === void 0)
    from12 = 0;
  if (to === void 0)
    to = this.length;
  var result2 = [];
  this.forEach(function(elt, i) {
    return result2.push(f2(elt, i));
  }, from12, to);
  return result2;
};
RopeSequence$1.from = function from4(values) {
  if (values instanceof RopeSequence$1) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence$1.empty;
};
var Leaf = function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: {}, depth: {} };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from12, to) {
    if (from12 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from12, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f2, from12, to, start16) {
    var this$1$1 = this;
    for (var i = from12; i < to; i++) {
      if (f2(this$1$1.values[i], start16 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from12, to, start16) {
    var this$1$1 = this;
    for (var i = from12 - 1; i >= to; i--) {
      if (f2(this$1$1.values[i], start16 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence$1);
RopeSequence$1.empty = new Leaf([]);
var Append = function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f2, from12, to, start16) {
    var leftLen = this.left.length;
    if (from12 < leftLen && this.left.forEachInner(f2, from12, Math.min(to, leftLen), start16) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f2, Math.max(from12 - leftLen, 0), Math.min(this.length, to) - leftLen, start16 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from12, to, start16) {
    var leftLen = this.left.length;
    if (from12 > leftLen && this.right.forEachInvertedInner(f2, from12 - leftLen, Math.max(to, leftLen) - leftLen, start16 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f2, Math.min(from12, leftLen), to, start16) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from12, to) {
    if (from12 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from12, to);
    }
    if (from12 >= leftLen) {
      return this.right.slice(from12 - leftLen, to - leftLen);
    }
    return this.left.slice(from12, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence$1);
var dist$9 = RopeSequence$1;
Object.defineProperty(history$1, "__esModule", { value: true });
function _interopDefault$6(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var RopeSequence2 = _interopDefault$6(dist$9);
var prosemirrorTransform$4 = dist$c;
var prosemirrorState$8 = dist$e;
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end8 = this.items.length;
  for (; ; end8--) {
    var next2 = this$1$1.items.get(end8 - 1);
    if (next2.selection) {
      --end8;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end8, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item, i) {
    if (!item.step) {
      if (!remap) {
        remap = this$1$1.remapping(end8, i + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item.map));
      var step3 = item.step.map(remap.slice(mapFrom)), map19;
      if (step3 && transform.maybeStep(step3).doc) {
        map19 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map19, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map19) {
        remap.appendMap(map19, mapFrom);
      }
    } else {
      transform.maybeStep(item.step);
    }
    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1$1.items.slice(0, end8).append(addBefore.reverse().concat(addAfter)), this$1$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i = 0; i < transform.steps.length; i++) {
    var step3 = transform.steps[i].invert(transform.docs[i]);
    var item = new Item(transform.mapping.maps[i], step3, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from12, to) {
  var maps = [], mirrors = [];
  this.items.forEach(function(item, i) {
    if (item.mirrorOffset != null) {
      var mirrorPos = i - item.mirrorOffset;
      if (mirrorPos >= from12) {
        mirrors.push(maps.length - item.mirrorOffset, maps.length);
      }
    }
    maps.push(item.map);
  }, from12, to);
  return new prosemirrorTransform$4.Mapping(maps, mirrors);
};
Branch.prototype.addMaps = function addMaps(array) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array.map(function(map19) {
    return new Item(map19);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start16 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item) {
    if (item.selection) {
      eventCount--;
    }
  }, this.items.length - rebasedCount);
  var iRebased = rebasedCount;
  this.items.forEach(function(item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map19 = mapping.maps[pos];
    if (item.step) {
      var step3 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map19, step3, selection));
    } else {
      rebasedItems.push(new Item(map19));
    }
  }, start16);
  var newMaps = [];
  for (var i = rebasedCount; i < newUntil; i++) {
    newMaps.push(new Item(mapping.maps[i]));
  }
  var items = this.items.slice(0, start16).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item) {
    if (!item.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0)
    upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function(item, i) {
    if (i >= upto) {
      items.push(item);
      if (item.selection) {
        events++;
      }
    } else if (item.step) {
      var step3 = item.step.map(remap.slice(mapFrom)), map19 = step3 && step3.getMap();
      mapFrom--;
      if (map19) {
        remap.appendMap(map19, mapFrom);
      }
      if (step3) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) {
          events++;
        }
        var newItem = new Item(map19.invert(), step3, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem)) {
          items[last] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(RopeSequence2.from(items.reverse()), events);
};
Branch.empty = new Branch(RopeSequence2.empty, 0);
function cutOffEvents(items, n2) {
  var cutPoint;
  items.forEach(function(item, i) {
    if (item.selection && n2-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map19, step3, selection, mirrorOffset) {
  this.map = map19;
  this.step = step3;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge2(other) {
  if (this.step && other.step && !other.selection) {
    var step3 = other.step.merge(this.step);
    if (step3) {
      return new Item(step3.getMap().invert(), step3, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done3, undone, prevMap, prevTime) {
  this.done = done3;
  this.undone = undone;
  this.prevMap = prevMap;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction2(history2, state, tr, options) {
  var newState = tr.getMeta(historyKey), rebased2;
  if (newState) {
    return newState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if ((appended || tr).getMeta("addToHistory") !== false) {
    var newGroup = history2.prevTime < (tr.time || 0) - options.newGroupDelay || !appended && !isAdjacentToLastStep(tr, history2.prevMap, history2.done);
    return new HistoryState(
      history2.done.addTransform(
        tr,
        newGroup ? state.selection.getBookmark() : null,
        options,
        mustPreserveItems(state)
      ),
      Branch.empty,
      tr.mapping.maps[tr.steps.length - 1],
      tr.time
    );
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(
      history2.done.rebased(tr, rebased2),
      history2.undone.rebased(tr, rebased2),
      history2.prevMap && tr.mapping.maps[tr.steps.length - 1],
      history2.prevTime
    );
  } else {
    return new HistoryState(
      history2.done.addMaps(tr.mapping.maps),
      history2.undone.addMaps(tr.mapping.maps),
      history2.prevMap,
      history2.prevTime
    );
  }
}
function isAdjacentToLastStep(transform, prevMap, done3) {
  if (!prevMap) {
    return false;
  }
  var firstMap = transform.mapping.maps[0], adjacent = false;
  if (!firstMap) {
    return true;
  }
  firstMap.forEach(function(start16, end8) {
    done3.items.forEach(function(item) {
      if (item.step) {
        prevMap.forEach(function(_start, _end, rStart, rEnd) {
          if (start16 <= rEnd && end8 >= rStart) {
            adjacent = true;
          }
        });
        return false;
      } else {
        start16 = item.map.invert().map(start16, -1);
        end8 = item.map.invert().map(end8, 1);
      }
    }, done3.items.length, 0);
  });
  return adjacent;
}
function histTransaction(history2, state, dispatch3, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop2 = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop2) {
    return;
  }
  var selection = pop2.selection.resolve(pop2.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(
    pop2.transform,
    state.selection.getBookmark(),
    histOptions,
    preserveItems
  );
  var newHist = new HistoryState(redo2 ? added : pop2.remaining, redo2 ? pop2.remaining : added, null, 0);
  dispatch3(pop2.transform.setSelection(selection).setMeta(historyKey, newHist).scrollIntoView());
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true);
}
var historyKey = new prosemirrorState$8.PluginKey("history");
var closeHistoryKey = new prosemirrorState$8.PluginKey("closeHistory");
function history(config) {
  config = {
    depth: config && config.depth || 100,
    newGroupDelay: config && config.newGroupDelay || 500
  };
  return new prosemirrorState$8.Plugin({
    key: historyKey,
    state: {
      init: function init5() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply8(tr, hist, state) {
        return applyTransaction2(hist, state, tr, config);
      }
    },
    config
  });
}
function undo(state, dispatch3) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch3) {
    histTransaction(hist, state, dispatch3, false);
  }
  return true;
}
function redo(state, dispatch3) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch3) {
    histTransaction(hist, state, dispatch3, true);
  }
  return true;
}
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}
history$1.HistoryState = HistoryState;
history$1.closeHistory = closeHistory;
var history_2 = history$1.history = history;
var undo_1 = history$1.undo = undo;
var redo_1 = history$1.redo = redo;
history$1.undoDepth = undoDepth;
history$1.redoDepth = redoDepth;
var commands$1 = {};
var dist$8 = {};
function OrderedMap$7(content2) {
  this.content = content2;
}
OrderedMap$7.prototype = {
  constructor: OrderedMap$7,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$7(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$7(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$7([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$7(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$7(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$7.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$7(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$7.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$7(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$7.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$7.from = function(value) {
  if (value instanceof OrderedMap$7)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$7(content2);
};
var orderedmap$3 = OrderedMap$7;
Object.defineProperty(dist$8, "__esModule", { value: true });
function _interopDefault$5(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$6 = _interopDefault$5(orderedmap$3);
function findDiffStart$3(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$3(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$3(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$3(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$3 = function Fragment4(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$8 = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$3.prototype.nodesBetween = function nodesBetween7(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$3.prototype.descendants = function descendants7(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$3.prototype.textBetween = function textBetween7(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$3.prototype.append = function append5(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$3(content2, this.size + other.size);
};
Fragment$3.prototype.cut = function cut7(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$3(result2, size);
};
Fragment$3.prototype.cutByIndex = function cutByIndex4(from12, to) {
  if (from12 == to) {
    return Fragment$3.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$3(this.content.slice(from12, to));
};
Fragment$3.prototype.replaceChild = function replaceChild4(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$3(copy12, size);
};
Fragment$3.prototype.addToStart = function addToStart4(node18) {
  return new Fragment$3([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$3.prototype.addToEnd = function addToEnd4(node18) {
  return new Fragment$3(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$3.prototype.eq = function eq13(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$8.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$8.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$8.childCount.get = function() {
  return this.content.length;
};
Fragment$3.prototype.child = function child7(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$3.prototype.maybeChild = function maybeChild7(index8) {
  return this.content[index8];
};
Fragment$3.prototype.forEach = function forEach9(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$3.prototype.findDiffStart = function findDiffStart$14(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$3(this, other, pos);
};
Fragment$3.prototype.findDiffEnd = function findDiffEnd$14(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$3(this, other, pos, otherPos);
};
Fragment$3.prototype.findIndex = function findIndex4(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$3(0, pos);
  }
  if (pos == this.size) {
    return retIndex$3(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$3(i + 1, end8);
      }
      return retIndex$3(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$3.prototype.toString = function toString17() {
  return "<" + this.toStringInner() + ">";
};
Fragment$3.prototype.toStringInner = function toStringInner4() {
  return this.content.join(", ");
};
Fragment$3.prototype.toJSON = function toJSON15() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$3.fromJSON = function fromJSON16(schema2, value) {
  if (!value) {
    return Fragment$3.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$3(value.map(schema2.nodeFromJSON));
};
Fragment$3.fromArray = function fromArray4(array) {
  if (!array.length) {
    return Fragment$3.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$3(joined || array, size);
};
Fragment$3.from = function from5(nodes2) {
  if (!nodes2) {
    return Fragment$3.empty;
  }
  if (nodes2 instanceof Fragment$3) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$3([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$3.prototype, prototypeAccessors$1$8);
var found$3 = { index: 0, offset: 0 };
function retIndex$3(index8, offset2) {
  found$3.index = index8;
  found$3.offset = offset2;
  return found$3;
}
Fragment$3.empty = new Fragment$3([], 0);
function compareDeep$3(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$3(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$3(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$3 = function Mark4(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$3.prototype.addToSet = function addToSet4(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$3.prototype.removeFromSet = function removeFromSet7(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$3.prototype.isInSet = function isInSet7(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$3.prototype.eq = function eq14(other) {
  return this == other || this.type == other.type && compareDeep$3(this.attrs, other.attrs);
};
Mark$3.prototype.toJSON = function toJSON16() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$3.fromJSON = function fromJSON17(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$3.sameSet = function sameSet4(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$3.setFrom = function setFrom4(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$3.none;
  }
  if (marks9 instanceof Mark$3) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$3.none = [];
function ReplaceError$3(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$3.prototype;
  return err8;
}
ReplaceError$3.prototype = Object.create(Error.prototype);
ReplaceError$3.prototype.constructor = ReplaceError$3;
ReplaceError$3.prototype.name = "ReplaceError";
var Slice$3 = function Slice4(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$5 = { size: {} };
prototypeAccessors$2$5.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$3.prototype.insertAt = function insertAt4(pos, fragment) {
  var content2 = insertInto$3(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$3(content2, this.openStart, this.openEnd);
};
Slice$3.prototype.removeBetween = function removeBetween4(from12, to) {
  return new Slice$3(removeRange$3(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$3.prototype.eq = function eq15(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$3.prototype.toString = function toString18() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$3.prototype.toJSON = function toJSON17() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$3.fromJSON = function fromJSON18(schema2, json) {
  if (!json) {
    return Slice$3.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$3(Fragment$3.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$3.maxOpen = function maxOpen4(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$3(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$3.prototype, prototypeAccessors$2$5);
function removeRange$3(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$3(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$3(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$3(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$3.empty = new Slice$3(Fragment$3.empty, 0, 0);
function replace$4($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$3("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$3("Inconsistent open depths");
  }
  return replaceOuter$3($from, $to, slice11, 0);
}
function replaceOuter$3($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$3($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$3(node18, replaceTwoWay$3($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$3(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$3(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$3(node18, replaceThreeWay$3($from, start16, end8, $to, depth));
  }
}
function checkJoin$3(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$3("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$3($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$3(node18, $after.node(depth));
  return node18;
}
function addNode$3(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$3($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$3($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$3(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$3($end.nodeBefore, target);
  }
}
function close$3(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$3("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$3($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$3($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$3($end, $to, depth + 1);
  var content2 = [];
  addRange$3(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$3(openStart, openEnd);
    addNode$3(close$3(openStart, replaceThreeWay$3($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$3(close$3(openStart, replaceTwoWay$3($from, $start, depth + 1)), content2);
    }
    addRange$3($start, $end, depth, content2);
    if (openEnd) {
      addNode$3(close$3(openEnd, replaceTwoWay$3($end, $to, depth + 1)), content2);
    }
  }
  addRange$3($to, null, depth, content2);
  return new Fragment$3(content2);
}
function replaceTwoWay$3($from, $to, depth) {
  var content2 = [];
  addRange$3(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$3($from, $to, depth + 1);
    addNode$3(close$3(type, replaceTwoWay$3($from, $to, depth + 1)), content2);
  }
  addRange$3($to, null, depth, content2);
  return new Fragment$3(content2);
}
function prepareSliceForReplace$3(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$3.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$3 = function ResolvedPos4(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$3 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$3.prototype.resolveDepth = function resolveDepth4(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$3.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$3.doc.get = function() {
  return this.node(0);
};
ResolvedPos$3.prototype.node = function node7(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$3.prototype.index = function index4(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$3.prototype.indexAfter = function indexAfter4(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$3.prototype.start = function start4(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$3.prototype.end = function end4(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$3.prototype.before = function before4(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$3.prototype.after = function after4(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$3.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$3.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$3.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$3.prototype.marks = function marks5() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$3.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$3.prototype.marksAcross = function marksAcross4($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$3.prototype.sharedDepth = function sharedDepth4(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$3.prototype.blockRange = function blockRange4(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$3(this$1$1, other, d);
    }
  }
};
ResolvedPos$3.prototype.sameParent = function sameParent4(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$3.prototype.max = function max4(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$3.prototype.min = function min4(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$3.prototype.toString = function toString19() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$3.resolve = function resolve10(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$3(pos, path, parentOffset);
};
ResolvedPos$3.resolveCached = function resolveCached4(doc2, pos) {
  for (var i = 0; i < resolveCache$3.length; i++) {
    var cached = resolveCache$3[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$3[resolveCachePos$3] = ResolvedPos$3.resolve(doc2, pos);
  resolveCachePos$3 = (resolveCachePos$3 + 1) % resolveCacheSize$3;
  return result2;
};
Object.defineProperties(ResolvedPos$3.prototype, prototypeAccessors$3$3);
var resolveCache$3 = [];
var resolveCachePos$3 = 0;
var resolveCacheSize$3 = 12;
var NodeRange$3 = function NodeRange4($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$3 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$3.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$3.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$3.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$3.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$3.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$3.prototype, prototypeAccessors$1$1$3);
var emptyAttrs$3 = /* @__PURE__ */ Object.create(null);
var Node$4 = function Node5(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$3.empty;
  this.marks = marks9 || Mark$3.none;
};
var prototypeAccessors$b = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$b.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$b.childCount.get = function() {
  return this.content.childCount;
};
Node$4.prototype.child = function child8(index8) {
  return this.content.child(index8);
};
Node$4.prototype.maybeChild = function maybeChild8(index8) {
  return this.content.maybeChild(index8);
};
Node$4.prototype.forEach = function forEach10(f2) {
  this.content.forEach(f2);
};
Node$4.prototype.nodesBetween = function nodesBetween8(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$4.prototype.descendants = function descendants8(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$b.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$4.prototype.textBetween = function textBetween8(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$b.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$b.lastChild.get = function() {
  return this.content.lastChild;
};
Node$4.prototype.eq = function eq16(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$4.prototype.sameMarkup = function sameMarkup4(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$4.prototype.hasMarkup = function hasMarkup4(type, attrs, marks9) {
  return this.type == type && compareDeep$3(this.attrs, attrs || type.defaultAttrs || emptyAttrs$3) && Mark$3.sameSet(this.marks, marks9 || Mark$3.none);
};
Node$4.prototype.copy = function copy5(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$4.prototype.mark = function mark7(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$4.prototype.cut = function cut8(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$4.prototype.slice = function slice6(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$3.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$3(content2, $from.depth - depth, $to.depth - depth);
};
Node$4.prototype.replace = function replace$14(from12, to, slice11) {
  return replace$4(this.resolve(from12), this.resolve(to), slice11);
};
Node$4.prototype.nodeAt = function nodeAt4(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$4.prototype.childAfter = function childAfter4(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$4.prototype.childBefore = function childBefore4(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$4.prototype.resolve = function resolve11(pos) {
  return ResolvedPos$3.resolveCached(this, pos);
};
Node$4.prototype.resolveNoCache = function resolveNoCache4(pos) {
  return ResolvedPos$3.resolve(this, pos);
};
Node$4.prototype.rangeHasMark = function rangeHasMark4(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$b.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$b.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$b.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$b.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$b.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$b.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$b.isAtom.get = function() {
  return this.type.isAtom;
};
Node$4.prototype.toString = function toString20() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$3(this.marks, name);
};
Node$4.prototype.contentMatchAt = function contentMatchAt4(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$4.prototype.canReplace = function canReplace4(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$3.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$4.prototype.canReplaceWith = function canReplaceWith4(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$4.prototype.canAppend = function canAppend4(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$4.prototype.defaultContentType = function defaultContentType4(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$4.prototype.check = function check4() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$4.prototype.toJSON = function toJSON18() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$4.fromJSON = function fromJSON19(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$3.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$4.prototype, prototypeAccessors$b);
var TextNode$3 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$3(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$4);
function wrapMarks$3(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$3 = function ContentMatch4(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$3 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$3.parse = function parse7(string, nodeTypes) {
  var stream = new TokenStream$3(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$3.empty;
  }
  var expr = parseExpr$3(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$3(nfa$3(expr));
  checkForDeadEnds$3(match2, stream);
  return match2;
};
ContentMatch$3.prototype.matchType = function matchType4(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$3.prototype.matchFragment = function matchFragment4(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$3.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$3.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$3.prototype.compatible = function compatible4(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$3.prototype.fillBefore = function fillBefore4(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$3.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$3.prototype.findWrapping = function findWrapping8(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$3.prototype.computeWrapping = function computeWrapping4(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$3.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$3.prototype.edge = function edge4(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$3.prototype.toString = function toString21() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$3.prototype, prototypeAccessors$5$3);
ContentMatch$3.empty = new ContentMatch$3(true);
var TokenStream$3 = function TokenStream4(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$3 = { next: {} };
prototypeAccessors$1$3$3.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$3.prototype.eat = function eat4(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$3.prototype.err = function err4(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$3.prototype, prototypeAccessors$1$3$3);
function parseExpr$3(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$3(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$3(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$3(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$3(stream) {
  var expr = parseExprAtom$3(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$3(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$3(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$3(stream, expr) {
  var min9 = parseNum$3(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$3(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$3(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$3(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$3(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$3(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$3(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$3(a, b) {
  return a - b;
}
function nullFrom$3(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$3);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$3(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$3(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$3(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$3(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$3);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$3(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$3(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$3(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$3(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$3(attrs[name]);
    }
  }
  return result2;
}
var NodeType$5 = function NodeType4(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$3(spec.attrs);
  this.defaultAttrs = defaultAttrs$3(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$3 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$3.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$3.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$3.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$3.empty;
};
prototypeAccessors$4$3.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$5.prototype.hasRequiredAttrs = function hasRequiredAttrs4(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$5.prototype.compatibleContent = function compatibleContent4(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$5.prototype.computeAttrs = function computeAttrs$14(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$3(this.attrs, attrs);
  }
};
NodeType$5.prototype.create = function create8(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$4(this, this.computeAttrs(attrs), Fragment$3.from(content2), Mark$3.setFrom(marks9));
};
NodeType$5.prototype.createChecked = function createChecked4(attrs, content2, marks9) {
  content2 = Fragment$3.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$4(this, this.computeAttrs(attrs), content2, Mark$3.setFrom(marks9));
};
NodeType$5.prototype.createAndFill = function createAndFill4(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$3.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$3.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$4(this, attrs, content2.append(after8), Mark$3.setFrom(marks9));
};
NodeType$5.prototype.validContent = function validContent4(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$5.prototype.allowsMarkType = function allowsMarkType4(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$5.prototype.allowsMarks = function allowsMarks4(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$5.prototype.allowedMarks = function allowedMarks4(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$3.empty;
};
NodeType$5.compile = function compile7(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$5(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$5.prototype, prototypeAccessors$4$3);
var Attribute$3 = function Attribute4(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$3 = { isRequired: {} };
prototypeAccessors$1$2$3.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$3.prototype, prototypeAccessors$1$2$3);
var MarkType$3 = function MarkType4(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$3(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$3(this.attrs);
  this.instance = defaults && new Mark$3(this, defaults);
};
MarkType$3.prototype.create = function create9(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$3(this, computeAttrs$3(this.attrs, attrs));
};
MarkType$3.compile = function compile8(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$3(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$3.prototype.removeFromSet = function removeFromSet8(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$3.prototype.isInSet = function isInSet8(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$3.prototype.excludes = function excludes4(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$3 = function Schema4(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$6.from(spec.nodes);
  this.spec.marks = OrderedMap$6.from(spec.marks);
  this.nodes = NodeType$5.compile(this.spec.nodes, this);
  this.marks = MarkType$3.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$3.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$3(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$3(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$3.prototype.node = function node8(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$5)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$3.prototype.text = function text4(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$3(type, type.defaultAttrs, text$1, Mark$3.setFrom(marks9));
};
Schema$3.prototype.mark = function mark8(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$3.prototype.nodeFromJSON = function nodeFromJSON4(json) {
  return Node$4.fromJSON(this, json);
};
Schema$3.prototype.markFromJSON = function markFromJSON4(json) {
  return Mark$3.fromJSON(this, json);
};
Schema$3.prototype.nodeType = function nodeType4(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$3(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$3 = function DOMParser4(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$3.prototype.parse = function parse8(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$3(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$3.prototype.parseSlice = function parseSlice4(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$3(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$3.maxOpen(context.finish());
};
DOMParser$3.prototype.matchTag = function matchTag4(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$3(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$3.prototype.matchStyle = function matchStyle4(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$3.schemaRules = function schemaRules4(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$4(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$4(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$3.fromSchema = function fromSchema7(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$3(schema2, DOMParser$3.schemaRules(schema2)));
};
var blockTags$3 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$3 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$3 = { ol: true, ul: true };
var OPT_PRESERVE_WS$3 = 1;
var OPT_PRESERVE_WS_FULL$3 = 2;
var OPT_OPEN_LEFT$3 = 4;
function wsOptionsFor$3(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$3 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$3 : 0);
}
var NodeContext$3 = function NodeContext4(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$3 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$3.none;
};
NodeContext$3.prototype.findWrapping = function findWrapping9(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$3.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$3.prototype.finish = function finish7(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$3)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$3.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$3.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$3 = function ParseContext4(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$3(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$3 : 0);
  if (topNode) {
    topContext = new NodeContext$3(
      topNode.type,
      topNode.attrs,
      Mark$3.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$3(null, null, Mark$3.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$3(parser.schema.topNodeType, null, Mark$3.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$3 = { top: {}, currentPos: {} };
prototypeAccessors$6$3.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$3.prototype.addDOM = function addDOM4(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$3(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$3.prototype.addTextNode = function addTextNode4(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$3)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$3)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$3.prototype.addElement = function addElement4(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$3.hasOwnProperty(name)) {
    normalizeList$3(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$3.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$3.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$3.prototype.readStyles = function readStyles4(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$3.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$3.prototype.addElementByRule = function addElementByRule4(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$3.prototype.addAll = function addAll4(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$3.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$3.prototype.findPlace = function findPlace4(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$3.prototype.insertNode = function insertNode4(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$3.prototype.applyPendingMarks = function applyPendingMarks4(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$3.prototype.enter = function enter4(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$3.prototype.enterInner = function enterInner4(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$3 : wsOptionsFor$3(preserveWS);
  if (top.options & OPT_OPEN_LEFT$3 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$3;
  }
  this.nodes.push(new NodeContext$3(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$3.prototype.closeExtra = function closeExtra4(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$3.prototype.finish = function finish8() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$3.prototype.sync = function sync4(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$3.prototype.addPendingMark = function addPendingMark4(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$3.prototype.removePendingMark = function removePendingMark4(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$3.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$3.prototype.findAtPoint = function findAtPoint4(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$3.prototype.findInside = function findInside4(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$3.prototype.findAround = function findAround4(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$3.prototype.findInText = function findInText4(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$3.prototype.matchesContext = function matchesContext4(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$3.prototype.textblockFromContext = function textblockFromContext4() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$3.prototype, prototypeAccessors$6$3);
function normalizeList$3(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$3.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$3(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$3(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$4(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$3 = function DOMSerializer4(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$3.prototype.serializeFragment = function serializeFragment4(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$3(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$3.prototype.serializeNode = function serializeNode4(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$3.renderSpec(doc$3(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$3.prototype.serializeNodeAndMarks = function serializeNodeAndMarks4(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$3.prototype.serializeMark = function serializeMark4(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$3.renderSpec(doc$3(options), toDOM4(mark15, inline3));
};
DOMSerializer$3.renderSpec = function renderSpec4(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$3.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$3.fromSchema = function fromSchema8(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$3(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$3.nodesFromSchema = function nodesFromSchema4(schema2) {
  var result2 = gatherToDOM$3(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$3.marksFromSchema = function marksFromSchema4(schema2) {
  return gatherToDOM$3(schema2.marks);
};
function gatherToDOM$3(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$3(options) {
  return options.document || window.document;
}
dist$8.Node = Node$4;
dist$8.ResolvedPos = ResolvedPos$3;
dist$8.NodeRange = NodeRange$3;
dist$8.Fragment = Fragment$3;
dist$8.Slice = Slice$3;
dist$8.ReplaceError = ReplaceError$3;
dist$8.Mark = Mark$3;
dist$8.Schema = Schema$3;
dist$8.NodeType = NodeType$5;
dist$8.MarkType = MarkType$3;
dist$8.ContentMatch = ContentMatch$3;
dist$8.DOMParser = DOMParser$3;
dist$8.DOMSerializer = DOMSerializer$3;
Object.defineProperty(commands$1, "__esModule", { value: true });
var prosemirrorTransform$3 = dist$c;
var prosemirrorModel$3 = dist$8;
var prosemirrorState$7 = dist$e;
function deleteSelection(state, dispatch3) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward(state, dispatch3, view2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view2 ? !view2.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && prosemirrorTransform$3.liftTarget(range);
    if (target == null) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  var before8 = $cut.nodeBefore;
  if (!before8.type.spec.isolating && deleteBarrier(state, $cut, dispatch3)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before8, "end") || prosemirrorState$7.NodeSelection.isSelectable(before8))) {
    if (dispatch3) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before8, "end") ? prosemirrorState$7.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState$7.NodeSelection.create(tr.doc, $cut.pos - before8.nodeSize));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  if (before8.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch3) {
      dispatch3(state.tr.delete($cut.pos - before8.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node18, side) {
  for (; node18; node18 = side == "start" ? node18.firstChild : node18.lastChild) {
    if (node18.isTextblock) {
      return true;
    }
  }
  return false;
}
function selectNodeBackward(state, dispatch3, view2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view2 ? !view2.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor), node18 = $cut && $cut.nodeBefore;
  if (!node18 || !prosemirrorState$7.NodeSelection.isSelectable(node18)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.setSelection(prosemirrorState$7.NodeSelection.create(state.doc, $cut.pos - node18.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0) {
        return $pos.doc.resolve($pos.before(i + 1));
      }
      if ($pos.node(i).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward(state, dispatch3, view2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view2 ? !view2.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after8 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch3)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after8, "start") || prosemirrorState$7.NodeSelection.isSelectable(after8))) {
    if (dispatch3) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after8, "start") ? prosemirrorState$7.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState$7.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  if (after8.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch3) {
      dispatch3(state.tr.delete($cut.pos, $cut.pos + after8.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward(state, dispatch3, view2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view2 ? !view2.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor), node18 = $cut && $cut.nodeAfter;
  if (!node18 || !prosemirrorState$7.NodeSelection.isSelectable(node18)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.setSelection(prosemirrorState$7.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      var parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinUp(state, dispatch3) {
  var sel = state.selection, nodeSel = sel instanceof prosemirrorState$7.NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !prosemirrorTransform$3.canJoin(state.doc, sel.from)) {
      return false;
    }
    point = sel.from;
  } else {
    point = prosemirrorTransform$3.joinPoint(state.doc, sel.from, -1);
    if (point == null) {
      return false;
    }
  }
  if (dispatch3) {
    var tr = state.tr.join(point);
    if (nodeSel) {
      tr.setSelection(prosemirrorState$7.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    }
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function joinDown(state, dispatch3) {
  var sel = state.selection, point;
  if (sel instanceof prosemirrorState$7.NodeSelection) {
    if (sel.node.isTextblock || !prosemirrorTransform$3.canJoin(state.doc, sel.to)) {
      return false;
    }
    point = sel.to;
  } else {
    point = prosemirrorTransform$3.joinPoint(state.doc, sel.to, 1);
    if (point == null) {
      return false;
    }
  }
  if (dispatch3) {
    dispatch3(state.tr.join(point).scrollIntoView());
  }
  return true;
}
function lift(state, dispatch3) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  var range = $from.blockRange($to), target = range && prosemirrorTransform$3.liftTarget(range);
  if (target == null) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.lift(range, target).scrollIntoView());
  }
  return true;
}
function newlineInCode(state, dispatch3) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function exitCode(state, dispatch3) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after8 = $head.indexAfter(-1), type = above.contentMatchAt(after8).defaultType;
  if (!above.canReplaceWith(after8, after8, type)) {
    return false;
  }
  if (dispatch3) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirrorState$7.Selection.near(tr.doc.resolve(pos), 1));
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear(state, dispatch3) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if ($from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type = $from.parent.contentMatchAt($to.indexAfter()).defaultType;
  if (!type || !type.isTextblock) {
    return false;
  }
  if (dispatch3) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirrorState$7.TextSelection.create(tr.doc, side + 1));
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock(state, dispatch3) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before8 = $cursor.before();
    if (prosemirrorTransform$3.canSplit(state.doc, before8)) {
      if (dispatch3) {
        dispatch3(state.tr.split(before8).scrollIntoView());
      }
      return true;
    }
  }
  var range = $cursor.blockRange(), target = range && prosemirrorTransform$3.liftTarget(range);
  if (target == null) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.lift(range, target).scrollIntoView());
  }
  return true;
}
function splitBlock(state, dispatch3) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof prosemirrorState$7.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !prosemirrorTransform$3.canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch3) {
    var atEnd2 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirrorState$7.TextSelection) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : $from.node(-1).contentMatchAt($from.indexAfter(-1)).defaultType;
    var types = atEnd2 && deflt ? [{ type: deflt }] : null;
    var can = prosemirrorTransform$3.canSplit(tr.doc, $from.pos, 1, types);
    if (!types && !can && prosemirrorTransform$3.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd2 && !$from.parentOffset && $from.parent.type != deflt && $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), prosemirrorModel$3.Fragment.from(deflt.create(), $from.parent))) {
        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
      }
    }
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function splitBlockKeepMarks(state, dispatch3) {
  return splitBlock(state, dispatch3 && function(tr) {
    var marks9 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks9) {
      tr.ensureMarks(marks9);
    }
    dispatch3(tr);
  });
}
function selectParentNode(state, dispatch3) {
  var ref = state.selection;
  var $from = ref.$from;
  var to = ref.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) {
    return false;
  }
  pos = $from.before(same);
  if (dispatch3) {
    dispatch3(state.tr.setSelection(prosemirrorState$7.NodeSelection.create(state.doc, pos)));
  }
  return true;
}
function selectAll(state, dispatch3) {
  if (dispatch3) {
    dispatch3(state.tr.setSelection(new prosemirrorState$7.AllSelection(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch3) {
  var before8 = $pos.nodeBefore, after8 = $pos.nodeAfter, index8 = $pos.index();
  if (!before8 || !after8 || !before8.type.compatibleContent(after8.type)) {
    return false;
  }
  if (!before8.content.size && $pos.parent.canReplace(index8 - 1, index8)) {
    if (dispatch3) {
      dispatch3(state.tr.delete($pos.pos - before8.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index8, index8 + 1) || !(after8.isTextblock || prosemirrorTransform$3.canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.clearIncompatible($pos.pos, before8.type, before8.contentMatchAt(before8.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch3) {
  var before8 = $cut.nodeBefore, after8 = $cut.nodeAfter, conn, match2;
  if (before8.type.spec.isolating || after8.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch3)) {
    return true;
  }
  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) && (conn = (match2 = before8.contentMatchAt(before8.childCount)).findWrapping(after8.type)) && match2.matchType(conn[0] || after8.type).validEnd) {
    if (dispatch3) {
      var end8 = $cut.pos + after8.nodeSize, wrap2 = prosemirrorModel$3.Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--) {
        wrap2 = prosemirrorModel$3.Fragment.from(conn[i].create(null, wrap2));
      }
      wrap2 = prosemirrorModel$3.Fragment.from(before8.copy(wrap2));
      var tr = state.tr.step(new prosemirrorTransform$3.ReplaceAroundStep($cut.pos - 1, end8, $cut.pos, end8, new prosemirrorModel$3.Slice(wrap2, 1, 0), conn.length, true));
      var joinAt = end8 + 2 * conn.length;
      if (prosemirrorTransform$3.canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = prosemirrorState$7.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && prosemirrorTransform$3.liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  return false;
}
function wrapIn(nodeType8, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && prosemirrorTransform$3.findWrapping(range, nodeType8, attrs);
    if (!wrapping) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.wrap(range, wrapping).scrollIntoView());
    }
    return true;
  };
}
function setBlockType(nodeType8, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var from12 = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from12, to, function(node18, pos) {
      if (applicable) {
        return false;
      }
      if (!node18.isTextblock || node18.hasMarkup(nodeType8, attrs)) {
        return;
      }
      if (node18.type == nodeType8) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index8 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index8, index8 + 1, nodeType8);
      }
    });
    if (!applicable) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setBlockType(from12, to, nodeType8, attrs).scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc2, ranges, type) {
  var loop = function(i2) {
    var ref = ranges[i2];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc2.type.allowsMarkType(type) : false;
    doc2.nodesBetween($from.pos, $to.pos, function(node18) {
      if (can) {
        return false;
      }
      can = node18.inlineContent && node18.type.allowsMarkType(type);
    });
    if (can) {
      return { v: true };
    }
  };
  for (var i = 0; i < ranges.length; i++) {
    var returned = loop(i);
    if (returned)
      return returned.v;
  }
  return false;
}
function toggleMark(markType, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var empty2 = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if (empty2 && !$cursor || !markApplies(state.doc, ranges, markType)) {
      return false;
    }
    if (dispatch3) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) {
          dispatch3(state.tr.removeStoredMark(markType));
        } else {
          dispatch3(state.tr.addStoredMark(markType.create(attrs)));
        }
      } else {
        var has2 = false, tr = state.tr;
        for (var i = 0; !has2 && i < ranges.length; i++) {
          var ref$1 = ranges[i];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has2 = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$12 = 0; i$12 < ranges.length; i$12++) {
          var ref$2 = ranges[i$12];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has2) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            tr.addMark($from$1.pos, $to$1.pos, markType.create(attrs));
          }
        }
        dispatch3(tr.scrollIntoView());
      }
    }
    return true;
  };
}
function wrapDispatchForJoin(dispatch3, isJoinable) {
  return function(tr) {
    if (!tr.isGeneric) {
      return dispatch3(tr);
    }
    var ranges = [];
    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map19 = tr.mapping.maps[i];
      for (var j = 0; j < ranges.length; j++) {
        ranges[j] = map19.map(ranges[j]);
      }
      map19.forEach(function(_s, _e, from13, to2) {
        return ranges.push(from13, to2);
      });
    }
    var joinable2 = [];
    for (var i$12 = 0; i$12 < ranges.length; i$12 += 2) {
      var from12 = ranges[i$12], to = ranges[i$12 + 1];
      var $from = tr.doc.resolve(from12), depth = $from.sharedDepth(to), parent = $from.node(depth);
      for (var index8 = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index8) {
        var after8 = parent.maybeChild(index8);
        if (!after8) {
          break;
        }
        if (index8 && joinable2.indexOf(pos) == -1) {
          var before8 = parent.child(index8 - 1);
          if (before8.type == after8.type && isJoinable(before8, after8)) {
            joinable2.push(pos);
          }
        }
        pos += after8.nodeSize;
      }
    }
    joinable2.sort(function(a, b) {
      return a - b;
    });
    for (var i$2 = joinable2.length - 1; i$2 >= 0; i$2--) {
      if (prosemirrorTransform$3.canJoin(tr.doc, joinable2[i$2])) {
        tr.join(joinable2[i$2]);
      }
    }
    dispatch3(tr);
  };
}
function autoJoin(command, isJoinable) {
  if (Array.isArray(isJoinable)) {
    var types = isJoinable;
    isJoinable = function(node18) {
      return types.indexOf(node18.type.name) > -1;
    };
  }
  return function(state, dispatch3) {
    return command(state, dispatch3 && wrapDispatchForJoin(dispatch3, isJoinable));
  };
}
function chainCommands() {
  var commands2 = [], len = arguments.length;
  while (len--)
    commands2[len] = arguments[len];
  return function(state, dispatch3, view2) {
    for (var i = 0; i < commands2.length; i++) {
      if (commands2[i](state, dispatch3, view2)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (var key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}
var mac$3 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
var baseKeymap = mac$3 ? macBaseKeymap : pcBaseKeymap;
commands$1.deleteSelection = deleteSelection;
commands$1.joinBackward = joinBackward;
commands$1.selectNodeBackward = selectNodeBackward;
commands$1.joinForward = joinForward;
commands$1.selectNodeForward = selectNodeForward;
var joinUp_1 = commands$1.joinUp = joinUp;
var joinDown_1 = commands$1.joinDown = joinDown;
var lift_1 = commands$1.lift = lift;
commands$1.newlineInCode = newlineInCode;
var exitCode_1 = commands$1.exitCode = exitCode;
commands$1.createParagraphNear = createParagraphNear;
commands$1.liftEmptyBlock = liftEmptyBlock;
commands$1.splitBlock = splitBlock;
commands$1.splitBlockKeepMarks = splitBlockKeepMarks;
var selectParentNode_1 = commands$1.selectParentNode = selectParentNode;
commands$1.selectAll = selectAll;
var wrapIn_1 = commands$1.wrapIn = wrapIn;
var setBlockType_1 = commands$1.setBlockType = setBlockType;
var toggleMark_1 = commands$1.toggleMark = toggleMark;
commands$1.autoJoin = autoJoin;
var chainCommands_1 = commands$1.chainCommands = chainCommands;
commands$1.pcBaseKeymap = pcBaseKeymap;
commands$1.macBaseKeymap = macBaseKeymap;
var baseKeymap_1 = commands$1.baseKeymap = baseKeymap;
var dropcursor = {};
var dist$7 = {};
var dist$6 = {};
function OrderedMap$5(content2) {
  this.content = content2;
}
OrderedMap$5.prototype = {
  constructor: OrderedMap$5,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$5(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$5(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$5([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$5(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$5(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$5.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$5(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$5.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$5(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$5.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$5.from = function(value) {
  if (value instanceof OrderedMap$5)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$5(content2);
};
var orderedmap$2 = OrderedMap$5;
Object.defineProperty(dist$6, "__esModule", { value: true });
function _interopDefault$4(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$4 = _interopDefault$4(orderedmap$2);
function findDiffStart$2(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$2(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$2(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$2(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$2 = function Fragment5(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$7 = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$2.prototype.nodesBetween = function nodesBetween9(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$2.prototype.descendants = function descendants9(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$2.prototype.textBetween = function textBetween9(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$2.prototype.append = function append6(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$2(content2, this.size + other.size);
};
Fragment$2.prototype.cut = function cut9(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$2(result2, size);
};
Fragment$2.prototype.cutByIndex = function cutByIndex5(from12, to) {
  if (from12 == to) {
    return Fragment$2.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$2(this.content.slice(from12, to));
};
Fragment$2.prototype.replaceChild = function replaceChild5(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$2(copy12, size);
};
Fragment$2.prototype.addToStart = function addToStart5(node18) {
  return new Fragment$2([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$2.prototype.addToEnd = function addToEnd5(node18) {
  return new Fragment$2(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$2.prototype.eq = function eq17(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$7.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$7.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$7.childCount.get = function() {
  return this.content.length;
};
Fragment$2.prototype.child = function child9(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$2.prototype.maybeChild = function maybeChild9(index8) {
  return this.content[index8];
};
Fragment$2.prototype.forEach = function forEach11(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$2.prototype.findDiffStart = function findDiffStart$15(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$2(this, other, pos);
};
Fragment$2.prototype.findDiffEnd = function findDiffEnd$15(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$2(this, other, pos, otherPos);
};
Fragment$2.prototype.findIndex = function findIndex5(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$2(0, pos);
  }
  if (pos == this.size) {
    return retIndex$2(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$2(i + 1, end8);
      }
      return retIndex$2(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$2.prototype.toString = function toString22() {
  return "<" + this.toStringInner() + ">";
};
Fragment$2.prototype.toStringInner = function toStringInner5() {
  return this.content.join(", ");
};
Fragment$2.prototype.toJSON = function toJSON19() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$2.fromJSON = function fromJSON20(schema2, value) {
  if (!value) {
    return Fragment$2.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$2(value.map(schema2.nodeFromJSON));
};
Fragment$2.fromArray = function fromArray5(array) {
  if (!array.length) {
    return Fragment$2.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$2(joined || array, size);
};
Fragment$2.from = function from6(nodes2) {
  if (!nodes2) {
    return Fragment$2.empty;
  }
  if (nodes2 instanceof Fragment$2) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$2([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$2.prototype, prototypeAccessors$1$7);
var found$2 = { index: 0, offset: 0 };
function retIndex$2(index8, offset2) {
  found$2.index = index8;
  found$2.offset = offset2;
  return found$2;
}
Fragment$2.empty = new Fragment$2([], 0);
function compareDeep$2(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$2(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$2(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$2 = function Mark5(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$2.prototype.addToSet = function addToSet5(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$2.prototype.removeFromSet = function removeFromSet9(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$2.prototype.isInSet = function isInSet9(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$2.prototype.eq = function eq18(other) {
  return this == other || this.type == other.type && compareDeep$2(this.attrs, other.attrs);
};
Mark$2.prototype.toJSON = function toJSON20() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$2.fromJSON = function fromJSON21(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$2.sameSet = function sameSet5(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$2.setFrom = function setFrom5(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$2.none;
  }
  if (marks9 instanceof Mark$2) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$2.none = [];
function ReplaceError$2(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$2.prototype;
  return err8;
}
ReplaceError$2.prototype = Object.create(Error.prototype);
ReplaceError$2.prototype.constructor = ReplaceError$2;
ReplaceError$2.prototype.name = "ReplaceError";
var Slice$2 = function Slice5(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$4 = { size: {} };
prototypeAccessors$2$4.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$2.prototype.insertAt = function insertAt5(pos, fragment) {
  var content2 = insertInto$2(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$2(content2, this.openStart, this.openEnd);
};
Slice$2.prototype.removeBetween = function removeBetween5(from12, to) {
  return new Slice$2(removeRange$2(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$2.prototype.eq = function eq19(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$2.prototype.toString = function toString23() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$2.prototype.toJSON = function toJSON21() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$2.fromJSON = function fromJSON22(schema2, json) {
  if (!json) {
    return Slice$2.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$2(Fragment$2.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$2.maxOpen = function maxOpen5(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$2(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$2.prototype, prototypeAccessors$2$4);
function removeRange$2(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$2(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$2(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$2(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$2.empty = new Slice$2(Fragment$2.empty, 0, 0);
function replace$3($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$2("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$2("Inconsistent open depths");
  }
  return replaceOuter$2($from, $to, slice11, 0);
}
function replaceOuter$2($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$2($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$2(node18, replaceTwoWay$2($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$2(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$2(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$2(node18, replaceThreeWay$2($from, start16, end8, $to, depth));
  }
}
function checkJoin$2(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$2("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$2($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$2(node18, $after.node(depth));
  return node18;
}
function addNode$2(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$2($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$2($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$2(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$2($end.nodeBefore, target);
  }
}
function close$2(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$2("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$2($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$2($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$2($end, $to, depth + 1);
  var content2 = [];
  addRange$2(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$2(openStart, openEnd);
    addNode$2(close$2(openStart, replaceThreeWay$2($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$2(close$2(openStart, replaceTwoWay$2($from, $start, depth + 1)), content2);
    }
    addRange$2($start, $end, depth, content2);
    if (openEnd) {
      addNode$2(close$2(openEnd, replaceTwoWay$2($end, $to, depth + 1)), content2);
    }
  }
  addRange$2($to, null, depth, content2);
  return new Fragment$2(content2);
}
function replaceTwoWay$2($from, $to, depth) {
  var content2 = [];
  addRange$2(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$2($from, $to, depth + 1);
    addNode$2(close$2(type, replaceTwoWay$2($from, $to, depth + 1)), content2);
  }
  addRange$2($to, null, depth, content2);
  return new Fragment$2(content2);
}
function prepareSliceForReplace$2(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$2.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$2 = function ResolvedPos5(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$2 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$2.prototype.resolveDepth = function resolveDepth5(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$2.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$2.doc.get = function() {
  return this.node(0);
};
ResolvedPos$2.prototype.node = function node9(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$2.prototype.index = function index5(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$2.prototype.indexAfter = function indexAfter5(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$2.prototype.start = function start5(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$2.prototype.end = function end5(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$2.prototype.before = function before5(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$2.prototype.after = function after5(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$2.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$2.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$2.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$2.prototype.marks = function marks6() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$2.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$2.prototype.marksAcross = function marksAcross5($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$2.prototype.sharedDepth = function sharedDepth5(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$2.prototype.blockRange = function blockRange5(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$2(this$1$1, other, d);
    }
  }
};
ResolvedPos$2.prototype.sameParent = function sameParent5(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$2.prototype.max = function max5(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$2.prototype.min = function min5(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$2.prototype.toString = function toString24() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$2.resolve = function resolve12(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$2(pos, path, parentOffset);
};
ResolvedPos$2.resolveCached = function resolveCached5(doc2, pos) {
  for (var i = 0; i < resolveCache$2.length; i++) {
    var cached = resolveCache$2[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$2[resolveCachePos$2] = ResolvedPos$2.resolve(doc2, pos);
  resolveCachePos$2 = (resolveCachePos$2 + 1) % resolveCacheSize$2;
  return result2;
};
Object.defineProperties(ResolvedPos$2.prototype, prototypeAccessors$3$2);
var resolveCache$2 = [];
var resolveCachePos$2 = 0;
var resolveCacheSize$2 = 12;
var NodeRange$2 = function NodeRange5($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$2 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$2.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$2.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$2.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$2.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$2.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$2.prototype, prototypeAccessors$1$1$2);
var emptyAttrs$2 = /* @__PURE__ */ Object.create(null);
var Node$3 = function Node6(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$2.empty;
  this.marks = marks9 || Mark$2.none;
};
var prototypeAccessors$a = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$a.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$a.childCount.get = function() {
  return this.content.childCount;
};
Node$3.prototype.child = function child10(index8) {
  return this.content.child(index8);
};
Node$3.prototype.maybeChild = function maybeChild10(index8) {
  return this.content.maybeChild(index8);
};
Node$3.prototype.forEach = function forEach12(f2) {
  this.content.forEach(f2);
};
Node$3.prototype.nodesBetween = function nodesBetween10(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$3.prototype.descendants = function descendants10(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$a.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$3.prototype.textBetween = function textBetween10(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$a.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$a.lastChild.get = function() {
  return this.content.lastChild;
};
Node$3.prototype.eq = function eq20(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$3.prototype.sameMarkup = function sameMarkup5(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$3.prototype.hasMarkup = function hasMarkup5(type, attrs, marks9) {
  return this.type == type && compareDeep$2(this.attrs, attrs || type.defaultAttrs || emptyAttrs$2) && Mark$2.sameSet(this.marks, marks9 || Mark$2.none);
};
Node$3.prototype.copy = function copy6(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$3.prototype.mark = function mark9(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$3.prototype.cut = function cut10(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$3.prototype.slice = function slice7(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$2.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$2(content2, $from.depth - depth, $to.depth - depth);
};
Node$3.prototype.replace = function replace$15(from12, to, slice11) {
  return replace$3(this.resolve(from12), this.resolve(to), slice11);
};
Node$3.prototype.nodeAt = function nodeAt5(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$3.prototype.childAfter = function childAfter5(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$3.prototype.childBefore = function childBefore5(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$3.prototype.resolve = function resolve13(pos) {
  return ResolvedPos$2.resolveCached(this, pos);
};
Node$3.prototype.resolveNoCache = function resolveNoCache5(pos) {
  return ResolvedPos$2.resolve(this, pos);
};
Node$3.prototype.rangeHasMark = function rangeHasMark5(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$a.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$a.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$a.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$a.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$a.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$a.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$a.isAtom.get = function() {
  return this.type.isAtom;
};
Node$3.prototype.toString = function toString25() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$2(this.marks, name);
};
Node$3.prototype.contentMatchAt = function contentMatchAt5(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$3.prototype.canReplace = function canReplace5(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$2.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$3.prototype.canReplaceWith = function canReplaceWith5(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$3.prototype.canAppend = function canAppend5(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$3.prototype.defaultContentType = function defaultContentType5(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$3.prototype.check = function check5() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$3.prototype.toJSON = function toJSON22() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$3.fromJSON = function fromJSON23(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$2.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$3.prototype, prototypeAccessors$a);
var TextNode$2 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$2(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$3);
function wrapMarks$2(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$2 = function ContentMatch5(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$2 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$2.parse = function parse9(string, nodeTypes) {
  var stream = new TokenStream$2(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$2.empty;
  }
  var expr = parseExpr$2(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$2(nfa$2(expr));
  checkForDeadEnds$2(match2, stream);
  return match2;
};
ContentMatch$2.prototype.matchType = function matchType5(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$2.prototype.matchFragment = function matchFragment5(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$2.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$2.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$2.prototype.compatible = function compatible5(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$2.prototype.fillBefore = function fillBefore5(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$2.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$2.prototype.findWrapping = function findWrapping10(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$2.prototype.computeWrapping = function computeWrapping5(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$2.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$2.prototype.edge = function edge5(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$2.prototype.toString = function toString26() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$2.prototype, prototypeAccessors$5$2);
ContentMatch$2.empty = new ContentMatch$2(true);
var TokenStream$2 = function TokenStream5(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$2 = { next: {} };
prototypeAccessors$1$3$2.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$2.prototype.eat = function eat5(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$2.prototype.err = function err5(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$2.prototype, prototypeAccessors$1$3$2);
function parseExpr$2(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$2(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$2(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$2(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$2(stream) {
  var expr = parseExprAtom$2(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$2(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$2(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$2(stream, expr) {
  var min9 = parseNum$2(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$2(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$2(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$2(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$2(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$2(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$2(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$2(a, b) {
  return a - b;
}
function nullFrom$2(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$2);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$2(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$2(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$2(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$2(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$2);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$2(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$2(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$2(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$2(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$2(attrs[name]);
    }
  }
  return result2;
}
var NodeType$4 = function NodeType5(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$2(spec.attrs);
  this.defaultAttrs = defaultAttrs$2(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$2 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$2.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$2.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$2.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$2.empty;
};
prototypeAccessors$4$2.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$4.prototype.hasRequiredAttrs = function hasRequiredAttrs5(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$4.prototype.compatibleContent = function compatibleContent5(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$4.prototype.computeAttrs = function computeAttrs$15(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$2(this.attrs, attrs);
  }
};
NodeType$4.prototype.create = function create10(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$3(this, this.computeAttrs(attrs), Fragment$2.from(content2), Mark$2.setFrom(marks9));
};
NodeType$4.prototype.createChecked = function createChecked5(attrs, content2, marks9) {
  content2 = Fragment$2.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$3(this, this.computeAttrs(attrs), content2, Mark$2.setFrom(marks9));
};
NodeType$4.prototype.createAndFill = function createAndFill5(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$2.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$2.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$3(this, attrs, content2.append(after8), Mark$2.setFrom(marks9));
};
NodeType$4.prototype.validContent = function validContent5(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$4.prototype.allowsMarkType = function allowsMarkType5(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$4.prototype.allowsMarks = function allowsMarks5(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$4.prototype.allowedMarks = function allowedMarks5(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$2.empty;
};
NodeType$4.compile = function compile9(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$4(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$4.prototype, prototypeAccessors$4$2);
var Attribute$2 = function Attribute5(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$2 = { isRequired: {} };
prototypeAccessors$1$2$2.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$2.prototype, prototypeAccessors$1$2$2);
var MarkType$2 = function MarkType5(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$2(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$2(this.attrs);
  this.instance = defaults && new Mark$2(this, defaults);
};
MarkType$2.prototype.create = function create11(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$2(this, computeAttrs$2(this.attrs, attrs));
};
MarkType$2.compile = function compile10(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$2(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$2.prototype.removeFromSet = function removeFromSet10(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$2.prototype.isInSet = function isInSet10(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$2.prototype.excludes = function excludes5(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$2 = function Schema5(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$4.from(spec.nodes);
  this.spec.marks = OrderedMap$4.from(spec.marks);
  this.nodes = NodeType$4.compile(this.spec.nodes, this);
  this.marks = MarkType$2.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$2.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$2(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$2(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$2.prototype.node = function node10(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$4)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$2.prototype.text = function text5(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$2(type, type.defaultAttrs, text$1, Mark$2.setFrom(marks9));
};
Schema$2.prototype.mark = function mark10(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$2.prototype.nodeFromJSON = function nodeFromJSON5(json) {
  return Node$3.fromJSON(this, json);
};
Schema$2.prototype.markFromJSON = function markFromJSON5(json) {
  return Mark$2.fromJSON(this, json);
};
Schema$2.prototype.nodeType = function nodeType5(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$2(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$2 = function DOMParser5(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$2.prototype.parse = function parse10(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$2(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$2.prototype.parseSlice = function parseSlice5(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$2(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$2.maxOpen(context.finish());
};
DOMParser$2.prototype.matchTag = function matchTag5(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$2(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$2.prototype.matchStyle = function matchStyle5(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$2.schemaRules = function schemaRules5(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$3(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$3(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$2.fromSchema = function fromSchema9(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$2(schema2, DOMParser$2.schemaRules(schema2)));
};
var blockTags$2 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$2 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$2 = { ol: true, ul: true };
var OPT_PRESERVE_WS$2 = 1;
var OPT_PRESERVE_WS_FULL$2 = 2;
var OPT_OPEN_LEFT$2 = 4;
function wsOptionsFor$2(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$2 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$2 : 0);
}
var NodeContext$2 = function NodeContext5(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$2 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$2.none;
};
NodeContext$2.prototype.findWrapping = function findWrapping11(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$2.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$2.prototype.finish = function finish9(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$2)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$2.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$2.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$2 = function ParseContext5(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$2(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$2 : 0);
  if (topNode) {
    topContext = new NodeContext$2(
      topNode.type,
      topNode.attrs,
      Mark$2.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$2(null, null, Mark$2.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$2(parser.schema.topNodeType, null, Mark$2.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$2 = { top: {}, currentPos: {} };
prototypeAccessors$6$2.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$2.prototype.addDOM = function addDOM5(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$2(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$2.prototype.addTextNode = function addTextNode5(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$2)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$2)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$2.prototype.addElement = function addElement5(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$2.hasOwnProperty(name)) {
    normalizeList$2(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$2.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$2.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$2.prototype.readStyles = function readStyles5(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$2.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$2.prototype.addElementByRule = function addElementByRule5(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$2.prototype.addAll = function addAll5(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$2.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$2.prototype.findPlace = function findPlace5(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$2.prototype.insertNode = function insertNode5(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$2.prototype.applyPendingMarks = function applyPendingMarks5(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$2.prototype.enter = function enter5(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$2.prototype.enterInner = function enterInner5(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$2 : wsOptionsFor$2(preserveWS);
  if (top.options & OPT_OPEN_LEFT$2 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$2;
  }
  this.nodes.push(new NodeContext$2(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$2.prototype.closeExtra = function closeExtra5(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$2.prototype.finish = function finish10() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$2.prototype.sync = function sync5(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$2.prototype.addPendingMark = function addPendingMark5(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$2.prototype.removePendingMark = function removePendingMark5(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$2.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$2.prototype.findAtPoint = function findAtPoint5(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$2.prototype.findInside = function findInside5(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$2.prototype.findAround = function findAround5(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$2.prototype.findInText = function findInText5(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$2.prototype.matchesContext = function matchesContext5(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$2.prototype.textblockFromContext = function textblockFromContext5() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$2.prototype, prototypeAccessors$6$2);
function normalizeList$2(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$2.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$2(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$2(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$3(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$2 = function DOMSerializer5(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$2.prototype.serializeFragment = function serializeFragment5(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$2(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$2.prototype.serializeNode = function serializeNode5(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$2.renderSpec(doc$2(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$2.prototype.serializeNodeAndMarks = function serializeNodeAndMarks5(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$2.prototype.serializeMark = function serializeMark5(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$2.renderSpec(doc$2(options), toDOM4(mark15, inline3));
};
DOMSerializer$2.renderSpec = function renderSpec5(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$2.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$2.fromSchema = function fromSchema10(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$2(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$2.nodesFromSchema = function nodesFromSchema5(schema2) {
  var result2 = gatherToDOM$2(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$2.marksFromSchema = function marksFromSchema5(schema2) {
  return gatherToDOM$2(schema2.marks);
};
function gatherToDOM$2(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$2(options) {
  return options.document || window.document;
}
dist$6.Node = Node$3;
dist$6.ResolvedPos = ResolvedPos$2;
dist$6.NodeRange = NodeRange$2;
dist$6.Fragment = Fragment$2;
dist$6.Slice = Slice$2;
dist$6.ReplaceError = ReplaceError$2;
dist$6.Mark = Mark$2;
dist$6.Schema = Schema$2;
dist$6.NodeType = NodeType$4;
dist$6.MarkType = MarkType$2;
dist$6.ContentMatch = ContentMatch$2;
dist$6.DOMParser = DOMParser$2;
dist$6.DOMSerializer = DOMSerializer$2;
Object.defineProperty(dist$7, "__esModule", { value: true });
var prosemirrorModel$2 = dist$6;
var prosemirrorState$6 = dist$e;
var prosemirrorTransform$2 = dist$c;
var result$1 = {};
if (typeof navigator != "undefined") {
  var ie_edge$1 = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10$1 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up$1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  result$1.mac = /Mac/.test(navigator.platform);
  var ie$2 = result$1.ie = !!(ie_upto10$1 || ie_11up$1 || ie_edge$1);
  result$1.ie_version = ie_upto10$1 ? document.documentMode || 6 : ie_11up$1 ? +ie_11up$1[1] : ie_edge$1 ? +ie_edge$1[1] : null;
  result$1.gecko = !ie$2 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result$1.gecko_version = result$1.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome$2 = !ie$2 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result$1.chrome = !!chrome$2;
  result$1.chrome_version = chrome$2 && +chrome$2[1];
  result$1.ios = !ie$2 && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  result$1.webkit = !ie$2 && "WebkitAppearance" in document.documentElement.style;
  result$1.safari = /Apple Computer/.test(navigator.vendor);
}
var domIndex$1 = function(node18) {
  for (var index8 = 0; ; index8++) {
    node18 = node18.previousSibling;
    if (!node18) {
      return index8;
    }
  }
};
var parentNode$1 = function(node18) {
  var parent = node18.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var textRange$1 = function(node18, from12, to) {
  var range = document.createRange();
  range.setEnd(node18, to == null ? node18.nodeValue.length : to);
  range.setStart(node18, from12 || 0);
  return range;
};
var isEquivalentPosition$1 = function(node18, off, targetNode, targetOff) {
  return targetNode && (scanFor$1(node18, off, targetNode, targetOff, -1) || scanFor$1(node18, off, targetNode, targetOff, 1));
};
var atomElements$1 = /^(img|br|input|textarea|hr)$/i;
function scanFor$1(node18, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node18 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize$1(node18)) || node18.nodeType == 3 && node18.nodeValue == "\uFEFF") {
      var parent = node18.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc$1(node18) || atomElements$1.test(node18.nodeName)) {
        return false;
      }
      off = domIndex$1(node18) + (dir < 0 ? 0 : 1);
      node18 = parent;
    } else if (node18.nodeType == 1) {
      node18 = node18.childNodes[off + (dir < 0 ? -1 : 0)];
      off = dir < 0 ? nodeSize$1(node18) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize$1(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function hasBlockDesc$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
var selectionCollapsed$1 = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result$1.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function windowRect$1(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView$1(view2, rect) {
  var scrollThreshold = view2.someProp("scrollThreshold") || 0, scrollMargin = view2.someProp("scrollMargin");
  var doc2 = view2.dom.ownerDocument, win = doc2.defaultView;
  if (scrollMargin == null) {
    scrollMargin = 5;
  }
  for (var parent = view2.dom; ; parent = parentNode$1(parent)) {
    if (!parent) {
      break;
    }
    var atBody = parent == doc2.body;
    var bounding = atBody ? windowRect$1(win) : parent.getBoundingClientRect();
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + scrollThreshold) {
      moveY = -(bounding.top - rect.top + scrollMargin);
    } else if (rect.bottom > bounding.bottom - scrollThreshold) {
      moveY = rect.bottom - bounding.bottom + scrollMargin;
    }
    if (rect.left < bounding.left + scrollThreshold) {
      moveX = -(bounding.left - rect.left + scrollMargin);
    } else if (rect.right > bounding.right - scrollThreshold) {
      moveX = rect.right - bounding.right + scrollMargin;
    }
    if (moveX || moveY) {
      if (atBody) {
        win.scrollBy(moveX, moveY);
      } else {
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
      }
    }
    if (atBody) {
      break;
    }
  }
}
function storeScrollPos$1(view2) {
  var rect = view2.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var doc2 = view2.dom.ownerDocument;
  var refDOM, refTop;
  for (var x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    var dom = view2.root.elementFromPoint(x2, y2);
    if (dom == view2.dom || !view2.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  var stack = [];
  for (var dom$1 = view2.dom; dom$1; dom$1 = parentNode$1(dom$1)) {
    stack.push({ dom: dom$1, top: dom$1.scrollTop, left: dom$1.scrollLeft });
    if (dom$1 == doc2.body) {
      break;
    }
  }
  return { refDOM, refTop, stack };
}
function resetScrollPos$1(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  var dTop = newRefTop == 0 ? 0 : newRefTop - refTop;
  for (var i = 0; i < stack.length; i++) {
    var ref$1 = stack[i];
    var dom = ref$1.dom;
    var top = ref$1.top;
    var left = ref$1.left;
    if (dom.scrollTop != top + dTop) {
      dom.scrollTop = top + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
function findOffsetInNode$1(node18, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child15 = node18.firstChild, childIndex = 0; child15; child15 = child15.nextSibling, childIndex++) {
    var rects = void 0;
    if (child15.nodeType == 1) {
      rects = child15.getClientRects();
    } else if (child15.nodeType == 3) {
      rects = textRange$1(child15).getClientRects();
    } else {
      continue;
    }
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child15;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child15.nodeType == 1 && dx) {
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset2 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText$1(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node18, offset: offset2 };
  }
  return findOffsetInNode$1(closest, coordsClosest);
}
function findOffsetInText$1(node18, coords) {
  var len = node18.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node18, i + 1);
    range.setStart(node18, i);
    var rect = singleRect$1(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left && rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top) {
      return { node: node18, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node18, offset: 0 };
}
function targetKludge$1(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement$1(view2, elt, coords) {
  if (!view2.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    return null;
  }
  var ref = findOffsetInNode$1(elt, coords);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var bias = -1;
  if (node18.nodeType == 1 && !node18.firstChild) {
    var rect = node18.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view2.docView.posFromDOM(node18, offset2, bias);
}
function posFromCaret$1(view2, node18, offset2, coords) {
  var outside = -1;
  for (var cur = node18; ; ) {
    if (cur == view2.dom) {
      break;
    }
    var desc = view2.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view2.docView.posFromDOM(node18, offset2);
}
function posAtCoords$1(view2, coords) {
  var root2 = view2.root, node18, offset2;
  if (root2.caretPositionFromPoint) {
    var pos$1 = root2.caretPositionFromPoint(coords.left, coords.top);
    if (pos$1) {
      var assign3;
      assign3 = pos$1, node18 = assign3.offsetNode, offset2 = assign3.offset;
    }
  }
  if (!node18 && root2.caretRangeFromPoint) {
    var range = root2.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      var assign$12;
      assign$12 = range, node18 = assign$12.startContainer, offset2 = assign$12.startOffset;
    }
  }
  var elt = root2.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt) {
    return null;
  }
  elt = targetKludge$1(elt, coords);
  if (node18) {
    if (node18 == view2.dom && offset2 == node18.childNodes.length - 1 && node18.lastChild.nodeType == 1 && coords.top > node18.lastChild.getBoundingClientRect().bottom) {
      pos = view2.state.doc.content.size;
    } else if (offset2 == 0 || node18.nodeType != 1 || node18.childNodes[offset2 - 1].nodeName != "BR") {
      pos = posFromCaret$1(view2, node18, offset2, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement$1(view2, elt, coords);
    if (pos == null) {
      return null;
    }
  }
  var desc = view2.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect$1(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
function coordsAtPos$1(view2, pos) {
  var ref = view2.docView.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var side, rect;
  if (node18.nodeType == 3) {
    if (offset2 < node18.nodeValue.length) {
      rect = singleRect$1(textRange$1(node18, offset2, offset2 + 1), -1);
      side = "left";
    }
    if ((!rect || rect.left == rect.right) && offset2) {
      rect = singleRect$1(textRange$1(node18, offset2 - 1, offset2), 1);
      side = "right";
    }
  } else if (node18.firstChild) {
    if (offset2 < node18.childNodes.length) {
      var child15 = node18.childNodes[offset2];
      rect = singleRect$1(child15.nodeType == 3 ? textRange$1(child15) : child15, -1);
      side = "left";
    }
    if ((!rect || rect.top == rect.bottom) && offset2) {
      var child$1 = node18.childNodes[offset2 - 1];
      rect = singleRect$1(child$1.nodeType == 3 ? textRange$1(child$1) : child$1, 1);
      side = "right";
    }
  } else {
    rect = node18.getBoundingClientRect();
    side = "left";
  }
  var x2 = rect[side];
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function withFlushedState$1(view2, state, f2) {
  var viewState = view2.state, active = view2.root.activeElement;
  if (viewState != state || !view2.inDOMChange) {
    view2.updateState(state);
  }
  if (active != view2.dom) {
    view2.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view2.updateState(viewState);
    }
    if (active != view2.dom) {
      active.focus();
    }
  }
}
function endOfTextblockVertical$1(view2, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$anchor.min(sel.$head) : sel.$anchor.max(sel.$head);
  if (!$pos.depth) {
    return false;
  }
  return withFlushedState$1(view2, state, function() {
    var dom = view2.docView.domAfterPos($pos.before());
    var coords = coordsAtPos$1(view2, $pos.pos);
    for (var child15 = dom.firstChild; child15; child15 = child15.nextSibling) {
      var boxes = void 0;
      if (child15.nodeType == 1) {
        boxes = child15.getClientRects();
      } else if (child15.nodeType == 3) {
        boxes = textRange$1(child15, 0, child15.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL$1 = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal$1(view2, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock || !$head.depth) {
    return false;
  }
  var offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  var sel = getSelection();
  if (!maybeRTL$1.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState$1(view2, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    sel.modify("move", dir, "character");
    var parentDOM = view2.docView.domAfterPos($head.before());
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    return result2;
  });
}
var cachedState$1 = null;
var cachedDir$1 = null;
var cachedResult$1 = false;
function endOfTextblock$1(view2, state, dir) {
  if (cachedState$1 == state && cachedDir$1 == dir) {
    return cachedResult$1;
  }
  cachedState$1 = state;
  cachedDir$1 = dir;
  return cachedResult$1 = dir == "up" || dir == "down" ? endOfTextblockVertical$1(view2, state, dir) : endOfTextblockHorizontal$1(view2, state, dir);
}
var NOT_DIRTY$1 = 0;
var CHILD_DIRTY$1 = 1;
var CONTENT_DIRTY$1 = 2;
var NODE_DIRTY$1 = 3;
var ViewDesc$1 = function ViewDesc(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY$1;
};
var prototypeAccessors$1$6 = { beforePosition: {}, size: {}, border: {}, posBefore: {}, posAtStart: {}, posAfter: {}, posAtEnd: {}, contentLost: {} };
ViewDesc$1.prototype.matchesWidget = function matchesWidget() {
  return false;
};
ViewDesc$1.prototype.matchesMark = function matchesMark() {
  return false;
};
ViewDesc$1.prototype.matchesNode = function matchesNode() {
  return false;
};
ViewDesc$1.prototype.matchesHack = function matchesHack() {
  return false;
};
prototypeAccessors$1$6.beforePosition.get = function() {
  return false;
};
ViewDesc$1.prototype.parseRule = function parseRule() {
  return null;
};
ViewDesc$1.prototype.stopEvent = function stopEvent() {
  return false;
};
prototypeAccessors$1$6.size.get = function() {
  var this$1$1 = this;
  var size = 0;
  for (var i = 0; i < this.children.length; i++) {
    size += this$1$1.children[i].size;
  }
  return size;
};
prototypeAccessors$1$6.border.get = function() {
  return 0;
};
ViewDesc$1.prototype.destroy = function destroy() {
  var this$1$1 = this;
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i = 0; i < this.children.length; i++) {
    this$1$1.children[i].destroy();
  }
};
ViewDesc$1.prototype.posBeforeChild = function posBeforeChild(child15) {
  var this$1$1 = this;
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this$1$1.children[i];
    if (cur == child15) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors$1$6.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors$1$6.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors$1$6.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors$1$6.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc$1.prototype.localPosFromDOM = function localPosFromDOM(dom, offset2, bias) {
  var this$1$1 = this;
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset2 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset2];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset2 == 0) {
      for (var search = dom; ; search = search.parentNode) {
        if (search == this$1$1.dom) {
          atEnd2 = false;
          break;
        }
        if (search.parentNode.firstChild != search) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset2 == dom.childNodes.length) {
      for (var search$1 = dom; ; search$1 = search$1.parentNode) {
        if (search$1 == this$1$1.dom) {
          atEnd2 = true;
          break;
        }
        if (search$1.parentNode.lastChild != search$1) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc$1.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
  var this$1$1 = this;
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this$1$1.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom) : desc.nodeDOM == dom)) {
        first = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc$1.prototype.getDesc = function getDesc(dom) {
  var this$1$1 = this;
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this$1$1) {
      return desc;
    }
  }
};
ViewDesc$1.prototype.posFromDOM = function posFromDOM(dom, offset2, bias) {
  var this$1$1 = this;
  for (var scan = dom; ; scan = scan.parentNode) {
    var desc = this$1$1.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset2, bias);
    }
  }
};
ViewDesc$1.prototype.descAt = function descAt(pos) {
  var this$1$1 = this;
  for (var i = 0, offset2 = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (offset2 == pos && end8 != offset2) {
      while (!child15.border && child15.children.length) {
        child15 = child15.children[0];
      }
      return child15;
    }
    if (pos < end8) {
      return child15.descAt(pos - offset2 - child15.border);
    }
    offset2 = end8;
  }
};
ViewDesc$1.prototype.domFromPos = function domFromPos(pos) {
  var this$1$1 = this;
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  for (var offset2 = 0, i = 0; ; i++) {
    if (offset2 == pos) {
      while (i < this.children.length && this.children[i].beforePosition) {
        i++;
      }
      return { node: this$1$1.contentDOM, offset: i };
    }
    if (i == this$1$1.children.length) {
      throw new Error("Invalid position " + pos);
    }
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (pos < end8) {
      return child15.domFromPos(pos - offset2 - child15.border);
    }
    offset2 = end8;
  }
};
ViewDesc$1.prototype.parseRange = function parseRange(from12, to, base2) {
  var this$1$1 = this;
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from12, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset2 = 0, i = 0; ; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (fromOffset == -1 && from12 <= end8) {
      var childBase = offset2 + child15.border;
      if (from12 >= childBase && to <= end8 - child15.border && child15.node && child15.contentDOM && this$1$1.contentDOM.contains(child15.contentDOM)) {
        return child15.parseRange(from12 - childBase, to - childBase, base2 + childBase);
      }
      from12 = base2 + offset2;
      for (var j = i; j > 0; j--) {
        var prev2 = this$1$1.children[j - 1];
        if (prev2.size && prev2.dom.parentNode == this$1$1.contentDOM && !prev2.emptyChildAt(1)) {
          fromOffset = domIndex$1(prev2.dom) + 1;
          break;
        }
        from12 -= prev2.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && to <= end8) {
      to = base2 + end8;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next2 = this$1$1.children[j$1];
        if (next2.size && next2.dom.parentNode == this$1$1.contentDOM && !next2.emptyChildAt(-1)) {
          toOffset = domIndex$1(next2.dom);
          break;
        }
        to += next2.size;
      }
      if (toOffset == -1) {
        toOffset = this$1$1.contentDOM.childNodes.length;
      }
      break;
    }
    offset2 = end8;
  }
  return { node: this.contentDOM, from: from12, to, fromOffset, toOffset };
};
ViewDesc$1.prototype.emptyChildAt = function emptyChildAt(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child15 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child15.size == 0 || child15.emptyChildAt(side);
};
ViewDesc$1.prototype.domAfterPos = function domAfterPos(pos) {
  var ref = this.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  if (node18.nodeType != 1 || offset2 == node18.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node18.childNodes[offset2];
};
ViewDesc$1.prototype.setSelection = function setSelection(anchor, head, root2) {
  var this$1$1 = this;
  var from12 = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset2 = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (from12 > offset2 && to < end8) {
      return child15.setSelection(anchor - offset2 - child15.border, head - offset2 - child15.border, root2);
    }
    offset2 = end8;
  }
  var anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head);
  var domSel = root2.getSelection(), range = document.createRange();
  if (isEquivalentPosition$1(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition$1(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  if (domSel.extend) {
    range.setEnd(anchorDOM.node, anchorDOM.offset);
    range.collapse(false);
  } else {
    if (anchor > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
  }
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (domSel.extend) {
    domSel.extend(headDOM.node, headDOM.offset);
  }
};
ViewDesc$1.prototype.ignoreMutation = function ignoreMutation(_mutation) {
  return !this.contentDOM;
};
prototypeAccessors$1$6.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc$1.prototype.markDirty = function markDirty(from12, to) {
  var this$1$1 = this;
  for (var offset2 = 0, i = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (offset2 == end8 ? from12 <= end8 && to >= offset2 : from12 < end8 && to > offset2) {
      var startInside = offset2 + child15.border, endInside = end8 - child15.border;
      if (from12 >= startInside && to <= endInside) {
        this$1$1.dirty = from12 == offset2 || to == end8 ? CONTENT_DIRTY$1 : CHILD_DIRTY$1;
        if (from12 == startInside && to == endInside && child15.contentLost) {
          child15.dirty = NODE_DIRTY$1;
        } else {
          child15.markDirty(from12 - startInside, to - startInside);
        }
        return;
      } else {
        child15.dirty = NODE_DIRTY$1;
      }
    }
    offset2 = end8;
  }
  this.dirty = CONTENT_DIRTY$1;
};
Object.defineProperties(ViewDesc$1.prototype, prototypeAccessors$1$6);
var nothing$1 = [];
var WidgetViewDesc$1 = function(ViewDesc4) {
  function WidgetViewDesc2(parent, widget3) {
    ViewDesc4.call(this, parent, nothing$1, widget3.type.widget, null);
    this.widget = widget3;
  }
  if (ViewDesc4)
    WidgetViewDesc2.__proto__ = ViewDesc4;
  WidgetViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { beforePosition: {} };
  prototypeAccessors$12.beforePosition.get = function() {
    return this.widget.type.side < 0;
  };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget3(widget3) {
    return this.dirty == NOT_DIRTY$1 && widget3.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    var stop7 = this.widget.spec.stopEvent;
    return stop7 ? stop7(event) : false;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc$1);
var CursorWrapperDesc$1 = function(WidgetViewDesc2) {
  function CursorWrapperDesc2() {
    WidgetViewDesc2.apply(this, arguments);
  }
  if (WidgetViewDesc2)
    CursorWrapperDesc2.__proto__ = WidgetViewDesc2;
  CursorWrapperDesc2.prototype = Object.create(WidgetViewDesc2 && WidgetViewDesc2.prototype);
  CursorWrapperDesc2.prototype.constructor = CursorWrapperDesc2;
  CursorWrapperDesc2.prototype.parseRule = function parseRule3() {
    var content2;
    for (var child15 = this.dom.firstChild; child15; child15 = child15.nextSibling) {
      var add4 = void 0;
      if (child15.nodeType == 3) {
        var text8 = child15.nodeValue.replace(/\ufeff/g, "");
        if (!text8) {
          continue;
        }
        add4 = document.createTextNode(text8);
      } else if (child15.textContent == "\uFEFF") {
        continue;
      } else {
        add4 = child15.cloneNode(true);
      }
      if (!content2) {
        content2 = document.createDocumentFragment();
      }
      content2.appendChild(add4);
    }
    if (content2) {
      return { skip: content2 };
    } else {
      return WidgetViewDesc2.prototype.parseRule.call(this);
    }
  };
  CursorWrapperDesc2.prototype.ignoreMutation = function ignoreMutation3() {
    return false;
  };
  return CursorWrapperDesc2;
}(WidgetViewDesc$1);
var MarkViewDesc$1 = function(ViewDesc4) {
  function MarkViewDesc2(parent, mark15, dom, contentDOM) {
    ViewDesc4.call(this, parent, [], dom, contentDOM);
    this.mark = mark15;
  }
  if (ViewDesc4)
    MarkViewDesc2.__proto__ = ViewDesc4;
  MarkViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create22(parent, mark15, inline3, view2) {
    var custom = customNodeViews$1(view2)[mark15.type.name];
    var spec = custom && custom(mark15, view2);
    if (!spec || !spec.dom) {
      spec = prosemirrorModel$2.DOMSerializer.renderSpec(document, mark15.type.spec.toDOM(mark15, inline3));
    }
    return new MarkViewDesc2(parent, mark15, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule3() {
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark3(mark15) {
    return this.dirty != NODE_DIRTY$1 && this.mark.eq(mark15);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty5(from12, to) {
    ViewDesc4.prototype.markDirty.call(this, from12, to);
    if (this.dirty != NOT_DIRTY$1) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY$1;
    }
  };
  return MarkViewDesc2;
}(ViewDesc$1);
var NodeViewDesc$1 = function(ViewDesc4) {
  function NodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2) {
    ViewDesc4.call(this, parent, node18.isLeaf ? nothing$1 : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node18;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view2);
    }
  }
  if (ViewDesc4)
    NodeViewDesc2.__proto__ = ViewDesc4;
  NodeViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$22 = { size: {}, border: {} };
  NodeViewDesc2.create = function create22(parent, node18, outerDeco, innerDeco, view2) {
    var custom = customNodeViews$1(view2)[node18.type.name], descObj;
    var spec = custom && custom(node18, view2, function() {
      if (descObj && descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node18.isText) {
      if (!dom) {
        dom = document.createTextNode(node18.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      var assign3;
      assign3 = prosemirrorModel$2.DOMSerializer.renderSpec(document, node18.type.spec.toDOM(node18)), dom = assign3.dom, contentDOM = assign3.contentDOM;
    }
    if (!contentDOM && !node18.isText && dom.nodeName != "BR") {
      dom.contentEditable = false;
      if (node18.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM = dom;
    dom = applyOuterDeco$1(dom, outerDeco, node18);
    if (spec) {
      return descObj = new CustomNodeViewDesc$1(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view2);
    } else if (node18.isText) {
      return new TextViewDesc$1(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2);
    } else {
      return new NodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule3() {
    var this$1$1 = this;
    if (this.contentDOM && !this.contentLost) {
      return { node: this.node.type.name, attrs: this.node.attrs, contentElement: this.contentDOM };
    } else {
      return { node: this.node.type.name, attrs: this.node.attrs, getContent: function() {
        return this$1$1.contentDOM ? prosemirrorModel$2.Fragment.empty : this$1$1.node.content;
      } };
    }
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode3(node18, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY$1 && node18.eq(this.node) && sameOuterDeco$1(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$22.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$22.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view2) {
    var this$1$1 = this;
    var updater = new ViewTreeUpdater$1(this), inline3 = this.node.inlineContent;
    iterDeco$1(this.node, this.innerDeco, function(widget3, i) {
      if (widget3.spec.marks) {
        updater.syncToMarks(widget3.spec.marks, inline3, view2);
      } else if (widget3.type.side >= 0) {
        updater.syncToMarks(i == this$1$1.node.childCount ? prosemirrorModel$2.Mark.none : this$1$1.node.child(i).marks, inline3, view2);
      }
      updater.placeWidget(widget3);
    }, function(child15, outerDeco, innerDeco, i) {
      updater.syncToMarks(child15.marks, inline3, view2);
      updater.findNodeMatch(child15, outerDeco, innerDeco, i) || updater.updateNextNode(child15, outerDeco, innerDeco, view2, i) || updater.addNode(child15, outerDeco, innerDeco, view2);
    });
    updater.syncToMarks(nothing$1, inline3, view2);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY$1) {
      this.renderChildren();
    }
  };
  NodeViewDesc2.prototype.renderChildren = function renderChildren() {
    renderDescs$1(this.contentDOM, this.children, NodeViewDesc2.is);
    if (result$1.ios) {
      iosHacks$1(this.dom);
    }
  };
  NodeViewDesc2.prototype.update = function update4(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY$1 || !node18.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node18, outerDeco, innerDeco, view2);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node18, outerDeco, innerDeco, view2) {
    this.updateOuterDeco(outerDeco);
    this.node = node18;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view2);
    }
    this.dirty = NOT_DIRTY$1;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco$1(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco$1(
      this.dom,
      this.nodeDOM,
      computeOuterDeco$1(this.outerDeco, this.node, needsWrap),
      computeOuterDeco$1(outerDeco, this.node, needsWrap)
    );
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$22);
  return NodeViewDesc2;
}(ViewDesc$1);
function docViewDesc$1(doc2, outerDeco, innerDeco, dom, view2) {
  applyOuterDeco$1(dom, outerDeco, doc2);
  return new NodeViewDesc$1(null, doc2, outerDeco, innerDeco, dom, dom, dom, view2);
}
var TextViewDesc$1 = function(NodeViewDesc2) {
  function TextViewDesc2(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2) {
    NodeViewDesc2.call(this, parent, node18, outerDeco, innerDeco, dom, null, nodeDOM, view2);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  TextViewDesc2.prototype.parseRule = function parseRule3() {
    var parent = this.nodeDOM.parentNode;
    return parent ? { skip: parent } : { ignore: true };
  };
  TextViewDesc2.prototype.update = function update4(node18, outerDeco) {
    if (this.dirty == NODE_DIRTY$1 || this.dirty != NOT_DIRTY$1 && !this.inParent() || !node18.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY$1 || node18.text != this.node.text) && node18.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node18.text;
    }
    this.node = node18;
    this.dirty = NOT_DIRTY$1;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset2, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return mutation.type != "characterData";
  };
  return TextViewDesc2;
}(NodeViewDesc$1);
var BRHackViewDesc$1 = function(ViewDesc4) {
  function BRHackViewDesc2() {
    ViewDesc4.apply(this, arguments);
  }
  if (ViewDesc4)
    BRHackViewDesc2.__proto__ = ViewDesc4;
  BRHackViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  BRHackViewDesc2.prototype.constructor = BRHackViewDesc2;
  BRHackViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  BRHackViewDesc2.prototype.matchesHack = function matchesHack3() {
    return this.dirty == NOT_DIRTY$1;
  };
  return BRHackViewDesc2;
}(ViewDesc$1);
var CustomNodeViewDesc$1 = function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view2) {
    NodeViewDesc2.call(this, parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update4(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY$1) {
      return false;
    }
    if (this.spec.update) {
      var result$$1 = this.spec.update(node18, outerDeco);
      if (result$$1) {
        this.updateInner(node18, outerDeco, innerDeco, view2);
      }
      return result$$1;
    } else if (!this.contentDOM && !node18.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node18, outerDeco, innerDeco, view2);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection3(anchor, head, root2) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root2);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy12() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc$1);
function renderDescs$1(parentDOM, descs) {
  var dom = parentDOM.firstChild;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm$1(dom);
      }
      dom = dom.nextSibling;
    } else {
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc$1) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs$1(desc.contentDOM, desc.children);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm$1(dom);
  }
}
function OuterDecoLevel$1(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel$1.prototype = /* @__PURE__ */ Object.create(null);
var noDeco$1 = [new OuterDecoLevel$1()];
function computeOuterDeco$1(outerDeco, node18, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco$1;
  }
  var top = needsWrap ? noDeco$1[0] : new OuterDecoLevel$1(), result$$1 = [top];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs, cur = top;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result$$1.push(cur = new OuterDecoLevel$1(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result$$1.length == 1) {
        result$$1.push(cur = top = new OuterDecoLevel$1(node18.isInline ? "span" : "div"));
      }
      if (name == "class") {
        cur.class = (cur.class ? cur.class + " " : "") + val;
      } else if (name == "style") {
        cur.style = (cur.style ? cur.style + ";" : "") + val;
      } else if (name != "nodeName") {
        cur[name] = val;
      }
    }
  }
  return result$$1;
}
function patchOuterDeco$1(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco$1 && curComputed == noDeco$1) {
    return nodeDOM;
  }
  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev2 = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev2 && prev2.nodeName == deco.nodeName && curDOM != outerDOM && (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.appendChild(curDOM);
        curDOM = parent;
      }
    }
    patchAttributes$1(curDOM, prev2 || noDeco$1[0], deco);
  }
  return curDOM;
}
function patchAttributes$1(dom, prev2, cur) {
  for (var name in prev2) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev2[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev2.class != cur.class) {
    var prevList = prev2.class ? prev2.class.split(" ") : nothing$1;
    var curList = cur.class ? cur.class.split(" ") : nothing$1;
    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) {
        dom.classList.remove(prevList[i]);
      }
    }
    for (var i$12 = 0; i$12 < curList.length; i$12++) {
      if (prevList.indexOf(curList[i$12]) == -1) {
        dom.classList.add(curList[i$12]);
      }
    }
  }
  if (prev2.style != cur.style) {
    if (prev2.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev2.style)) {
        dom.style[m2[1].toLowerCase()] = "";
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco$1(dom, deco, node18) {
  return patchOuterDeco$1(dom, dom, noDeco$1, computeOuterDeco$1(deco, node18, dom.nodeType != 1));
}
function sameOuterDeco$1(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) {
      return false;
    }
  }
  return true;
}
function rm$1(dom) {
  var next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
var ViewTreeUpdater$1 = function ViewTreeUpdater(top) {
  this.top = top;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatched = preMatch$1(top.node.content, top.children);
};
ViewTreeUpdater$1.prototype.destroyBetween = function destroyBetween(start16, end8) {
  var this$1$1 = this;
  if (start16 == end8) {
    return;
  }
  for (var i = start16; i < end8; i++) {
    this$1$1.top.children[i].destroy();
  }
  this.top.children.splice(start16, end8 - start16);
  this.changed = true;
};
ViewTreeUpdater$1.prototype.destroyRest = function destroyRest() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater$1.prototype.syncToMarks = function syncToMarks(marks9, inline3, view2) {
  var this$1$1 = this;
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks9.length), next2;
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks9[keep])) {
    keep++;
  }
  while (keep < depth) {
    this$1$1.destroyRest();
    this$1$1.top.dirty = NOT_DIRTY$1;
    this$1$1.index = this$1$1.stack.pop();
    this$1$1.top = this$1$1.stack.pop();
    depth--;
  }
  while (depth < marks9.length) {
    this$1$1.stack.push(this$1$1.top, this$1$1.index + 1);
    if (this$1$1.index < this$1$1.top.children.length && (next2 = this$1$1.top.children[this$1$1.index]).matchesMark(marks9[depth])) {
      this$1$1.top = next2;
    } else {
      var markDesc = MarkViewDesc$1.create(this$1$1.top, marks9[depth], inline3, view2);
      this$1$1.top.children.splice(this$1$1.index, 0, markDesc);
      this$1$1.top = markDesc;
      this$1$1.changed = true;
    }
    this$1$1.index = 0;
    depth++;
  }
};
ViewTreeUpdater$1.prototype.findNodeMatch = function findNodeMatch(node18, outerDeco, innerDeco, index8) {
  var this$1$1 = this;
  for (var i = this.index, children = this.top.children, e = Math.min(children.length, i + 5); i < e; i++) {
    var child15 = children[i], preMatched = void 0;
    if (child15.matchesNode(node18, outerDeco, innerDeco) && ((preMatched = this$1$1.preMatched.indexOf(child15)) == -1 || preMatched == index8)) {
      this$1$1.destroyBetween(this$1$1.index, i);
      this$1$1.index++;
      return true;
    }
  }
  return false;
};
ViewTreeUpdater$1.prototype.updateNextNode = function updateNextNode(node18, outerDeco, innerDeco, view2, index8) {
  if (this.index == this.top.children.length) {
    return false;
  }
  var next2 = this.top.children[this.index];
  if (next2 instanceof NodeViewDesc$1) {
    var preMatch2 = this.preMatched.indexOf(next2);
    if (preMatch2 > -1 && preMatch2 != index8) {
      return false;
    }
    var nextDOM = next2.dom;
    if (next2.update(node18, outerDeco, innerDeco, view2)) {
      if (next2.dom != nextDOM) {
        this.changed = true;
      }
      this.index++;
      return true;
    }
  }
  return false;
};
ViewTreeUpdater$1.prototype.addNode = function addNode2(node18, outerDeco, innerDeco, view2) {
  this.top.children.splice(this.index++, 0, NodeViewDesc$1.create(this.top, node18, outerDeco, innerDeco, view2));
  this.changed = true;
};
ViewTreeUpdater$1.prototype.placeWidget = function placeWidget(widget3) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget3)) {
    this.index++;
  } else {
    var desc = new (widget3.spec.isCursorWrapper ? CursorWrapperDesc$1 : WidgetViewDesc$1)(this.top, widget3);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater$1.prototype.addTextblockHacks = function addTextblockHacks() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc$1) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc$1) || /\n$/.test(lastChild.node.text)) {
    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
      this.index++;
    } else {
      var dom = document.createElement("br");
      this.top.children.splice(this.index++, 0, new BRHackViewDesc$1(this.top, nothing$1, dom, null));
      this.changed = true;
    }
  }
};
function preMatch$1(frag, descs) {
  var result$$1 = [], end8 = frag.childCount;
  for (var i = descs.length - 1; end8 > 0 && i >= 0; i--) {
    var desc = descs[i], node18 = desc.node;
    if (!node18) {
      continue;
    }
    if (node18 != frag.child(end8 - 1)) {
      break;
    }
    result$$1[--end8] = desc;
  }
  return result$$1;
}
function compareSide$1(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco$1(parent, deco, onWidget, onNode) {
  var locals5 = deco.locals(parent), offset2 = 0;
  if (locals5.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child15 = parent.child(i);
      onNode(child15, locals5, deco.forChild(offset2, child15), i);
      offset2 += child15.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
      var widget3 = locals5[decoIndex++], widgets = void 0;
      while (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
        (widgets || (widgets = [widget3])).push(locals5[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide$1);
        for (var i$12 = 0; i$12 < widgets.length; i$12++) {
          onWidget(widgets[i$12], parentIndex);
        }
      } else {
        onWidget(widget3, parentIndex);
      }
    }
    var child$1 = void 0;
    if (restNode) {
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset2) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals5.length && locals5[decoIndex].from == offset2) {
      active.push(locals5[decoIndex++]);
    }
    var end8 = offset2 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end8;
      if (decoIndex < locals5.length && locals5[decoIndex].from < cutAt) {
        cutAt = locals5[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end8) {
        restNode = child$1.cut(cutAt - offset2);
        child$1 = child$1.cut(0, cutAt - offset2);
        end8 = cutAt;
      }
    }
    onNode(child$1, active.length ? active.slice() : nothing$1, deco.forChild(offset2, child$1), parentIndex - 1);
    offset2 = end8;
  }
}
var cachedCustomViews$1;
var cachedCustomFor$1;
function customNodeViews$1(view2) {
  if (cachedCustomFor$1 == view2._props) {
    return cachedCustomViews$1;
  }
  cachedCustomFor$1 = view2._props;
  return cachedCustomViews$1 = buildCustomViews$1(view2);
}
function buildCustomViews$1(view2) {
  var result$$1 = {};
  view2.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result$$1, prop)) {
        result$$1[prop] = obj[prop];
      }
    }
  });
  return result$$1;
}
function iosHacks$1(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function moveSelectionBlock$1(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirrorState$6.Selection.findFrom($start, dir);
}
function apply$3(view2, sel) {
  view2.dispatch(view2.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally$1(view2, dir) {
  var sel = view2.state.selection;
  if (sel instanceof prosemirrorState$6.TextSelection) {
    if (!sel.empty) {
      return false;
    } else if (view2.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next2 = moveSelectionBlock$1(view2.state, dir);
      if (next2 && next2 instanceof prosemirrorState$6.NodeSelection) {
        return apply$3(view2, next2);
      }
      return false;
    } else {
      var $head = sel.$head, node18 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (node18 && prosemirrorState$6.NodeSelection.isSelectable(node18)) {
        var nodePos = dir < 0 ? $head.pos - node18.nodeSize : $head.pos;
        if (node18.isAtom || (desc = view2.docView.descAt(nodePos)) && !desc.contentDOM) {
          return apply$3(view2, new prosemirrorState$6.NodeSelection(dir < 0 ? view2.state.doc.resolve($head.pos - node18.nodeSize) : $head));
        }
      }
      return false;
    }
  } else if (sel instanceof prosemirrorState$6.NodeSelection && sel.node.isInline) {
    return apply$3(view2, new prosemirrorState$6.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock$1(view2.state, dir);
    if (next$1) {
      return apply$3(view2, next$1);
    }
    return false;
  }
}
function nodeLen$1(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function isIgnorable$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft$1(view2) {
  var sel = view2.root.getSelection();
  var node18 = sel.anchorNode, offset2 = sel.anchorOffset;
  if (!node18) {
    return;
  }
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 > 0) {
      if (node18.nodeType != 1) {
        if (node18.nodeType == 3 && node18.nodeValue.charAt(offset2 - 1) == "\uFEFF") {
          moveNode = node18;
          moveOffset = --offset2;
        } else {
          break;
        }
      } else {
        var before8 = node18.childNodes[offset2 - 1];
        if (isIgnorable$1(before8)) {
          moveNode = node18;
          moveOffset = --offset2;
        } else if (before8.nodeType == 3) {
          node18 = before8;
          offset2 = node18.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode$1(node18)) {
      break;
    } else {
      var prev2 = node18.previousSibling;
      while (prev2 && isIgnorable$1(prev2)) {
        moveNode = node18.parentNode;
        moveOffset = domIndex$1(prev2);
        prev2 = prev2.previousSibling;
      }
      if (!prev2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom) {
          break;
        }
        offset2 = 0;
      } else {
        node18 = prev2;
        offset2 = nodeLen$1(node18);
      }
    }
  }
  if (moveNode) {
    setSel$1(view2, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight$1(view2) {
  var sel = view2.root.getSelection();
  var node18 = sel.anchorNode, offset2 = sel.anchorOffset;
  if (!node18) {
    return;
  }
  var len = nodeLen$1(node18);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node18.nodeType != 1) {
        break;
      }
      var after8 = node18.childNodes[offset2];
      if (isIgnorable$1(after8)) {
        moveNode = node18;
        moveOffset = ++offset2;
      } else {
        break;
      }
    } else if (isBlockNode$1(node18)) {
      break;
    } else {
      var next2 = node18.nextSibling;
      while (next2 && isIgnorable$1(next2)) {
        moveNode = next2.parentNode;
        moveOffset = domIndex$1(next2) + 1;
        next2 = next2.nextSibling;
      }
      if (!next2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom) {
          break;
        }
        offset2 = len = 0;
      } else {
        node18 = next2;
        offset2 = 0;
        len = nodeLen$1(node18);
      }
    }
  }
  if (moveNode) {
    setSel$1(view2, sel, moveNode, moveOffset);
  }
}
function isBlockNode$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSel$1(view2, sel, node18, offset2) {
  var range = document.createRange();
  range.setEnd(node18, offset2);
  range.setStart(node18, offset2);
  sel.removeAllRanges();
  sel.addRange(range);
  view2.selectionReader.storeDOMState(view2.selection);
}
function selectVertically$1(view2, dir) {
  var sel = view2.state.selection;
  if (sel instanceof prosemirrorState$6.TextSelection && !sel.empty) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view2.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next2 = moveSelectionBlock$1(view2.state, dir);
    if (next2 && next2 instanceof prosemirrorState$6.NodeSelection) {
      return apply$3(view2, next2);
    }
  }
  if (!$from.parent.inlineContent) {
    var beyond = prosemirrorState$6.Selection.findFrom(dir < 0 ? $from : $to, dir);
    return beyond ? apply$3(view2, beyond) : true;
  }
  return false;
}
function stopNativeHorizontalDelete$1(view2, dir) {
  if (!(view2.state.selection instanceof prosemirrorState$6.TextSelection)) {
    return true;
  }
  var ref = view2.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view2.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view2.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view2.dispatch(tr);
    return true;
  }
  return false;
}
function getMods$1(event) {
  var result$$1 = "";
  if (event.ctrlKey) {
    result$$1 += "c";
  }
  if (event.metaKey) {
    result$$1 += "m";
  }
  if (event.altKey) {
    result$$1 += "a";
  }
  if (event.shiftKey) {
    result$$1 += "s";
  }
  return result$$1;
}
function captureKeyDown$1(view2, event) {
  var code = event.keyCode, mods = getMods$1(event);
  if (code == 8 || result$1.mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete$1(view2, -1) || skipIgnoredNodesLeft$1(view2);
  } else if (code == 46 || result$1.mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete$1(view2, 1) || skipIgnoredNodesRight$1(view2);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37) {
    return selectHorizontally$1(view2, -1) || skipIgnoredNodesLeft$1(view2);
  } else if (code == 39) {
    return selectHorizontally$1(view2, 1) || skipIgnoredNodesRight$1(view2);
  } else if (code == 38) {
    return selectVertically$1(view2, -1) || skipIgnoredNodesLeft$1(view2);
  } else if (code == 40) {
    return selectVertically$1(view2, 1) || skipIgnoredNodesRight$1(view2);
  } else if (mods == (result$1.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
var TrackedRecord$1 = function TrackedRecord(prev2, mapping, state) {
  this.prev = prev2;
  this.mapping = mapping;
  this.state = state;
};
var TrackMappings$1 = function TrackMappings(state) {
  this.seen = [new TrackedRecord$1(null, null, state)];
  prosemirrorState$6.EditorState.addApplyListener(this.track = this.track.bind(this));
};
TrackMappings$1.prototype.destroy = function destroy2() {
  prosemirrorState$6.EditorState.removeApplyListener(this.track);
};
TrackMappings$1.prototype.find = function find(state) {
  var this$1$1 = this;
  for (var i = this.seen.length - 1; i >= 0; i--) {
    var record = this$1$1.seen[i];
    if (record.state == state) {
      return record;
    }
  }
};
TrackMappings$1.prototype.track = function track(old, tr, state) {
  var found2 = this.seen.length < 200 ? this.find(old) : null;
  if (found2) {
    this.seen.push(new TrackedRecord$1(found2, tr.docChanged ? tr.mapping : null, state));
  }
};
TrackMappings$1.prototype.getMapping = function getMapping(state, appendTo) {
  var found2 = this.find(state);
  if (!found2) {
    return null;
  }
  var mappings = [];
  for (var rec = found2; rec; rec = rec.prev) {
    if (rec.mapping) {
      mappings.push(rec.mapping);
    }
  }
  var result2 = appendTo || new prosemirrorTransform$2.Mapping();
  for (var i = mappings.length - 1; i >= 0; i--) {
    result2.appendMapping(mappings[i]);
  }
  return result2;
};
var SelectionReader$1 = function SelectionReader(view2) {
  var this$1$1 = this;
  this.view = view2;
  this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;
  this.lastSelection = view2.state.selection;
  this.ignoreUpdates = false;
  this.poller = poller$1(this);
  view2.dom.addEventListener("focus", function() {
    return this$1$1.poller.start(hasFocusAndSelection$1(this$1$1.view));
  });
  view2.dom.addEventListener("blur", function() {
    return this$1$1.poller.stop();
  });
  if (!view2.editable) {
    this.poller.start(false);
  }
};
SelectionReader$1.prototype.destroy = function destroy3() {
  this.poller.stop();
};
SelectionReader$1.prototype.poll = function poll(origin) {
  this.poller.poll(origin);
};
SelectionReader$1.prototype.editableChanged = function editableChanged() {
  if (!this.view.editable) {
    this.poller.start();
  } else if (!hasFocusAndSelection$1(this.view)) {
    this.poller.stop();
  }
};
SelectionReader$1.prototype.domChanged = function domChanged() {
  var sel = this.view.root.getSelection();
  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;
};
SelectionReader$1.prototype.storeDOMState = function storeDOMState(selection) {
  var sel = this.view.root.getSelection();
  this.lastAnchorNode = sel.anchorNode;
  this.lastAnchorOffset = sel.anchorOffset;
  this.lastHeadNode = sel.focusNode;
  this.lastHeadOffset = sel.focusOffset;
  this.lastSelection = selection;
};
SelectionReader$1.prototype.clearDOMState = function clearDOMState() {
  this.lastAnchorNode = this.lastSelection = null;
};
SelectionReader$1.prototype.readFromDOM = function readFromDOM(origin) {
  if (this.ignoreUpdates || !this.domChanged() || !hasFocusAndSelection$1(this.view)) {
    return;
  }
  if (!this.view.inDOMChange) {
    this.view.domObserver.flush();
  }
  if (this.view.inDOMChange) {
    return;
  }
  var domSel = this.view.root.getSelection(), doc2 = this.view.state.doc;
  var nearestDesc3 = this.view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc3.size == 0;
  var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed$1(domSel)) {
    $anchor = $head;
    while (nearestDesc3 && !nearestDesc3.node) {
      nearestDesc3 = nearestDesc3.parent;
    }
    if (nearestDesc3 && nearestDesc3.node.isAtom && prosemirrorState$6.NodeSelection.isSelectable(nearestDesc3.node) && nearestDesc3.parent) {
      var pos = nearestDesc3.posBefore;
      selection = new prosemirrorState$6.NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    $anchor = doc2.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset));
  }
  if (!selection) {
    var bias = origin == "pointer" || this.view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween$1(this.view, $anchor, $head, bias);
  }
  var preserve = !inWidget && head == selection.head && $anchor.pos == selection.anchor && (!this.view.cursorWrapper || domSel.isCollapsed && origin != "pointer");
  if (preserve) {
    this.storeDOMState(selection);
  }
  if (!this.view.state.selection.eq(selection)) {
    var tr = this.view.state.tr.setSelection(selection);
    if (origin == "pointer") {
      tr.setMeta("pointer", true);
    }
    this.view.dispatch(tr);
  } else if (!preserve) {
    selectionToDOM$1(this.view);
  }
};
var SelectionChangePoller$1 = function SelectionChangePoller(reader) {
  var this$1$1 = this;
  this.listening = false;
  this.curOrigin = null;
  this.originTime = 0;
  this.reader = reader;
  this.readFunc = function() {
    return reader.readFromDOM(this$1$1.originTime > Date.now() - 50 ? this$1$1.curOrigin : null);
  };
};
SelectionChangePoller$1.prototype.poll = function poll2(origin) {
  this.curOrigin = origin;
  this.originTime = Date.now();
};
SelectionChangePoller$1.prototype.start = function start6(andRead) {
  if (!this.listening) {
    var doc2 = this.reader.view.dom.ownerDocument;
    doc2.addEventListener("selectionchange", this.readFunc);
    this.listening = true;
    if (andRead) {
      this.readFunc();
    }
  }
};
SelectionChangePoller$1.prototype.stop = function stop() {
  if (this.listening) {
    var doc2 = this.reader.view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", this.readFunc);
    this.listening = false;
  }
};
var TimeoutPoller$1 = function TimeoutPoller(reader) {
  this.polling = null;
  this.reader = reader;
  this.pollFunc = this.doPoll.bind(this, null);
};
TimeoutPoller$1.prototype.doPoll = function doPoll(origin) {
  var view2 = this.reader.view;
  if (view2.focused || !view2.editable) {
    this.reader.readFromDOM(origin);
    this.polling = setTimeout(this.pollFunc, 100);
  } else {
    this.polling = null;
  }
};
TimeoutPoller$1.prototype.poll = function poll3(origin) {
  clearTimeout(this.polling);
  this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0);
};
TimeoutPoller$1.prototype.start = function start7() {
  if (this.polling == null) {
    this.poll();
  }
};
TimeoutPoller$1.prototype.stop = function stop2() {
  clearTimeout(this.polling);
  this.polling = null;
};
function poller$1(reader) {
  return new ("onselectionchange" in document ? SelectionChangePoller$1 : TimeoutPoller$1)(reader);
}
function selectionToDOM$1(view2, takeFocus) {
  var sel = view2.state.selection;
  syncNodeSelection$1(view2, sel);
  if (view2.editable && !view2.hasFocus()) {
    if (!takeFocus) {
      return;
    }
    if (result$1.gecko && result$1.gecko_version <= 55) {
      view2.selectionReader.ignoreUpdates = true;
      view2.dom.focus();
      view2.selectionReader.ignoreUpdates = false;
    }
  } else if (!view2.editable && !hasSelection$1(view2) && !takeFocus) {
    return;
  }
  var reader = view2.selectionReader;
  if (reader.lastSelection && reader.lastSelection.eq(sel) && !reader.domChanged()) {
    return;
  }
  reader.ignoreUpdates = true;
  if (view2.cursorWrapper) {
    selectCursorWrapper$1(view2);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable$1 && !(sel instanceof prosemirrorState$6.TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear$1(view2, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear$1(view2, sel.to);
      }
    }
    view2.docView.setSelection(anchor, head, view2.root);
    if (brokenSelectBetweenUneditable$1) {
      if (resetEditableFrom) {
        resetEditableFrom.contentEditable = "false";
      }
      if (resetEditableTo) {
        resetEditableTo.contentEditable = "false";
      }
    }
    if (sel.visible) {
      view2.dom.classList.remove("ProseMirror-hideselection");
    } else if (anchor != head) {
      view2.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange$1(view2);
      }
    }
  }
  reader.storeDOMState(sel);
  reader.ignoreUpdates = false;
}
var brokenSelectBetweenUneditable$1 = result$1.safari || result$1.chrome && result$1.chrome_version < 63;
function temporarilyEditableNear$1(view2, pos) {
  var ref = view2.docView.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var after8 = offset2 < node18.childNodes.length ? node18.childNodes[offset2] : null;
  var before8 = offset2 ? node18.childNodes[offset2 - 1] : null;
  if ((!after8 || after8.contentEditable == "false") && (!before8 || before8.contentEditable == "false")) {
    if (after8) {
      after8.contentEditable = "true";
      return after8;
    } else if (before8) {
      before8.contentEditable = "true";
      return before8;
    }
  }
}
function removeClassOnSelectionChange$1(view2) {
  var doc2 = view2.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view2.hideSelectionGuard);
  var domSel = view2.root.getSelection();
  var node18 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view2.hideSelectionGuard = function() {
    if (domSel.anchorNode != node18 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view2.hideSelectionGuard);
      view2.dom.classList.remove("ProseMirror-hideselection");
    }
  });
}
function selectCursorWrapper$1(view2) {
  var domSel = view2.root.getSelection(), range = document.createRange();
  var node18 = view2.cursorWrapper.type.widget;
  range.setEnd(node18, node18.childNodes.length);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!view2.state.selection.visible && result$1.ie && result$1.ie_version <= 11) {
    node18.disabled = true;
    node18.disabled = false;
  }
}
function syncNodeSelection$1(view2, sel) {
  if (sel instanceof prosemirrorState$6.NodeSelection) {
    var desc = view2.docView.descAt(sel.from);
    if (desc != view2.lastSelectedViewDesc) {
      clearNodeSelection$1(view2);
      if (desc) {
        desc.selectNode();
      }
      view2.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection$1(view2);
  }
}
function clearNodeSelection$1(view2) {
  if (view2.lastSelectedViewDesc) {
    view2.lastSelectedViewDesc.deselectNode();
    view2.lastSelectedViewDesc = null;
  }
}
function selectionBetween$1(view2, $anchor, $head, bias) {
  return view2.someProp("createSelectionBetween", function(f2) {
    return f2(view2, $anchor, $head);
  }) || prosemirrorState$6.TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection$1(view2) {
  if (view2.editable && view2.root.activeElement != view2.dom) {
    return false;
  }
  return hasSelection$1(view2);
}
function hasSelection$1(view2) {
  var sel = view2.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view2.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode);
  } catch (_) {
    return false;
  }
}
var DOMChange$1 = function DOMChange(view2, composing) {
  var this$1$1 = this;
  this.view = view2;
  this.state = view2.state;
  this.composing = composing;
  this.from = this.to = null;
  this.typeOver = false;
  this.timeout = composing ? null : setTimeout(function() {
    return this$1$1.finish();
  }, DOMChange.commitTimeout);
  this.trackMappings = new TrackMappings$1(view2.state);
  this.mapping = new prosemirrorTransform$2.Mapping();
  this.mappingTo = view2.state;
};
DOMChange$1.prototype.addRange = function addRange(from12, to) {
  if (this.from == null) {
    this.from = from12;
    this.to = to;
  } else {
    this.from = Math.min(from12, this.from);
    this.to = Math.max(to, this.to);
  }
};
DOMChange$1.prototype.changedRange = function changedRange() {
  if (this.from == null) {
    return rangeAroundSelection$1(this.state.selection);
  }
  var $from = this.state.doc.resolve(Math.min(this.from, this.state.selection.from)), $to = this.state.doc.resolve(this.to);
  var shared2 = $from.sharedDepth(this.to);
  return { from: $from.before(shared2 + 1), to: $to.after(shared2 + 1) };
};
DOMChange$1.prototype.markDirty = function markDirty2(range) {
  if (this.from == null) {
    this.view.docView.markDirty((range = range || this.changedRange()).from, range.to);
  } else {
    this.view.docView.markDirty(this.from, this.to);
  }
};
DOMChange$1.prototype.stateUpdated = function stateUpdated(state) {
  if (this.trackMappings.getMapping(state, this.mapping)) {
    this.trackMappings.destroy();
    this.trackMappings = new TrackMappings$1(state);
    this.mappingTo = state;
    return true;
  } else {
    this.markDirty();
    this.destroy();
    return false;
  }
};
DOMChange$1.prototype.finish = function finish11(force) {
  clearTimeout(this.timeout);
  if (this.composing && !force) {
    return;
  }
  this.view.domObserver.flush();
  var range = this.changedRange();
  this.markDirty(range);
  this.destroy();
  var sel = this.state.selection, allowTypeOver = this.typeOver && sel instanceof prosemirrorState$6.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor);
  readDOMChange$1(this.view, this.mapping, this.state, range, allowTypeOver);
  if (this.view.docView.dirty) {
    this.view.updateState(this.view.state);
  }
};
DOMChange$1.prototype.destroy = function destroy4() {
  clearTimeout(this.timeout);
  this.trackMappings.destroy();
  this.view.inDOMChange = null;
};
DOMChange$1.prototype.compositionEnd = function compositionEnd() {
  var this$1$1 = this;
  if (this.composing) {
    this.composing = false;
    this.timeout = setTimeout(function() {
      return this$1$1.finish();
    }, 50);
  }
};
DOMChange$1.start = function start8(view2, composing) {
  if (view2.inDOMChange) {
    if (composing) {
      clearTimeout(view2.inDOMChange.timeout);
      view2.inDOMChange.composing = true;
    }
  } else {
    view2.inDOMChange = new DOMChange$1(view2, composing);
  }
  return view2.inDOMChange;
};
DOMChange$1.commitTimeout = 20;
function parseBetween$1(view2, oldState, range) {
  var ref = view2.docView.parseRange(range.from, range.to);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from12 = ref.from;
  var to = ref.to;
  var domSel = view2.root.getSelection(), find5 = null, anchor = domSel.anchorNode;
  if (anchor && view2.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find5 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed$1(domSel)) {
      find5.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  var startDoc = oldState.doc;
  var parser = view2.someProp("domParser") || prosemirrorModel$2.DOMParser.fromSchema(view2.state.schema);
  var $from = startDoc.resolve(from12);
  var sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find5,
    ruleFromNode: ruleFromNode$1(parser, $from),
    context: $from
  });
  if (find5 && find5[0].pos != null) {
    var anchor$1 = find5[0].pos, head = find5[1] && find5[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from12, head: head + from12 };
  }
  return { doc: doc2, sel, from: from12, to };
}
function ruleFromNode$1(parser, context) {
  return function(dom) {
    var desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (result$1.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        return parser.matchTag(document.createElement("li"), context);
      } else if (dom.parentNode.lastChild == dom) {
        return { ignore: true };
      }
    }
  };
}
function isAtEnd$1($pos, depth) {
  for (var i = depth || 0; i < $pos.depth; i++) {
    if ($pos.index(i) + 1 < $pos.node(i).childCount) {
      return false;
    }
  }
  return $pos.parentOffset == $pos.parent.content.size;
}
function isAtStart$1($pos, depth) {
  for (var i = depth || 0; i < $pos.depth; i++) {
    if ($pos.index(0) > 0) {
      return false;
    }
  }
  return $pos.parentOffset == 0;
}
function rangeAroundSelection$1(selection) {
  var $from = selection.$anchor.min(selection.$head), $to = selection.$anchor.max(selection.$head);
  if ($from.sameParent($to) && $from.parent.inlineContent && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {
    var startOff = Math.max(0, $from.parentOffset);
    var size = $from.parent.content.size;
    var endOff = Math.min(size, $to.parentOffset);
    if (startOff > 0) {
      startOff = $from.parent.childBefore(startOff).offset;
    }
    if (endOff < size) {
      var after8 = $from.parent.childAfter(endOff);
      endOff = after8.offset + after8.node.nodeSize;
    }
    var nodeStart = $from.start();
    return { from: nodeStart + startOff, to: nodeStart + endOff };
  } else {
    for (var depth = 0; ; depth++) {
      var fromStart = isAtStart$1($from, depth + 1), toEnd = isAtEnd$1($to, depth + 1);
      if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {
        var from12 = $from.before(depth + 1), to = $to.after(depth + 1);
        if (fromStart && $from.index(depth) > 0) {
          from12 -= $from.node(depth).child($from.index(depth) - 1).nodeSize;
        }
        if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount) {
          to += $to.node(depth).child($to.index(depth) + 1).nodeSize;
        }
        return { from: from12, to };
      }
    }
  }
}
function keyEvent$1(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function readDOMChange$1(view2, mapping, oldState, range, allowTypeOver) {
  var parse16 = parseBetween$1(view2, oldState, range);
  var doc2 = oldState.doc, compare = doc2.slice(parse16.from, parse16.to);
  var preferredPos, preferredSide;
  if (view2.lastKeyCode === 8 && Date.now() - 100 < view2.lastKeyCodeTime) {
    preferredPos = oldState.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = oldState.selection.from;
    preferredSide = "start";
  }
  view2.lastKeyCode = null;
  var change = findDiff$1(compare.content, parse16.doc.content, parse16.from, preferredPos, preferredSide);
  if (!change) {
    if (allowTypeOver) {
      var state = view2.state, sel = state.selection;
      view2.dispatch(state.tr.replaceSelectionWith(state.schema.text(state.doc.textBetween(sel.from, sel.to)), true).scrollIntoView());
    } else if (parse16.sel) {
      var sel$1 = resolveSelection$1(view2, view2.state.doc, mapping, parse16.sel);
      if (sel$1 && !sel$1.eq(view2.state.selection)) {
        view2.dispatch(view2.state.tr.setSelection(sel$1));
      }
    }
    return;
  }
  var $from = parse16.doc.resolveNoCache(change.start - parse16.from);
  var $to = parse16.doc.resolveNoCache(change.endB - parse16.from);
  var nextSel;
  if (!$from.sameParent($to) && $from.pos < parse16.doc.content.size && (nextSel = prosemirrorState$6.Selection.findFrom(parse16.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos && view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, keyEvent$1(13, "Enter"));
  })) {
    return;
  }
  if (oldState.selection.anchor > change.start && looksLikeJoin$1(doc2, change.start, change.endA, $from, $to) && view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, keyEvent$1(8, "Backspace"));
  })) {
    return;
  }
  var from12 = mapping.map(change.start), to = mapping.map(change.endA, -1);
  var tr, storedMarks, markChange, $from1;
  if ($from.sameParent($to) && $from.parent.inlineContent) {
    if ($from.pos == $to.pos) {
      tr = view2.state.tr.delete(from12, to);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange$1(
      $from.parent.content.cut($from.parentOffset, $to.parentOffset),
      $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())
    ))) {
      tr = view2.state.tr;
      if (markChange.type == "add") {
        tr.addMark(from12, to, markChange.mark);
      } else {
        tr.removeMark(from12, to, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text8 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view2.someProp("handleTextInput", function(f2) {
        return f2(view2, from12, to, text8);
      })) {
        return;
      }
      tr = view2.state.tr.insertText(text8, from12, to);
    }
  }
  if (!tr) {
    tr = view2.state.tr.replace(from12, to, parse16.doc.slice(change.start - parse16.from, change.endB - parse16.from));
  }
  if (parse16.sel) {
    var sel$2 = resolveSelection$1(view2, tr.doc, mapping, parse16.sel);
    if (sel$2) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view2.dispatch(tr.scrollIntoView());
}
function resolveSelection$1(view2, doc2, mapping, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween$1(
    view2,
    doc2.resolve(mapping.map(parsedSel.anchor)),
    doc2.resolve(mapping.map(parsedSel.head))
  );
}
function isMarkChange$1(cur, prev2) {
  var curMarks = cur.firstChild.marks, prevMarks = prev2.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark15, update4;
  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }
  for (var i$12 = 0; i$12 < curMarks.length; i$12++) {
    removed = curMarks[i$12].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark15 = added[0];
    type = "add";
    update4 = function(node18) {
      return node18.mark(mark15.addToSet(node18.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark15 = removed[0];
    type = "remove";
    update4 = function(node18) {
      return node18.mark(mark15.removeFromSet(node18.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev2.childCount; i$2++) {
    updated.push(update4(prev2.child(i$2)));
  }
  if (prosemirrorModel$2.Fragment.from(updated).eq(cur)) {
    return { mark: mark15, type };
  }
}
function looksLikeJoin$1(old, start16, end8, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end8 - start16 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening$1($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start16);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening$1($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end8 || skipClosingAndOpening$1($next, true, false) < end8) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening$1($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end8 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end8++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next2 && !next2.isLeaf) {
      next2 = next2.firstChild;
      end8++;
    }
  }
  return end8;
}
function findDiff$1(a, b, pos, preferredPos, preferredSide) {
  var start16 = a.findDiffStart(b, pos);
  if (start16 == null) {
    return null;
  }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start16 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start16;
  }
  if (endA < start16 && a.size < b.size) {
    var move3 = preferredPos <= start16 && preferredPos >= endA ? start16 - preferredPos : 0;
    start16 -= move3;
    endB = start16 + (endB - endA);
    endA = start16;
  } else if (endB < start16) {
    var move$1 = preferredPos <= start16 && preferredPos >= endB ? start16 - preferredPos : 0;
    start16 -= move$1;
    endA = start16 + (endA - endB);
    endB = start16;
  }
  return { start: start16, endA, endB };
}
function serializeForClipboard$1(view2, slice11) {
  var context = [];
  var content2 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node18 = content2.firstChild;
    context.push(node18.type.name, node18.type.hasRequiredAttrs() ? node18.attrs : null);
    content2 = node18.content;
  }
  var serializer = view2.someProp("clipboardSerializer") || prosemirrorModel$2.DOMSerializer.fromSchema(view2.state.schema);
  var wrap2 = document.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content2));
  var firstChild = wrap2.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap$1[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = document.createElement(needsWrap[i]);
      while (wrap2.firstChild) {
        wrapper.appendChild(wrap2.firstChild);
      }
      wrap2.appendChild(wrapper);
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text8 = view2.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice11);
  }) || slice11.content.textBetween(0, slice11.content.size, "\n\n");
  return { dom: wrap2, text: text8 };
}
function parseFromClipboard$1(view2, text8, html2, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice11;
  if (!html2 && !text8) {
    return null;
  }
  if ((plainText || inCode || !html2) && text8) {
    view2.someProp("transformPastedText", function(f2) {
      text8 = f2(text8);
    });
    if (inCode) {
      return new prosemirrorModel$2.Slice(prosemirrorModel$2.Fragment.from(view2.state.schema.text(text8)), 0, 0);
    }
    var parsed = view2.someProp("clipboardTextParser", function(f2) {
      return f2(text8, $context);
    });
    if (parsed) {
      slice11 = parsed;
    } else {
      dom = document.createElement("div");
      text8.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
        dom.appendChild(document.createElement("p")).textContent = block;
      });
    }
  } else {
    view2.someProp("transformPastedHTML", function(f2) {
      return html2 = f2(html2);
    });
    dom = readHTML$1(html2);
  }
  if (!slice11) {
    var parser = view2.someProp("clipboardParser") || view2.someProp("domParser") || prosemirrorModel$2.DOMParser.fromSchema(view2.state.schema);
    slice11 = parser.parseSlice(dom, { preserveWhitespace: true, context: $context });
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (sliceData) {
    slice11 = addContext$1(new prosemirrorModel$2.Slice(
      slice11.content,
      Math.min(slice11.openStart, +sliceData[1]),
      Math.min(slice11.openEnd, +sliceData[2])
    ), sliceData[3]);
  } else {
    slice11 = prosemirrorModel$2.Slice.maxOpen(normalizeSiblings$1(slice11.content, $context), false);
  }
  view2.someProp("transformPasted", function(f2) {
    slice11 = f2(slice11);
  });
  return slice11;
}
function normalizeSiblings$1(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d2) {
    var parent = $context.node(d2);
    var match2 = parent.contentMatchAt($context.index(d2));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node18) {
      if (!result2) {
        return;
      }
      var wrap2 = match2.findWrapping(node18.type), inLast;
      if (!wrap2) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling$1(wrap2, lastWrap, node18, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight$1(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers$1(node18, wrap2);
        result2.push(wrapped);
        match2 = match2.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap2;
      }
    });
    if (result2) {
      return { v: prosemirrorModel$2.Fragment.from(result2) };
    }
  };
  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop(d);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers$1(node18, wrap2, from12) {
  if (from12 === void 0)
    from12 = 0;
  for (var i = wrap2.length - 1; i >= from12; i--) {
    node18 = wrap2[i].create(null, prosemirrorModel$2.Fragment.from(node18));
  }
  return node18;
}
function addToSibling$1(wrap2, lastWrap, node18, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    var inner = addToSibling$1(wrap2, lastWrap, node18, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node18.type : wrap2[depth + 1])) {
      return sibling.copy(sibling.content.append(prosemirrorModel$2.Fragment.from(withWrappers$1(node18, wrap2, depth + 1))));
    }
  }
}
function closeRight$1(node18, depth) {
  if (depth == 0) {
    return node18;
  }
  var fragment = node18.content.replaceChild(node18.childCount - 1, closeRight$1(node18.lastChild, depth - 1));
  var fill = node18.contentMatchAt(node18.childCount).fillBefore(prosemirrorModel$2.Fragment.empty, true);
  return node18.copy(fragment.append(fill));
}
var wrapMap$1 = {
  thead: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var detachedDoc$1 = null;
function readHTML$1(html2) {
  var metas = /(\s*<meta [^>]*>)*/.exec(html2);
  if (metas) {
    html2 = html2.slice(metas[0].length);
  }
  var doc2 = detachedDoc$1 || (detachedDoc$1 = document.implementation.createHTMLDocument("title"));
  var elt = doc2.createElement("div");
  var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(html2), wrap2, depth = 0;
  if (wrap2 = firstTag && wrapMap$1[firstTag[1].toLowerCase()]) {
    html2 = wrap2.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html2 + wrap2.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
    depth = wrap2.length;
  }
  elt.innerHTML = html2;
  for (var i = 0; i < depth; i++) {
    elt = elt.firstChild;
  }
  return elt;
}
function addContext$1(slice11, context) {
  if (!slice11.size) {
    return slice11;
  }
  var schema2 = slice11.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice11;
  }
  var content2 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema2.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content2 = prosemirrorModel$2.Fragment.from(type.create(array[i + 1], content2));
    openStart++;
    openEnd++;
  }
  return new prosemirrorModel$2.Slice(content2, openStart, openEnd);
}
var observeOptions$1 = { childList: true, characterData: true, attributes: true, subtree: true, characterDataOldValue: true };
var useCharData$1 = result$1.ie && result$1.ie_version <= 11;
var DOMObserver$1 = function DOMObserver(view2) {
  var this$1$1 = this;
  this.view = view2;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    return this$1$1.registerMutations(mutations);
  });
  if (useCharData$1) {
    this.onCharData = function(e) {
      return this$1$1.registerMutation({ target: e.target, type: "characterData", oldValue: e.prevValue });
    };
  }
};
DOMObserver$1.prototype.start = function start9() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions$1);
  }
  if (useCharData$1) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
};
DOMObserver$1.prototype.stop = function stop3() {
  if (this.observer) {
    this.flush();
    this.observer.disconnect();
  }
  if (useCharData$1) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
};
DOMObserver$1.prototype.flush = function flush() {
  if (this.observer) {
    this.registerMutations(this.observer.takeRecords());
  }
};
DOMObserver$1.prototype.registerMutations = function registerMutations(mutations) {
  var this$1$1 = this;
  for (var i = 0; i < mutations.length; i++) {
    this$1$1.registerMutation(mutations[i]);
  }
};
DOMObserver$1.prototype.registerMutation = function registerMutation(mut) {
  if (!this.view.editable) {
    return;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable")) {
    return;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return;
  }
  var from12, to;
  if (mut.type == "childList") {
    var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target ? domIndex$1(mut.previousSibling) + 1 : 0;
    if (fromOffset == -1) {
      return;
    }
    from12 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target ? domIndex$1(mut.nextSibling) : mut.target.childNodes.length;
    if (toOffset == -1) {
      return;
    }
    to = desc.localPosFromDOM(mut.target, toOffset, 1);
  } else if (mut.type == "attributes") {
    from12 = desc.posAtStart - desc.border;
    to = desc.posAtEnd + desc.border;
  } else {
    from12 = desc.posAtStart;
    to = desc.posAtEnd;
    if (mut.target.nodeValue == mut.oldValue) {
      DOMChange$1.start(this.view).typeOver = true;
    }
  }
  DOMChange$1.start(this.view).addRange(from12, to);
};
var handlers$1 = {};
var editHandlers$1 = {};
function initInput$1(view2) {
  view2.shiftKey = false;
  view2.mouseDown = null;
  view2.inDOMChange = null;
  view2.lastKeyCode = null;
  view2.lastKeyCodeTime = 0;
  view2.domObserver = new DOMObserver$1(view2);
  view2.domObserver.start();
  view2.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers$1[event2];
    view2.dom.addEventListener(event2, view2.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView$1(view2, event3) && !runCustomHandler$1(view2, event3) && (view2.editable || !(event3.type in editHandlers$1))) {
        handler(view2, event3);
      }
    });
  };
  for (var event in handlers$1)
    loop(event);
  ensureListeners$1(view2);
}
function destroyInput$1(view2) {
  view2.domObserver.stop();
  if (view2.inDOMChange) {
    view2.inDOMChange.destroy();
  }
  for (var type in view2.eventHandlers) {
    view2.dom.removeEventListener(type, view2.eventHandlers[type]);
  }
}
function ensureListeners$1(view2) {
  view2.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view2.eventHandlers[type]) {
        view2.dom.addEventListener(type, view2.eventHandlers[type] = function(event) {
          return runCustomHandler$1(view2, event);
        });
      }
    }
  });
}
function runCustomHandler$1(view2, event) {
  return view2.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view2, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView$1(view2, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node18 = event.target; node18 != view2.dom; node18 = node18.parentNode) {
    if (!node18 || node18.nodeType == 11 || node18.pmViewDesc && node18.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent$1(view2, event) {
  if (!runCustomHandler$1(view2, event) && handlers$1[event.type] && (view2.editable || !(event.type in editHandlers$1))) {
    handlers$1[event.type](view2, event);
  }
}
editHandlers$1.keydown = function(view2, event) {
  if (event.keyCode == 16) {
    view2.shiftKey = true;
  }
  if (view2.inDOMChange) {
    return;
  }
  view2.lastKeyCode = event.keyCode;
  view2.lastKeyCodeTime = Date.now();
  if (view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, event);
  }) || captureKeyDown$1(view2, event)) {
    event.preventDefault();
  } else {
    view2.selectionReader.poll();
  }
};
editHandlers$1.keyup = function(view2, e) {
  if (e.keyCode == 16) {
    view2.shiftKey = false;
  }
};
editHandlers$1.keypress = function(view2, event) {
  if (view2.inDOMChange || !event.charCode || event.ctrlKey && !event.altKey || result$1.mac && event.metaKey) {
    return;
  }
  if (view2.someProp("handleKeyPress", function(f2) {
    return f2(view2, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view2.state.selection;
  if (!(sel instanceof prosemirrorState$6.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text8 = String.fromCharCode(event.charCode);
    if (!view2.someProp("handleTextInput", function(f2) {
      return f2(view2, sel.$from.pos, sel.$to.pos, text8);
    })) {
      view2.dispatch(view2.state.tr.insertText(text8).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords$1(event) {
  return { left: event.clientX, top: event.clientY };
}
var lastClick$1 = { time: 0, x: 0, y: 0 };
var oneButLastClick$1 = lastClick$1;
function isNear$1(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext$1(view2, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view2.state.doc.resolve(inside);
  var loop = function(i2) {
    if (view2.someProp(propName, function(f2) {
      return i2 > $pos.depth ? f2(view2, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f2(view2, pos, $pos.node(i2), $pos.before(i2), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop(i);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection$1(view2, selection, origin) {
  if (!view2.focused) {
    view2.focus();
  }
  var tr = view2.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view2.dispatch(tr);
}
function selectClickedLeaf$1(view2, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view2.state.doc.resolve(inside), node18 = $pos.nodeAfter;
  if (node18 && node18.isAtom && prosemirrorState$6.NodeSelection.isSelectable(node18)) {
    updateSelection$1(view2, new prosemirrorState$6.NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode$1(view2, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view2.state.selection, selectedNode, selectAt;
  if (sel instanceof prosemirrorState$6.NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view2.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirrorState$6.NodeSelection.isSelectable(node18)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection$1(view2, prosemirrorState$6.NodeSelection.create(view2.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick$1(view2, pos, inside, event, selectNode) {
  return runHandlerOnContext$1(view2, "handleClickOn", pos, inside, event) || view2.someProp("handleClick", function(f2) {
    return f2(view2, pos, event);
  }) || (selectNode ? selectClickedNode$1(view2, inside) : selectClickedLeaf$1(view2, inside));
}
function handleDoubleClick$1(view2, pos, inside, event) {
  return runHandlerOnContext$1(view2, "handleDoubleClickOn", pos, inside, event) || view2.someProp("handleDoubleClick", function(f2) {
    return f2(view2, pos, event);
  });
}
function handleTripleClick$1(view2, pos, inside, event) {
  return runHandlerOnContext$1(view2, "handleTripleClickOn", pos, inside, event) || view2.someProp("handleTripleClick", function(f2) {
    return f2(view2, pos, event);
  }) || defaultTripleClick$1(view2, inside);
}
function defaultTripleClick$1(view2, inside) {
  var doc2 = view2.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection$1(view2, prosemirrorState$6.TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node18.inlineContent) {
      updateSelection$1(view2, prosemirrorState$6.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node18.content.size), "pointer");
    } else if (prosemirrorState$6.NodeSelection.isSelectable(node18)) {
      updateSelection$1(view2, prosemirrorState$6.NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush$1(view2) {
  if (!view2.inDOMChange) {
    return false;
  }
  view2.inDOMChange.finish(true);
  return true;
}
var selectNodeModifier$1 = result$1.mac ? "metaKey" : "ctrlKey";
handlers$1.mousedown = function(view2, event) {
  var flushed = forceDOMFlush$1(view2);
  var now2 = Date.now(), type;
  if (now2 - lastClick$1.time >= 500 || !isNear$1(event, lastClick$1) || event[selectNodeModifier$1]) {
    type = "singleClick";
  } else if (now2 - oneButLastClick$1.time >= 600 || !isNear$1(event, oneButLastClick$1)) {
    type = "doubleClick";
  } else {
    type = "tripleClick";
  }
  oneButLastClick$1 = lastClick$1;
  lastClick$1 = { time: now2, x: event.clientX, y: event.clientY };
  var pos = view2.posAtCoords(eventCoords$1(event));
  if (!pos) {
    return;
  }
  if (type == "singleClick") {
    view2.mouseDown = new MouseDown$1(view2, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick$1 : handleTripleClick$1)(view2, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    view2.selectionReader.poll("pointer");
  }
};
var MouseDown$1 = function MouseDown(view2, pos, event, flushed) {
  var this$1$1 = this;
  this.view = view2;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier$1];
  this.allowDefault = event.shiftKey;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view2.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view2.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  this.target = flushed ? null : event.target;
  if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || view2.state.selection instanceof prosemirrorState$6.NodeSelection && targetPos == view2.state.selection.from) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result$1.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        return this$1$1.target.setAttribute("contentEditable", "false");
      }, 20);
    }
    this.view.domObserver.start();
  }
  view2.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view2.root.addEventListener("mousemove", this.move = this.move.bind(this));
  view2.selectionReader.poll("pointer");
};
MouseDown$1.prototype.done = function done() {
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = false;
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  this.view.mouseDown = null;
};
MouseDown$1.prototype.up = function up(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  if (this.allowDefault) {
    this.view.selectionReader.poll("pointer");
  } else if (handleSingleClick$1(this.view, this.pos.pos, this.pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (this.flushed) {
    updateSelection$1(this.view, prosemirrorState$6.Selection.near(this.view.state.doc.resolve(this.pos.pos)), "pointer");
    event.preventDefault();
  } else {
    this.view.selectionReader.poll("pointer");
  }
};
MouseDown$1.prototype.move = function move(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  this.view.selectionReader.poll("pointer");
};
handlers$1.touchdown = function(view2) {
  forceDOMFlush$1(view2);
  view2.selectionReader.poll("pointer");
};
handlers$1.contextmenu = function(view2) {
  return forceDOMFlush$1(view2);
};
editHandlers$1.compositionstart = editHandlers$1.compositionupdate = function(view2) {
  DOMChange$1.start(view2, true);
};
editHandlers$1.compositionend = function(view2, e) {
  if (!view2.inDOMChange) {
    if (e.data) {
      DOMChange$1.start(view2, true);
    } else {
      return;
    }
  }
  view2.inDOMChange.compositionEnd();
};
editHandlers$1.input = function(view2) {
  var change = DOMChange$1.start(view2);
  if (!change.composing) {
    change.finish();
  }
};
function captureCopy$1(view2, dom) {
  var doc2 = dom.ownerDocument;
  var wrap2 = doc2.body.appendChild(doc2.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = doc2.createRange();
  range.selectNodeContents(dom);
  view2.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    doc2.body.removeChild(wrap2);
    view2.focus();
  }, 50);
}
var brokenClipboardAPI$1 = result$1.ie && result$1.ie_version < 15 || result$1.ios;
handlers$1.copy = editHandlers$1.cut = function(view2, e) {
  var sel = view2.state.selection, cut15 = e.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI$1 ? null : e.clipboardData;
  var slice11 = sel.content();
  var ref = serializeForClipboard$1(view2, slice11);
  var dom = ref.dom;
  var text8 = ref.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text8);
  } else {
    captureCopy$1(view2, dom);
  }
  if (cut15) {
    view2.dispatch(view2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode$1(slice11) {
  return slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1 ? slice11.content.firstChild : null;
}
function capturePaste$1(view2, e) {
  var doc2 = view2.dom.ownerDocument;
  var plainText = view2.shiftKey || view2.state.selection.$from.parent.type.spec.code;
  var target = doc2.body.appendChild(doc2.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view2.focus();
    doc2.body.removeChild(target);
    if (plainText) {
      doPaste$1(view2, target.value, null, e);
    } else {
      doPaste$1(view2, target.textContent, target.innerHTML, e);
    }
  }, 50);
}
function doPaste$1(view2, text8, html2, e) {
  var slice11 = parseFromClipboard$1(view2, text8, html2, view2.shiftKey, view2.state.selection.$from);
  if (!slice11) {
    return false;
  }
  if (view2.someProp("handlePaste", function(f2) {
    return f2(view2, e, slice11);
  })) {
    return true;
  }
  var singleNode = sliceSingleNode$1(slice11);
  var tr = singleNode ? view2.state.tr.replaceSelectionWith(singleNode, view2.shiftKey) : view2.state.tr.replaceSelection(slice11);
  view2.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers$1.paste = function(view2, e) {
  var data = brokenClipboardAPI$1 ? null : e.clipboardData;
  if (data && doPaste$1(view2, data.getData("text/plain"), data.getData("text/html"), e)) {
    e.preventDefault();
  } else {
    capturePaste$1(view2, e);
  }
};
var Dragging$1 = function Dragging(slice11, move3) {
  this.slice = slice11;
  this.move = move3;
};
function dropPos$2(slice11, $pos) {
  if (!slice11 || !slice11.content.size) {
    return $pos.pos;
  }
  var content2 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content2 = content2.firstChild.content;
  }
  for (var d = $pos.depth; d >= 0; d--) {
    var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
    if ($pos.node(d).canReplace(insertPos, insertPos, content2)) {
      return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return $pos.pos;
}
var dragCopyModifier$1 = result$1.mac ? "altKey" : "ctrlKey";
handlers$1.dragstart = function(view2, e) {
  var mouseDown = view2.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e.dataTransfer) {
    return;
  }
  var sel = view2.state.selection;
  var pos = sel.empty ? null : view2.posAtCoords(eventCoords$1(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState$6.NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view2.dispatch(view2.state.tr.setSelection(prosemirrorState$6.NodeSelection.create(view2.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view2.docView.nearestDesc(e.target, true);
    if (!desc || !desc.node.type.spec.draggable || desc == view2.docView) {
      return;
    }
    view2.dispatch(view2.state.tr.setSelection(prosemirrorState$6.NodeSelection.create(view2.state.doc, desc.posBefore)));
  }
  var slice11 = view2.state.selection.content();
  var ref = serializeForClipboard$1(view2, slice11);
  var dom = ref.dom;
  var text8 = ref.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI$1 ? "Text" : "text/html", dom.innerHTML);
  if (!brokenClipboardAPI$1) {
    e.dataTransfer.setData("text/plain", text8);
  }
  view2.dragging = new Dragging$1(slice11, !e[dragCopyModifier$1]);
};
handlers$1.dragend = function(view2) {
  window.setTimeout(function() {
    return view2.dragging = null;
  }, 50);
};
editHandlers$1.dragover = editHandlers$1.dragenter = function(_, e) {
  return e.preventDefault();
};
editHandlers$1.drop = function(view2, e) {
  var dragging = view2.dragging;
  view2.dragging = null;
  if (!e.dataTransfer) {
    return;
  }
  var eventPos = view2.posAtCoords(eventCoords$1(e));
  if (!eventPos) {
    return;
  }
  var $mouse = view2.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice11 = dragging && dragging.slice || parseFromClipboard$1(
    view2,
    e.dataTransfer.getData(brokenClipboardAPI$1 ? "Text" : "text/plain"),
    brokenClipboardAPI$1 ? null : e.dataTransfer.getData("text/html"),
    false,
    $mouse
  );
  if (!slice11) {
    return;
  }
  e.preventDefault();
  if (view2.someProp("handleDrop", function(f2) {
    return f2(view2, e, slice11, dragging && dragging.move);
  })) {
    return;
  }
  var insertPos = dropPos$2(slice11, view2.state.doc.resolve($mouse.pos));
  var tr = view2.state.tr;
  if (dragging && dragging.move) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode2 = slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode2) {
    tr.replaceRangeWith(pos, pos, slice11.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice11);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode2 && prosemirrorState$6.NodeSelection.isSelectable(slice11.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice11.content.firstChild)) {
    tr.setSelection(new prosemirrorState$6.NodeSelection($pos));
  } else {
    tr.setSelection(selectionBetween$1(view2, $pos, tr.doc.resolve(tr.mapping.map(insertPos))));
  }
  view2.focus();
  view2.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers$1.focus = function(view2) {
  if (!view2.focused) {
    view2.dom.classList.add("ProseMirror-focused");
    view2.focused = true;
  }
};
handlers$1.blur = function(view2) {
  if (view2.focused) {
    view2.dom.classList.remove("ProseMirror-focused");
    view2.focused = false;
  }
};
for (var prop$1 in editHandlers$1) {
  handlers$1[prop$1] = editHandlers$1[prop$1];
}
function compareObjs$1(a, b) {
  if (a == b) {
    return true;
  }
  for (var p2 in a) {
    if (a[p2] !== b[p2]) {
      return false;
    }
  }
  for (var p$12 in b) {
    if (!(p$12 in a)) {
      return false;
    }
  }
  return true;
}
var WidgetType$1 = function WidgetType(widget3, spec) {
  this.spec = spec || noSpec$1;
  this.side = this.spec.side || 0;
  if (!this.spec.raw) {
    if (widget3.nodeType != 1) {
      var wrap2 = document.createElement("span");
      wrap2.appendChild(widget3);
      widget3 = wrap2;
    }
    widget3.contentEditable = false;
    widget3.classList.add("ProseMirror-widget");
  }
  this.widget = widget3;
};
WidgetType$1.prototype.map = function map8(mapping, span, offset2, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref.pos;
  var deleted = ref.deleted;
  return deleted ? null : new Decoration$1(pos - offset2, pos - offset2, this);
};
WidgetType$1.prototype.valid = function valid() {
  return true;
};
WidgetType$1.prototype.eq = function eq21(other) {
  return this == other || other instanceof WidgetType$1 && (this.widget == other.widget || this.spec.key) && compareObjs$1(this.spec, other.spec);
};
var InlineType$1 = function InlineType(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
InlineType$1.prototype.map = function map9(mapping, span, offset2, oldOffset) {
  var from12 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
  return from12 >= to ? null : new Decoration$1(from12, to, this);
};
InlineType$1.prototype.valid = function valid2(_, span) {
  return span.from < span.to;
};
InlineType$1.prototype.eq = function eq22(other) {
  return this == other || other instanceof InlineType$1 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
InlineType$1.is = function is(span) {
  return span.type instanceof InlineType$1;
};
var NodeType$3 = function NodeType6(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
NodeType$3.prototype.map = function map10(mapping, span, offset2, oldOffset) {
  var from12 = mapping.mapResult(span.from + oldOffset, 1);
  if (from12.deleted) {
    return null;
  }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from12.pos) {
    return null;
  }
  return new Decoration$1(from12.pos - offset2, to.pos - offset2, this);
};
NodeType$3.prototype.valid = function valid3(node18, span) {
  var ref = node18.content.findIndex(span.from);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return offset2 == span.from && offset2 + node18.child(index8).nodeSize == span.to;
};
NodeType$3.prototype.eq = function eq23(other) {
  return this == other || other instanceof NodeType$3 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
var Decoration$1 = function Decoration(from12, to, type) {
  this.from = from12;
  this.to = to;
  this.type = type;
};
var prototypeAccessors$2$3 = { spec: {} };
Decoration$1.prototype.copy = function copy7(from12, to) {
  return new Decoration$1(from12, to, this.type);
};
Decoration$1.prototype.eq = function eq24(other) {
  return this.type.eq(other.type) && this.from == other.from && this.to == other.to;
};
Decoration$1.prototype.map = function map11(mapping, offset2, oldOffset) {
  return this.type.map(mapping, this, offset2, oldOffset);
};
Decoration$1.widget = function widget(pos, dom, spec) {
  return new Decoration$1(pos, pos, new WidgetType$1(dom, spec));
};
Decoration$1.inline = function inline(from12, to, attrs, spec) {
  return new Decoration$1(from12, to, new InlineType$1(attrs, spec));
};
Decoration$1.node = function node11(from12, to, attrs, spec) {
  return new Decoration$1(from12, to, new NodeType$3(attrs, spec));
};
prototypeAccessors$2$3.spec.get = function() {
  return this.type.spec;
};
Object.defineProperties(Decoration$1.prototype, prototypeAccessors$2$3);
var none$1 = [];
var noSpec$1 = {};
var DecorationSet$1 = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none$1;
  this.children = children && children.length ? children : none$1;
};
DecorationSet$1.create = function create12(doc2, decorations) {
  return decorations.length ? buildTree$1(decorations, doc2, 0, noSpec$1) : empty$1;
};
DecorationSet$1.prototype.find = function find2(start16, end8, predicate) {
  var result2 = [];
  this.findInner(start16 == null ? 0 : start16, end8 == null ? 1e9 : end8, result2, 0, predicate);
  return result2;
};
DecorationSet$1.prototype.findInner = function findInner(start16, end8, result2, offset2, predicate) {
  var this$1$1 = this;
  for (var i = 0; i < this.local.length; i++) {
    var span = this$1$1.local[i];
    if (span.from <= end8 && span.to >= start16 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
  }
  for (var i$12 = 0; i$12 < this.children.length; i$12 += 3) {
    if (this$1$1.children[i$12] < end8 && this$1$1.children[i$12 + 1] > start16) {
      var childOff = this$1$1.children[i$12] + 1;
      this$1$1.children[i$12 + 2].findInner(start16 - childOff, end8 - childOff, result2, offset2 + childOff, predicate);
    }
  }
};
DecorationSet$1.prototype.map = function map12(mapping, doc2, options) {
  if (this == empty$1 || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec$1);
};
DecorationSet$1.prototype.mapInner = function mapInner(mapping, node18, offset2, oldOffset, options) {
  var this$1$1 = this;
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this$1$1.local[i].map(mapping, offset2, oldOffset);
    if (mapped && mapped.type.valid(node18, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this$1$1.local[i].spec);
    }
  }
  if (this.children.length) {
    return mapChildren$1(this.children, newLocal, mapping, node18, offset2, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet$1(newLocal.sort(byPos$1)) : empty$1;
  }
};
DecorationSet$1.prototype.add = function add2(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty$1) {
    return DecorationSet$1.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet$1.prototype.addInner = function addInner(doc2, decorations, offset2) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset2, found2;
    if (!(found2 = takeSpansForNode$1(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree$1(found2, childNode, baseOffset + 1, noSpec$1));
    }
    childIndex += 3;
  });
  var local = moveSpans$1(childIndex ? withoutNulls$1(decorations) : decorations, -offset2);
  return new DecorationSet$1(
    local.length ? this.local.concat(local).sort(byPos$1) : this.local,
    children || this.children
  );
};
DecorationSet$1.prototype.remove = function remove(decorations) {
  if (decorations.length == 0 || this == empty$1) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet$1.prototype.removeInner = function removeInner(decorations, offset2) {
  var this$1$1 = this;
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found2 = void 0, from12 = children[i] + offset2, to = children[i + 1] + offset2;
    for (var j = 0, span = void 0; j < decorations.length; j++) {
      if (span = decorations[j]) {
        if (span.from > from12 && span.to < to) {
          decorations[j] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this$1$1.children) {
      children = this$1$1.children.slice();
    }
    var removed = children[i + 2].removeInner(found2, from12 + 1);
    if (removed != empty$1) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) {
    for (var i$12 = 0, span$1 = void 0; i$12 < decorations.length; i$12++) {
      if (span$1 = decorations[i$12]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].type.eq(span$1.type)) {
            if (local == this$1$1.local) {
              local = this$1$1.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet$1(local, children) : empty$1;
};
DecorationSet$1.prototype.forChild = function forChild(offset2, node18) {
  var this$1$1 = this;
  if (this == empty$1) {
    return this;
  }
  if (node18.isLeaf) {
    return DecorationSet$1.empty;
  }
  var child15, local;
  for (var i = 0; i < this.children.length; i += 3) {
    if (this$1$1.children[i] >= offset2) {
      if (this$1$1.children[i] == offset2) {
        child15 = this$1$1.children[i + 2];
      }
      break;
    }
  }
  var start16 = offset2 + 1, end8 = start16 + node18.content.size;
  for (var i$12 = 0; i$12 < this.local.length; i$12++) {
    var dec = this$1$1.local[i$12];
    if (dec.from < end8 && dec.to > start16 && dec.type instanceof InlineType$1) {
      var from12 = Math.max(start16, dec.from) - start16, to = Math.min(end8, dec.to) - start16;
      if (from12 < to) {
        (local || (local = [])).push(dec.copy(from12, to));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet$1(local.sort(byPos$1));
    return child15 ? new DecorationGroup$1([localSet, child15]) : localSet;
  }
  return child15 || empty$1;
};
DecorationSet$1.prototype.eq = function eq25(other) {
  var this$1$1 = this;
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet$1) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i = 0; i < this.local.length; i++) {
    if (!this$1$1.local[i].eq(other.local[i])) {
      return false;
    }
  }
  for (var i$12 = 0; i$12 < this.children.length; i$12 += 3) {
    if (this$1$1.children[i$12] != other.children[i$12] || this$1$1.children[i$12 + 1] != other.children[i$12 + 1] || !this$1$1.children[i$12 + 2].eq(other.children[i$12 + 2])) {
      return false;
    }
  }
  return false;
};
DecorationSet$1.prototype.locals = function locals(node18) {
  return removeOverlap$1(this.localsInner(node18));
};
DecorationSet$1.prototype.localsInner = function localsInner(node18) {
  var this$1$1 = this;
  if (this == empty$1) {
    return none$1;
  }
  if (node18.inlineContent || !this.local.some(InlineType$1.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this$1$1.local[i].type instanceof InlineType$1)) {
      result2.push(this$1$1.local[i]);
    }
  }
  return result2;
};
var empty$1 = new DecorationSet$1();
DecorationSet$1.empty = empty$1;
DecorationSet$1.removeOverlap = removeOverlap$1;
var DecorationGroup$1 = function DecorationGroup(members) {
  this.members = members;
};
DecorationGroup$1.prototype.forChild = function forChild2(offset2, child15) {
  var this$1$1 = this;
  if (child15.isLeaf) {
    return DecorationSet$1.empty;
  }
  var found2 = [];
  for (var i = 0; i < this.members.length; i++) {
    var result2 = this$1$1.members[i].forChild(offset2, child15);
    if (result2 == empty$1) {
      continue;
    }
    if (result2 instanceof DecorationGroup$1) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup$1.from(found2);
};
DecorationGroup$1.prototype.eq = function eq26(other) {
  var this$1$1 = this;
  if (!(other instanceof DecorationGroup$1) || other.members.length != this.members.length) {
    return false;
  }
  for (var i = 0; i < this.members.length; i++) {
    if (!this$1$1.members[i].eq(other.members[i])) {
      return false;
    }
  }
  return true;
};
DecorationGroup$1.prototype.locals = function locals2(node18) {
  var this$1$1 = this;
  var result2, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals5 = this$1$1.members[i].localsInner(node18);
    if (!locals5.length) {
      continue;
    }
    if (!result2) {
      result2 = locals5;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j = 0; j < locals5.length; j++) {
        result2.push(locals5[j]);
      }
    }
  }
  return result2 ? removeOverlap$1(sorted ? result2 : result2.sort(byPos$1)) : none$1;
};
DecorationGroup$1.from = function from7(members) {
  switch (members.length) {
    case 0:
      return empty$1;
    case 1:
      return members[0];
    default:
      return new DecorationGroup$1(members);
  }
};
function mapChildren$1(oldChildren, newLocal, mapping, node18, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i2 = 0; i2 < children.length; i2 += 3) {
      var end8 = children[i2 + 1], dSize = void 0;
      if (end8 == -1 || oldStart > end8 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i2] + oldOffset) {
        children[i2 + 1] = -1;
      } else if (dSize = newEnd - newStart - (oldEnd - oldStart) + (oldOffset - offset2)) {
        children[i2] += dSize;
        children[i2 + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$12 = 0; i$12 < children.length; i$12 += 3) {
    if (children[i$12 + 1] == -1) {
      var from12 = mapping.map(children[i$12] + oldOffset), fromLocal = from12 - offset2;
      if (fromLocal < 0 || fromLocal >= node18.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$12 + 1] + oldOffset, -1), toLocal = to - offset2;
      var ref = node18.content.findIndex(fromLocal);
      var index8 = ref.index;
      var childOffset = ref.offset;
      var childNode = node18.maybeChild(index8);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$12 + 2].mapInner(mapping, childNode, from12 + 1, children[i$12] + oldOffset + 1, options);
        if (mapped != empty$1) {
          children[i$12] = fromLocal;
          children[i$12 + 1] = toLocal;
          children[i$12 + 2] = mapped;
        } else {
          children.splice(i$12, 3);
          i$12 -= 3;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations$1(
      children,
      newLocal ? moveSpans$1(newLocal, offset2) : [],
      mapping,
      offset2,
      oldOffset,
      options
    );
    var built = buildTree$1(decorations, node18, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] == -1) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet$1(newLocal && newLocal.sort(byPos$1), children);
}
function moveSpans$1(spans, offset2) {
  if (!offset2 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result2.push(new Decoration$1(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations$1(children, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (var i2 = 0; i2 < set.local.length; i2++) {
      var mapped = set.local[i2].map(mapping, offset2, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set.local[i2].spec);
      }
    }
    for (var i$12 = 0; i$12 < set.children.length; i$12 += 3) {
      gather(set.children[i$12 + 2], set.children[i$12] + oldOffset2 + 1);
    }
  }
  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) {
      gather(children[i + 2], children[i] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode$1(spans, node18, offset2) {
  if (node18.isLeaf) {
    return null;
  }
  var end8 = offset2 + node18.nodeSize, found2 = null;
  for (var i = 0, span = void 0; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end8) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls$1(array) {
  var result2 = [];
  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) {
      result2.push(array[i]);
    }
  }
  return result2;
}
function buildTree$1(spans, node18, offset2, options) {
  var children = [], hasNulls = false;
  node18.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode$1(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree$1(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty$1) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals5 = moveSpans$1(hasNulls ? withoutNulls$1(spans) : spans, -offset2).sort(byPos$1);
  for (var i = 0; i < locals5.length; i++) {
    if (!locals5[i].type.valid(node18, locals5[i])) {
      if (options.onRemove) {
        options.onRemove(locals5[i].spec);
      }
      locals5.splice(i--, 1);
    }
  }
  return locals5.length || children.length ? new DecorationSet$1(locals5, children) : empty$1;
}
function byPos$1(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap$1(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) {
      for (var j = i + 1; j < working.length; j++) {
        var next2 = working[j];
        if (next2.from == span.from) {
          if (next2.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next2.copy(next2.from, span.to);
            insertAhead$1(working, j + 1, next2.copy(span.to, next2.to));
          }
          continue;
        } else {
          if (next2.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i] = span.copy(span.from, next2.from);
            insertAhead$1(working, j, span.copy(next2.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead$1(array, i, deco) {
  while (i < array.length && byPos$1(deco, array[i]) > 0) {
    i++;
  }
  array.splice(i, 0, deco);
}
function viewDecorations$1(view2) {
  var found2 = [];
  view2.someProp("decorations", function(f2) {
    var result2 = f2(view2.state);
    if (result2 && result2 != empty$1) {
      found2.push(result2);
    }
  });
  if (view2.cursorWrapper) {
    found2.push(DecorationSet$1.create(view2.state.doc, [view2.cursorWrapper]));
  }
  return DecorationGroup$1.from(found2);
}
var EditorView$1 = function EditorView(place, props) {
  this._props = props;
  this.state = props.state;
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable$1(this);
  this.cursorWrapper = null;
  updateCursorWrapper$1(this);
  this.docView = docViewDesc$1(this.state.doc, computeDocDeco$1(this), viewDecorations$1(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput$1(this);
  this.selectionReader = new SelectionReader$1(this);
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$9 = { props: {}, root: {} };
prototypeAccessors$9.props.get = function() {
  var this$1$1 = this;
  if (this._props.state != this.state) {
    var prev2 = this._props;
    this._props = {};
    for (var name in prev2) {
      this$1$1._props[name] = prev2[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView$1.prototype.update = function update(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners$1(this);
  }
  this._props = props;
  this.updateState(props.state);
};
EditorView$1.prototype.setProps = function setProps(props) {
  var this$1$1 = this;
  var updated = {};
  for (var name in this$1$1._props) {
    updated[name] = this$1$1._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView$1.prototype.updateState = function updateState(state) {
  var this$1$1 = this;
  var prev2 = this.state;
  this.state = state;
  if (prev2.plugins != state.plugins) {
    ensureListeners$1(this);
  }
  this.domObserver.flush();
  if (this.inDOMChange && this.inDOMChange.stateUpdated(state)) {
    return;
  }
  var prevEditable = this.editable;
  this.editable = getEditable$1(this);
  updateCursorWrapper$1(this);
  var innerDeco = viewDecorations$1(this), outerDeco = computeDocDeco$1(this);
  var scroll = prev2.config != state.config ? "reset" : state.scrollToSelection > prev2.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  var updateSel = updateDoc || !state.selection.eq(prev2.selection) || this.selectionReader.domChanged();
  var oldScrollPos = scroll == "preserve" && updateSel && storeScrollPos$1(this);
  if (updateSel) {
    this.domObserver.stop();
    if (updateDoc) {
      if (!this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.destroy();
        this.docView = docViewDesc$1(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      this.selectionReader.clearDOMState();
    }
    selectionToDOM$1(this);
    this.domObserver.start();
  }
  if (prevEditable != this.editable) {
    this.selectionReader.editableChanged();
  }
  this.updatePluginViews(prev2);
  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof prosemirrorState$6.NodeSelection) {
      scrollRectIntoView$1(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect());
    } else {
      scrollRectIntoView$1(this, this.coordsAtPos(state.selection.head));
    }
  } else if (oldScrollPos) {
    resetScrollPos$1(oldScrollPos);
  }
};
EditorView$1.prototype.destroyPluginViews = function destroyPluginViews() {
  var view2;
  while (view2 = this.pluginViews.pop()) {
    if (view2.destroy) {
      view2.destroy();
    }
  }
};
EditorView$1.prototype.updatePluginViews = function updatePluginViews(prevState) {
  var this$1$1 = this;
  var plugins = this.state.plugins;
  if (!prevState || prevState.plugins != plugins) {
    this.destroyPluginViews();
    for (var i = 0; i < plugins.length; i++) {
      var plugin = plugins[i];
      if (plugin.spec.view) {
        this$1$1.pluginViews.push(plugin.spec.view(this$1$1));
      }
    }
  } else {
    for (var i$12 = 0; i$12 < this.pluginViews.length; i$12++) {
      var pluginView = this$1$1.pluginViews[i$12];
      if (pluginView.update) {
        pluginView.update(this$1$1, prevState);
      }
    }
  }
};
EditorView$1.prototype.someProp = function someProp(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i = 0; i < plugins.length; i++) {
      var prop$1 = plugins[i].props[propName];
      if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
        return value;
      }
    }
  }
};
EditorView$1.prototype.hasFocus = function hasFocus() {
  return this.root.activeElement == this.dom;
};
EditorView$1.prototype.focus = function focus() {
  this.domObserver.stop();
  selectionToDOM$1(this, true);
  this.domObserver.start();
  if (this.editable) {
    this.dom.focus();
  }
};
prototypeAccessors$9.root.get = function() {
  var this$1$1 = this;
  var cached = this._root;
  if (cached == null) {
    for (var search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
        return this$1$1._root = search;
      }
    }
  }
  return cached || document;
};
EditorView$1.prototype.posAtCoords = function posAtCoords$1$1(coords) {
  var pos = posAtCoords$1(this, coords);
  if (this.inDOMChange && pos) {
    pos.pos = this.inDOMChange.mapping.map(pos.pos);
    if (pos.inside != -1) {
      pos.inside = this.inDOMChange.mapping.map(pos.inside);
    }
  }
  return pos;
};
EditorView$1.prototype.coordsAtPos = function coordsAtPos$1$1(pos) {
  if (this.inDOMChange) {
    pos = this.inDOMChange.mapping.invert().map(pos);
  }
  return coordsAtPos$1(this, pos);
};
EditorView$1.prototype.domAtPos = function domAtPos(pos) {
  if (this.inDOMChange) {
    pos = this.inDOMChange.mapping.invert().map(pos);
  }
  return this.docView.domFromPos(pos);
};
EditorView$1.prototype.endOfTextblock = function endOfTextblock$1$1(dir, state) {
  return endOfTextblock$1(this, state || this.state, dir);
};
EditorView$1.prototype.destroy = function destroy5() {
  if (!this.docView) {
    return;
  }
  destroyInput$1(this);
  this.destroyPluginViews();
  this.selectionReader.destroy();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations$1(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
EditorView$1.prototype.dispatchEvent = function dispatchEvent$1$1(event) {
  return dispatchEvent$1(this, event);
};
EditorView$1.prototype.dispatch = function dispatch(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction(tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView$1.prototype, prototypeAccessors$9);
function computeDocDeco$1(view2) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror" + (view2.focused ? " ProseMirror-focused" : "");
  attrs.contenteditable = String(view2.editable);
  view2.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view2.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration$1.node(0, view2.state.doc.content.size, attrs)];
}
function nonInclusiveMark$1(mark15) {
  return mark15.type.spec.inclusive === false;
}
function cursorWrapperDOM$1(visible) {
  var span = document.createElement("span");
  span.textContent = "\uFEFF";
  if (!visible) {
    span.style.position = "absolute";
    span.style.left = "-100000px";
  }
  return span;
}
function updateCursorWrapper$1(view2) {
  var ref = view2.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var visible = ref.visible;
  var $pos = $head.pos == $anchor.pos && (!visible || $head.parent.inlineContent) ? $head : null;
  if ($pos && (!visible || view2.state.storedMarks || $pos.parent.content.length == 0 || $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.some(nonInclusiveMark$1))) {
    var marks9 = view2.state.storedMarks || $pos.marks();
    var spec = { isCursorWrapper: true, marks: marks9, raw: true, visible };
    if (!view2.cursorWrapper || !prosemirrorModel$2.Mark.sameSet(view2.cursorWrapper.spec.marks, marks9) || view2.cursorWrapper.type.widget.textContent != "\uFEFF" || view2.cursorWrapper.spec.visible != visible) {
      view2.cursorWrapper = Decoration$1.widget($pos.pos, cursorWrapperDOM$1(visible), spec);
    } else if (view2.cursorWrapper.pos != $pos.pos) {
      view2.cursorWrapper = Decoration$1.widget($pos.pos, view2.cursorWrapper.type.widget, spec);
    }
  } else {
    view2.cursorWrapper = null;
  }
}
function getEditable$1(view2) {
  return !view2.someProp("editable", function(value) {
    return value(view2.state) === false;
  });
}
dist$7.EditorView = EditorView$1;
dist$7.Decoration = Decoration$1;
dist$7.DecorationSet = DecorationSet$1;
dist$7.__serializeForClipboard = serializeForClipboard$1;
dist$7.__parseFromClipboard = parseFromClipboard$1;
Object.defineProperty(dropcursor, "__esModule", { value: true });
var prosemirrorState$5 = dist$e;
var prosemirrorView$1 = dist$7;
var gecko$1 = typeof navigator != "undefined" && /gecko\/\d/i.test(navigator.userAgent);
var linux = typeof navigator != "undefined" && /linux/i.test(navigator.platform);
function dropCursor(options) {
  function dispatch3(view2, data) {
    view2.dispatch(view2.state.tr.setMeta(plugin, data));
  }
  var timeout = null;
  function scheduleRemoval(view2) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      if (plugin.getState(view2.state)) {
        dispatch3(view2, { type: "remove" });
      }
    }, 1e3);
  }
  var plugin = new prosemirrorState$5.Plugin({
    state: {
      init: function init5() {
        return null;
      },
      apply: function apply8(tr, prev2, state) {
        if (gecko$1 && linux) {
          return null;
        }
        var command = tr.getMeta(plugin);
        if (!command) {
          return prev2;
        }
        if (command.type == "set") {
          return pluginStateFor(state, command.pos, options);
        }
        return null;
      }
    },
    props: {
      handleDOMEvents: {
        dragover: function dragover(view2, event) {
          var active = plugin.getState(view2.state);
          var pos = view2.posAtCoords({ left: event.clientX, top: event.clientY });
          if (pos) {
            var target = pos.pos;
            if (view2.dragging) {
              target = dropPos$1(view2.dragging.slice, view2.state.doc.resolve(target));
            }
            if (!active || active.pos != target) {
              dispatch3(view2, { type: "set", pos: target });
            }
          }
          scheduleRemoval(view2);
          return false;
        },
        dragend: function dragend(view2) {
          if (plugin.getState(view2.state)) {
            dispatch3(view2, { type: "remove" });
          }
          return false;
        },
        drop: function drop(view2) {
          if (plugin.getState(view2.state)) {
            dispatch3(view2, { type: "remove" });
          }
          return false;
        },
        dragleave: function dragleave(view2, event) {
          if (event.target == view2.dom) {
            dispatch3(view2, { type: "remove" });
          }
          return false;
        }
      },
      decorations: function decorations(state) {
        var active = plugin.getState(state);
        return active && active.deco;
      }
    }
  });
  return plugin;
}
function style$1(options, side) {
  var width = options && options.width || 1;
  var color = options && options.color || "black";
  return "border-" + side + ": " + width + "px solid " + color + "; margin-" + side + ": -" + width + "px";
}
function pluginStateFor(state, pos, options) {
  var $pos = state.doc.resolve(pos), deco;
  if (!$pos.parent.inlineContent) {
    var before8, after8;
    if (before8 = $pos.nodeBefore) {
      deco = prosemirrorView$1.Decoration.node(pos - before8.nodeSize, pos, { nodeName: "div", style: style$1(options, "right") });
    } else if (after8 = $pos.nodeAfter) {
      deco = prosemirrorView$1.Decoration.node(pos, pos + after8.nodeSize, { nodeName: "div", style: style$1(options, "left") });
    }
  }
  if (!deco) {
    var node18 = document.createElement("span");
    node18.textContent = "\u200B";
    node18.style.cssText = style$1(options, "left") + "; display: inline-block; pointer-events: none";
    deco = prosemirrorView$1.Decoration.widget(pos, node18);
  }
  return { pos, deco: prosemirrorView$1.DecorationSet.create(state.doc, [deco]) };
}
function dropPos$1(slice11, $pos) {
  if (!slice11 || !slice11.content.size) {
    return $pos.pos;
  }
  var content2 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content2 = content2.firstChild.content;
  }
  for (var d = $pos.depth; d >= 0; d--) {
    var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
    if ($pos.node(d).canReplace(insertPos, insertPos, content2)) {
      return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return $pos.pos;
}
var dropCursor_1 = dropcursor.dropCursor = dropCursor;
var dist$5 = {};
var keymap$1 = {};
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ";",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var brokenModifierNames = chrome$1 && (mac$2 || +chrome$1[1] < 57) || gecko && mac$2;
for (var i$2 = 0; i$2 < 10; i$2++)
  base[48 + i$2] = base[96 + i$2] = String(i$2);
for (var i$2 = 1; i$2 <= 24; i$2++)
  base[i$2 + 111] = "F" + i$2;
for (var i$2 = 65; i$2 <= 90; i$2++) {
  base[i$2] = String.fromCharCode(i$2 + 32);
  shift[i$2] = String.fromCharCode(i$2);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName$1(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || safari && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var w3cKeyname = keyName$1;
keyName$1.base = base;
keyName$1.shift = shift;
Object.defineProperty(keymap$1, "__esModule", { value: true });
function _interopDefault$3(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var keyName = _interopDefault$3(w3cKeyname);
var prosemirrorState$4 = dist$e;
var mac$1 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta2;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta2 = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac$1) {
        meta2 = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta2) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize(map19) {
  var copy12 = /* @__PURE__ */ Object.create(null);
  for (var prop in map19) {
    copy12[normalizeKeyName(prop)] = map19[prop];
  }
  return copy12;
}
function modifiers(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap(bindings) {
  return new prosemirrorState$4.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map19 = normalize(bindings);
  return function(view2, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map19[modifiers(name, event, !isChar)];
    if (direct && direct(view2.state, view2.dispatch, view2)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = keyName.base[event.keyCode]) && baseName != name) {
      var fromCode = map19[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view2.state, view2.dispatch, view2)) {
        return true;
      }
    }
    return false;
  };
}
keymap$1.keymap = keymap;
keymap$1.keydownHandler = keydownHandler;
var dist$4 = {};
var dist$3 = {};
function OrderedMap$3(content2) {
  this.content = content2;
}
OrderedMap$3.prototype = {
  constructor: OrderedMap$3,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$3(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$3(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$3([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$3(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$3(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$3.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$3(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$3.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$3(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$3.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$3.from = function(value) {
  if (value instanceof OrderedMap$3)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$3(content2);
};
var orderedmap$1 = OrderedMap$3;
Object.defineProperty(dist$3, "__esModule", { value: true });
function _interopDefault$2(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap$2 = _interopDefault$2(orderedmap$1);
function findDiffStart$16(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$16(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$16(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$16(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$1 = function Fragment6(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1$5 = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment$1.prototype.nodesBetween = function nodesBetween11(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment$1.prototype.descendants = function descendants11(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment$1.prototype.textBetween = function textBetween11(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment$1.prototype.append = function append7(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment$1(content2, this.size + other.size);
};
Fragment$1.prototype.cut = function cut11(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment$1(result2, size);
};
Fragment$1.prototype.cutByIndex = function cutByIndex6(from12, to) {
  if (from12 == to) {
    return Fragment$1.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$1(this.content.slice(from12, to));
};
Fragment$1.prototype.replaceChild = function replaceChild6(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment$1(copy12, size);
};
Fragment$1.prototype.addToStart = function addToStart6(node18) {
  return new Fragment$1([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment$1.prototype.addToEnd = function addToEnd6(node18) {
  return new Fragment$1(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment$1.prototype.eq = function eq27(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1$5.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1$5.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1$5.childCount.get = function() {
  return this.content.length;
};
Fragment$1.prototype.child = function child11(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment$1.prototype.maybeChild = function maybeChild11(index8) {
  return this.content[index8];
};
Fragment$1.prototype.forEach = function forEach13(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment$1.prototype.findDiffStart = function findDiffStart$1$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$16(this, other, pos);
};
Fragment$1.prototype.findDiffEnd = function findDiffEnd$1$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$16(this, other, pos, otherPos);
};
Fragment$1.prototype.findIndex = function findIndex6(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex$1(0, pos);
  }
  if (pos == this.size) {
    return retIndex$1(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex$1(i + 1, end8);
      }
      return retIndex$1(i, curPos);
    }
    curPos = end8;
  }
};
Fragment$1.prototype.toString = function toString27() {
  return "<" + this.toStringInner() + ">";
};
Fragment$1.prototype.toStringInner = function toStringInner6() {
  return this.content.join(", ");
};
Fragment$1.prototype.toJSON = function toJSON23() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment$1.fromJSON = function fromJSON24(schema2, value) {
  if (!value) {
    return Fragment$1.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$1(value.map(schema2.nodeFromJSON));
};
Fragment$1.fromArray = function fromArray6(array) {
  if (!array.length) {
    return Fragment$1.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment$1(joined || array, size);
};
Fragment$1.from = function from8(nodes2) {
  if (!nodes2) {
    return Fragment$1.empty;
  }
  if (nodes2 instanceof Fragment$1) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment$1([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment$1.prototype, prototypeAccessors$1$5);
var found$1 = { index: 0, offset: 0 };
function retIndex$1(index8, offset2) {
  found$1.index = index8;
  found$1.offset = offset2;
  return found$1;
}
Fragment$1.empty = new Fragment$1([], 0);
function compareDeep$1(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$1(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep$1(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$1 = function Mark6(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$1.prototype.addToSet = function addToSet6(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$1.prototype.removeFromSet = function removeFromSet11(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark$1.prototype.isInSet = function isInSet11(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark$1.prototype.eq = function eq28(other) {
  return this == other || this.type == other.type && compareDeep$1(this.attrs, other.attrs);
};
Mark$1.prototype.toJSON = function toJSON24() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark$1.fromJSON = function fromJSON25(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$1.sameSet = function sameSet6(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$1.setFrom = function setFrom6(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark$1.none;
  }
  if (marks9 instanceof Mark$1) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$1.none = [];
function ReplaceError$1(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError$1.prototype;
  return err8;
}
ReplaceError$1.prototype = Object.create(Error.prototype);
ReplaceError$1.prototype.constructor = ReplaceError$1;
ReplaceError$1.prototype.name = "ReplaceError";
var Slice$1 = function Slice6(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2$2 = { size: {} };
prototypeAccessors$2$2.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$1.prototype.insertAt = function insertAt6(pos, fragment) {
  var content2 = insertInto$1(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice$1(content2, this.openStart, this.openEnd);
};
Slice$1.prototype.removeBetween = function removeBetween6(from12, to) {
  return new Slice$1(removeRange$1(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$1.prototype.eq = function eq29(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$1.prototype.toString = function toString28() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$1.prototype.toJSON = function toJSON25() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$1.fromJSON = function fromJSON26(schema2, json) {
  if (!json) {
    return Slice$1.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$1(Fragment$1.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice$1.maxOpen = function maxOpen6(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice$1(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$1.prototype, prototypeAccessors$2$2);
function removeRange$1(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange$1(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto$1(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto$1(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice$1.empty = new Slice$1(Fragment$1.empty, 0, 0);
function replace$2($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$1("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$1("Inconsistent open depths");
  }
  return replaceOuter$1($from, $to, slice11, 0);
}
function replaceOuter$1($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$1($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close$1(node18, replaceTwoWay$1($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close$1(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace$1(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close$1(node18, replaceThreeWay$1($from, start16, end8, $to, depth));
  }
}
function checkJoin$1(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError$1("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$1($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin$1(node18, $after.node(depth));
  return node18;
}
function addNode$1(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange$1($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$1($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode$1(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$1($end.nodeBefore, target);
  }
}
function close$1(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError$1("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay$1($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content2 = [];
  addRange$1(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$1(openStart, openEnd);
    addNode$1(close$1(openStart, replaceThreeWay$1($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode$1(close$1(openStart, replaceTwoWay$1($from, $start, depth + 1)), content2);
    }
    addRange$1($start, $end, depth, content2);
    if (openEnd) {
      addNode$1(close$1(openEnd, replaceTwoWay$1($end, $to, depth + 1)), content2);
    }
  }
  addRange$1($to, null, depth, content2);
  return new Fragment$1(content2);
}
function replaceTwoWay$1($from, $to, depth) {
  var content2 = [];
  addRange$1(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$1($from, $to, depth + 1);
    addNode$1(close$1(type, replaceTwoWay$1($from, $to, depth + 1)), content2);
  }
  addRange$1($to, null, depth, content2);
  return new Fragment$1(content2);
}
function prepareSliceForReplace$1(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment$1.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$1 = function ResolvedPos6(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3$1 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos$1.prototype.resolveDepth = function resolveDepth6(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3$1.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3$1.doc.get = function() {
  return this.node(0);
};
ResolvedPos$1.prototype.node = function node12(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$1.prototype.index = function index6(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$1.prototype.indexAfter = function indexAfter6(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$1.prototype.start = function start10(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$1.prototype.end = function end6(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$1.prototype.before = function before6(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$1.prototype.after = function after6(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3$1.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3$1.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3$1.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos$1.prototype.marks = function marks7() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark$1.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$1.prototype.marksAcross = function marksAcross6($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos$1.prototype.sharedDepth = function sharedDepth6(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$1.prototype.blockRange = function blockRange6(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange$1(this$1$1, other, d);
    }
  }
};
ResolvedPos$1.prototype.sameParent = function sameParent6(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$1.prototype.max = function max6(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$1.prototype.min = function min6(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$1.prototype.toString = function toString29() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$1.resolve = function resolve14(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos$1(pos, path, parentOffset);
};
ResolvedPos$1.resolveCached = function resolveCached6(doc2, pos) {
  for (var i = 0; i < resolveCache$1.length; i++) {
    var cached = resolveCache$1[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$1[resolveCachePos$1] = ResolvedPos$1.resolve(doc2, pos);
  resolveCachePos$1 = (resolveCachePos$1 + 1) % resolveCacheSize$1;
  return result2;
};
Object.defineProperties(ResolvedPos$1.prototype, prototypeAccessors$3$1);
var resolveCache$1 = [];
var resolveCachePos$1 = 0;
var resolveCacheSize$1 = 12;
var NodeRange$1 = function NodeRange6($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$1 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$1.prototype, prototypeAccessors$1$1$1);
var emptyAttrs$1 = /* @__PURE__ */ Object.create(null);
var Node$2 = function Node7(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment$1.empty;
  this.marks = marks9 || Mark$1.none;
};
var prototypeAccessors$8 = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$8.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$8.childCount.get = function() {
  return this.content.childCount;
};
Node$2.prototype.child = function child12(index8) {
  return this.content.child(index8);
};
Node$2.prototype.maybeChild = function maybeChild12(index8) {
  return this.content.maybeChild(index8);
};
Node$2.prototype.forEach = function forEach14(f2) {
  this.content.forEach(f2);
};
Node$2.prototype.nodesBetween = function nodesBetween12(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$2.prototype.descendants = function descendants12(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$8.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$2.prototype.textBetween = function textBetween12(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors$8.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$8.lastChild.get = function() {
  return this.content.lastChild;
};
Node$2.prototype.eq = function eq30(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$2.prototype.sameMarkup = function sameMarkup6(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$2.prototype.hasMarkup = function hasMarkup6(type, attrs, marks9) {
  return this.type == type && compareDeep$1(this.attrs, attrs || type.defaultAttrs || emptyAttrs$1) && Mark$1.sameSet(this.marks, marks9 || Mark$1.none);
};
Node$2.prototype.copy = function copy8(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$2.prototype.mark = function mark11(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$2.prototype.cut = function cut12(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$2.prototype.slice = function slice8(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice$1.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice$1(content2, $from.depth - depth, $to.depth - depth);
};
Node$2.prototype.replace = function replace$16(from12, to, slice11) {
  return replace$2(this.resolve(from12), this.resolve(to), slice11);
};
Node$2.prototype.nodeAt = function nodeAt6(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$2.prototype.childAfter = function childAfter6(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$2.prototype.childBefore = function childBefore6(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$2.prototype.resolve = function resolve15(pos) {
  return ResolvedPos$1.resolveCached(this, pos);
};
Node$2.prototype.resolveNoCache = function resolveNoCache6(pos) {
  return ResolvedPos$1.resolve(this, pos);
};
Node$2.prototype.rangeHasMark = function rangeHasMark6(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$8.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$8.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$8.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$8.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$8.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$8.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$8.isAtom.get = function() {
  return this.type.isAtom;
};
Node$2.prototype.toString = function toString30() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$1(this.marks, name);
};
Node$2.prototype.contentMatchAt = function contentMatchAt6(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$2.prototype.canReplace = function canReplace6(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment$1.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$2.prototype.canReplaceWith = function canReplaceWith6(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$2.prototype.canAppend = function canAppend6(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$2.prototype.defaultContentType = function defaultContentType6(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$2.prototype.check = function check6() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$2.prototype.toJSON = function toJSON26() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$2.fromJSON = function fromJSON27(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment$1.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$2.prototype, prototypeAccessors$8);
var TextNode$1 = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$1(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$2);
function wrapMarks$1(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$1 = function ContentMatch6(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5$1 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch$1.parse = function parse11(string, nodeTypes) {
  var stream = new TokenStream$1(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$1.empty;
  }
  var expr = parseExpr$1(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa$1(nfa$1(expr));
  checkForDeadEnds$1(match2, stream);
  return match2;
};
ContentMatch$1.prototype.matchType = function matchType6(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch$1.prototype.matchFragment = function matchFragment6(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5$1.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5$1.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch$1.prototype.compatible = function compatible6(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$1.prototype.fillBefore = function fillBefore6(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$1.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$1.prototype.findWrapping = function findWrapping12(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch$1.prototype.computeWrapping = function computeWrapping6(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5$1.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$1.prototype.edge = function edge6(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$1.prototype.toString = function toString31() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$1.prototype, prototypeAccessors$5$1);
ContentMatch$1.empty = new ContentMatch$1(true);
var TokenStream$1 = function TokenStream6(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3$1 = { next: {} };
prototypeAccessors$1$3$1.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$1.prototype.eat = function eat6(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$1.prototype.err = function err6(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$1.prototype, prototypeAccessors$1$3$1);
function parseExpr$1(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$1(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$1(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$1(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$1(stream) {
  var expr = parseExprAtom$1(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$1(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$1(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$1(stream, expr) {
  var min9 = parseNum$1(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum$1(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName$1(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$1(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$1(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$1(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$1(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp$1(a, b) {
  return a - b;
}
function nullFrom$1(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp$1);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$1(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$1(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom$1(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$1(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$1);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$1(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs$1(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs$16(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$1(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$1(attrs[name]);
    }
  }
  return result2;
}
var NodeType$2 = function NodeType7(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$1(spec.attrs);
  this.defaultAttrs = defaultAttrs$1(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4$1 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4$1.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4$1.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4$1.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$1.empty;
};
prototypeAccessors$4$1.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$2.prototype.hasRequiredAttrs = function hasRequiredAttrs6(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType$2.prototype.compatibleContent = function compatibleContent6(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$2.prototype.computeAttrs = function computeAttrs$1$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$16(this.attrs, attrs);
  }
};
NodeType$2.prototype.create = function create13(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$2(this, this.computeAttrs(attrs), Fragment$1.from(content2), Mark$1.setFrom(marks9));
};
NodeType$2.prototype.createChecked = function createChecked6(attrs, content2, marks9) {
  content2 = Fragment$1.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$2(this, this.computeAttrs(attrs), content2, Mark$1.setFrom(marks9));
};
NodeType$2.prototype.createAndFill = function createAndFill6(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment$1.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment$1.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$2(this, attrs, content2.append(after8), Mark$1.setFrom(marks9));
};
NodeType$2.prototype.validContent = function validContent6(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowsMarkType = function allowsMarkType6(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$2.prototype.allowsMarks = function allowsMarks6(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowedMarks = function allowedMarks6(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark$1.empty;
};
NodeType$2.compile = function compile11(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$2(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$2.prototype, prototypeAccessors$4$1);
var Attribute$1 = function Attribute6(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2$1 = { isRequired: {} };
prototypeAccessors$1$2$1.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$1.prototype, prototypeAccessors$1$2$1);
var MarkType$1 = function MarkType6(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs$1(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs$1(this.attrs);
  this.instance = defaults && new Mark$1(this, defaults);
};
MarkType$1.prototype.create = function create14(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$1(this, computeAttrs$16(this.attrs, attrs));
};
MarkType$1.compile = function compile12(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType$1(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType$1.prototype.removeFromSet = function removeFromSet12(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType$1.prototype.isInSet = function isInSet12(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType$1.prototype.excludes = function excludes6(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$1 = function Schema6(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap$2.from(spec.nodes);
  this.spec.marks = OrderedMap$2.from(spec.marks);
  this.nodes = NodeType$2.compile(this.spec.nodes, this);
  this.marks = MarkType$1.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$1.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks$1(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks$1(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$1.prototype.node = function node13(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$2)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema$1.prototype.text = function text6(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode$1(type, type.defaultAttrs, text$1, Mark$1.setFrom(marks9));
};
Schema$1.prototype.mark = function mark12(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema$1.prototype.nodeFromJSON = function nodeFromJSON6(json) {
  return Node$2.fromJSON(this, json);
};
Schema$1.prototype.markFromJSON = function markFromJSON6(json) {
  return Mark$1.fromJSON(this, json);
};
Schema$1.prototype.nodeType = function nodeType6(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks$1(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser$1 = function DOMParser6(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser$1.prototype.parse = function parse12(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$1(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$1.prototype.parseSlice = function parseSlice6(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$1(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$1.maxOpen(context.finish());
};
DOMParser$1.prototype.matchTag = function matchTag6(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches$1(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$1.prototype.matchStyle = function matchStyle6(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$1.schemaRules = function schemaRules6(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy$2(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$2(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser$1.fromSchema = function fromSchema11(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser$1(schema2, DOMParser$1.schemaRules(schema2)));
};
var blockTags$1 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$1 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$1 = { ol: true, ul: true };
var OPT_PRESERVE_WS$1 = 1;
var OPT_PRESERVE_WS_FULL$1 = 2;
var OPT_OPEN_LEFT$1 = 4;
function wsOptionsFor$1(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS$1 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$1 : 0);
}
var NodeContext$1 = function NodeContext6(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT$1 ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark$1.none;
};
NodeContext$1.prototype.findWrapping = function findWrapping13(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$1.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext$1.prototype.finish = function finish12(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$1)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment$1.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment$1.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext$1 = function ParseContext6(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$1(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT$1 : 0);
  if (topNode) {
    topContext = new NodeContext$1(
      topNode.type,
      topNode.attrs,
      Mark$1.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext$1(null, null, Mark$1.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$1(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$1 = { top: {}, currentPos: {} };
prototypeAccessors$6$1.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$1.prototype.addDOM = function addDOM6(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles$1(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext$1.prototype.addTextNode = function addTextNode6(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS$1)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL$1)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$1.prototype.addElement = function addElement6(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags$1.hasOwnProperty(name)) {
    normalizeList$1(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags$1.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$1.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext$1.prototype.readStyles = function readStyles6(styles2) {
  var this$1$1 = this;
  var marks9 = Mark$1.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext$1.prototype.addElementByRule = function addElementByRule6(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext$1.prototype.addAll = function addAll6(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags$1.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext$1.prototype.findPlace = function findPlace6(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$1.prototype.insertNode = function insertNode6(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext$1.prototype.applyPendingMarks = function applyPendingMarks6(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext$1.prototype.enter = function enter6(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext$1.prototype.enterInner = function enterInner6(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT$1 : wsOptionsFor$1(preserveWS);
  if (top.options & OPT_OPEN_LEFT$1 && top.content.length == 0) {
    options |= OPT_OPEN_LEFT$1;
  }
  this.nodes.push(new NodeContext$1(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext$1.prototype.closeExtra = function closeExtra6(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$1.prototype.finish = function finish13() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$1.prototype.sync = function sync6(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext$1.prototype.addPendingMark = function addPendingMark6(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext$1.prototype.removePendingMark = function removePendingMark6(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6$1.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$1.prototype.findAtPoint = function findAtPoint6(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$1.prototype.findInside = function findInside6(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext$1.prototype.findAround = function findAround6(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext$1.prototype.findInText = function findInText6(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext$1.prototype.matchesContext = function matchesContext6(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext$1.prototype.textblockFromContext = function textblockFromContext6() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext$1.prototype, prototypeAccessors$6$1);
function normalizeList$1(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags$1.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$1(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$1(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy$2(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer$1 = function DOMSerializer6(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer$1.prototype.serializeFragment = function serializeFragment6(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$1(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer$1.prototype.serializeNode = function serializeNode6(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer$1.renderSpec(doc$1(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$1.prototype.serializeNodeAndMarks = function serializeNodeAndMarks6(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$1.prototype.serializeMark = function serializeMark6(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer$1.renderSpec(doc$1(options), toDOM4(mark15, inline3));
};
DOMSerializer$1.renderSpec = function renderSpec6(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer$1.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$1.fromSchema = function fromSchema12(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer$1(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer$1.nodesFromSchema = function nodesFromSchema6(schema2) {
  var result2 = gatherToDOM$1(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer$1.marksFromSchema = function marksFromSchema6(schema2) {
  return gatherToDOM$1(schema2.marks);
};
function gatherToDOM$1(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc$1(options) {
  return options.document || window.document;
}
dist$3.Node = Node$2;
dist$3.ResolvedPos = ResolvedPos$1;
dist$3.NodeRange = NodeRange$1;
dist$3.Fragment = Fragment$1;
dist$3.Slice = Slice$1;
dist$3.ReplaceError = ReplaceError$1;
dist$3.Mark = Mark$1;
dist$3.Schema = Schema$1;
dist$3.NodeType = NodeType$2;
dist$3.MarkType = MarkType$1;
dist$3.ContentMatch = ContentMatch$1;
dist$3.DOMParser = DOMParser$1;
dist$3.DOMSerializer = DOMSerializer$1;
Object.defineProperty(dist$4, "__esModule", { value: true });
var prosemirrorModel$1 = dist$3;
var prosemirrorState$3 = dist$e;
var prosemirrorTransform$1 = dist$c;
var result = {};
if (typeof navigator != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  result.mac = /Mac/.test(navigator.platform);
  var ie$1 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie$1 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome = !ie$1 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  result.ios = !ie$1 && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  result.webkit = !ie$1 && "WebkitAppearance" in document.documentElement.style;
  result.safari = /Apple Computer/.test(navigator.vendor);
}
var domIndex = function(node18) {
  for (var index8 = 0; ; index8++) {
    node18 = node18.previousSibling;
    if (!node18) {
      return index8;
    }
  }
};
var parentNode = function(node18) {
  var parent = node18.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var textRange = function(node18, from12, to) {
  var range = document.createRange();
  range.setEnd(node18, to == null ? node18.nodeValue.length : to);
  range.setStart(node18, from12 || 0);
  return range;
};
var isEquivalentPosition = function(node18, off, targetNode, targetOff) {
  return targetNode && (scanFor(node18, off, targetNode, targetOff, -1) || scanFor(node18, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node18, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node18 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize(node18)) || node18.nodeType == 3 && node18.nodeValue == "\uFEFF") {
      var parent = node18.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node18) || atomElements.test(node18.nodeName)) {
        return false;
      }
      off = domIndex(node18) + (dir < 0 ? 0 : 1);
      node18 = parent;
    } else if (node18.nodeType == 1) {
      node18 = node18.childNodes[off + (dir < 0 ? -1 : 0)];
      off = dir < 0 ? nodeSize(node18) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function hasBlockDesc(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView(view2, rect) {
  var scrollThreshold = view2.someProp("scrollThreshold") || 0, scrollMargin = view2.someProp("scrollMargin");
  var doc2 = view2.dom.ownerDocument, win = doc2.defaultView;
  if (scrollMargin == null) {
    scrollMargin = 5;
  }
  for (var parent = view2.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    var atBody = parent == doc2.body;
    var bounding = atBody ? windowRect(win) : parent.getBoundingClientRect();
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + scrollThreshold) {
      moveY = -(bounding.top - rect.top + scrollMargin);
    } else if (rect.bottom > bounding.bottom - scrollThreshold) {
      moveY = rect.bottom - bounding.bottom + scrollMargin;
    }
    if (rect.left < bounding.left + scrollThreshold) {
      moveX = -(bounding.left - rect.left + scrollMargin);
    } else if (rect.right > bounding.right - scrollThreshold) {
      moveX = rect.right - bounding.right + scrollMargin;
    }
    if (moveX || moveY) {
      if (atBody) {
        win.scrollBy(moveX, moveY);
      } else {
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
      }
    }
    if (atBody) {
      break;
    }
  }
}
function storeScrollPos(view2) {
  var rect = view2.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var doc2 = view2.dom.ownerDocument;
  var refDOM, refTop;
  for (var x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    var dom = view2.root.elementFromPoint(x2, y2);
    if (dom == view2.dom || !view2.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  var stack = [];
  for (var dom$1 = view2.dom; dom$1; dom$1 = parentNode(dom$1)) {
    stack.push({ dom: dom$1, top: dom$1.scrollTop, left: dom$1.scrollLeft });
    if (dom$1 == doc2.body) {
      break;
    }
  }
  return { refDOM, refTop, stack };
}
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  var dTop = newRefTop == 0 ? 0 : newRefTop - refTop;
  for (var i = 0; i < stack.length; i++) {
    var ref$1 = stack[i];
    var dom = ref$1.dom;
    var top = ref$1.top;
    var left = ref$1.left;
    if (dom.scrollTop != top + dTop) {
      dom.scrollTop = top + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
function findOffsetInNode(node18, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child15 = node18.firstChild, childIndex = 0; child15; child15 = child15.nextSibling, childIndex++) {
    var rects = void 0;
    if (child15.nodeType == 1) {
      rects = child15.getClientRects();
    } else if (child15.nodeType == 3) {
      rects = textRange(child15).getClientRects();
    } else {
      continue;
    }
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child15;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child15.nodeType == 1 && dx) {
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset2 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node18, offset: offset2 };
  }
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node18, coords) {
  var len = node18.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node18, i + 1);
    range.setStart(node18, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left && rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top) {
      return { node: node18, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node18, offset: 0 };
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view2, elt, coords) {
  if (!view2.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    return null;
  }
  var ref = findOffsetInNode(elt, coords);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var bias = -1;
  if (node18.nodeType == 1 && !node18.firstChild) {
    var rect = node18.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view2.docView.posFromDOM(node18, offset2, bias);
}
function posFromCaret(view2, node18, offset2, coords) {
  var outside = -1;
  for (var cur = node18; ; ) {
    if (cur == view2.dom) {
      break;
    }
    var desc = view2.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view2.docView.posFromDOM(node18, offset2);
}
function posAtCoords(view2, coords) {
  var root2 = view2.root, node18, offset2;
  if (root2.caretPositionFromPoint) {
    var pos$1 = root2.caretPositionFromPoint(coords.left, coords.top);
    if (pos$1) {
      var assign3;
      assign3 = pos$1, node18 = assign3.offsetNode, offset2 = assign3.offset;
    }
  }
  if (!node18 && root2.caretRangeFromPoint) {
    var range = root2.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      var assign$12;
      assign$12 = range, node18 = assign$12.startContainer, offset2 = assign$12.startOffset;
    }
  }
  var elt = root2.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt) {
    return null;
  }
  elt = targetKludge(elt, coords);
  if (node18) {
    if (node18 == view2.dom && offset2 == node18.childNodes.length - 1 && node18.lastChild.nodeType == 1 && coords.top > node18.lastChild.getBoundingClientRect().bottom) {
      pos = view2.state.doc.content.size;
    } else if (offset2 == 0 || node18.nodeType != 1 || node18.childNodes[offset2 - 1].nodeName != "BR") {
      pos = posFromCaret(view2, node18, offset2, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view2, elt, coords);
    if (pos == null) {
      return null;
    }
  }
  var desc = view2.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
function coordsAtPos(view2, pos) {
  var ref = view2.docView.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var side, rect;
  if (node18.nodeType == 3) {
    if (offset2 < node18.nodeValue.length) {
      rect = singleRect(textRange(node18, offset2, offset2 + 1), -1);
      side = "left";
    }
    if ((!rect || rect.left == rect.right) && offset2) {
      rect = singleRect(textRange(node18, offset2 - 1, offset2), 1);
      side = "right";
    }
  } else if (node18.firstChild) {
    if (offset2 < node18.childNodes.length) {
      var child15 = node18.childNodes[offset2];
      rect = singleRect(child15.nodeType == 3 ? textRange(child15) : child15, -1);
      side = "left";
    }
    if ((!rect || rect.top == rect.bottom) && offset2) {
      var child$1 = node18.childNodes[offset2 - 1];
      rect = singleRect(child$1.nodeType == 3 ? textRange(child$1) : child$1, 1);
      side = "right";
    }
  } else {
    rect = node18.getBoundingClientRect();
    side = "left";
  }
  var x2 = rect[side];
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function withFlushedState(view2, state, f2) {
  var viewState = view2.state, active = view2.root.activeElement;
  if (viewState != state || !view2.inDOMChange) {
    view2.updateState(state);
  }
  if (active != view2.dom) {
    view2.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view2.updateState(viewState);
    }
    if (active != view2.dom) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view2, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$anchor.min(sel.$head) : sel.$anchor.max(sel.$head);
  if (!$pos.depth) {
    return false;
  }
  return withFlushedState(view2, state, function() {
    var dom = view2.docView.domAfterPos($pos.before());
    var coords = coordsAtPos(view2, $pos.pos);
    for (var child15 = dom.firstChild; child15; child15 = child15.nextSibling) {
      var boxes = void 0;
      if (child15.nodeType == 1) {
        boxes = child15.getClientRects();
      } else if (child15.nodeType == 3) {
        boxes = textRange(child15, 0, child15.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view2, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock || !$head.depth) {
    return false;
  }
  var offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  var sel = getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState(view2, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    sel.modify("move", dir, "character");
    var parentDOM = view2.docView.domAfterPos($head.before());
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    return result2;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view2, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view2, state, dir) : endOfTextblockHorizontal(view2, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc2 = function ViewDesc3(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};
var prototypeAccessors$1$4 = { beforePosition: {}, size: {}, border: {}, posBefore: {}, posAtStart: {}, posAfter: {}, posAtEnd: {}, contentLost: {} };
ViewDesc2.prototype.matchesWidget = function matchesWidget2() {
  return false;
};
ViewDesc2.prototype.matchesMark = function matchesMark2() {
  return false;
};
ViewDesc2.prototype.matchesNode = function matchesNode2() {
  return false;
};
ViewDesc2.prototype.matchesHack = function matchesHack2() {
  return false;
};
prototypeAccessors$1$4.beforePosition.get = function() {
  return false;
};
ViewDesc2.prototype.parseRule = function parseRule2() {
  return null;
};
ViewDesc2.prototype.stopEvent = function stopEvent2() {
  return false;
};
prototypeAccessors$1$4.size.get = function() {
  var this$1$1 = this;
  var size = 0;
  for (var i = 0; i < this.children.length; i++) {
    size += this$1$1.children[i].size;
  }
  return size;
};
prototypeAccessors$1$4.border.get = function() {
  return 0;
};
ViewDesc2.prototype.destroy = function destroy6() {
  var this$1$1 = this;
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i = 0; i < this.children.length; i++) {
    this$1$1.children[i].destroy();
  }
};
ViewDesc2.prototype.posBeforeChild = function posBeforeChild2(child15) {
  var this$1$1 = this;
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this$1$1.children[i];
    if (cur == child15) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors$1$4.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors$1$4.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors$1$4.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors$1$4.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset2, bias) {
  var this$1$1 = this;
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset2 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset2];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset2 == 0) {
      for (var search = dom; ; search = search.parentNode) {
        if (search == this$1$1.dom) {
          atEnd2 = false;
          break;
        }
        if (search.parentNode.firstChild != search) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset2 == dom.childNodes.length) {
      for (var search$1 = dom; ; search$1 = search$1.parentNode) {
        if (search$1 == this$1$1.dom) {
          atEnd2 = true;
          break;
        }
        if (search$1.parentNode.lastChild != search$1) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc2.prototype.nearestDesc = function nearestDesc2(dom, onlyNodes) {
  var this$1$1 = this;
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this$1$1.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom) : desc.nodeDOM == dom)) {
        first = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc2.prototype.getDesc = function getDesc2(dom) {
  var this$1$1 = this;
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this$1$1) {
      return desc;
    }
  }
};
ViewDesc2.prototype.posFromDOM = function posFromDOM2(dom, offset2, bias) {
  var this$1$1 = this;
  for (var scan = dom; ; scan = scan.parentNode) {
    var desc = this$1$1.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset2, bias);
    }
  }
};
ViewDesc2.prototype.descAt = function descAt2(pos) {
  var this$1$1 = this;
  for (var i = 0, offset2 = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (offset2 == pos && end8 != offset2) {
      while (!child15.border && child15.children.length) {
        child15 = child15.children[0];
      }
      return child15;
    }
    if (pos < end8) {
      return child15.descAt(pos - offset2 - child15.border);
    }
    offset2 = end8;
  }
};
ViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
  var this$1$1 = this;
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  for (var offset2 = 0, i = 0; ; i++) {
    if (offset2 == pos) {
      while (i < this.children.length && this.children[i].beforePosition) {
        i++;
      }
      return { node: this$1$1.contentDOM, offset: i };
    }
    if (i == this$1$1.children.length) {
      throw new Error("Invalid position " + pos);
    }
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (pos < end8) {
      return child15.domFromPos(pos - offset2 - child15.border);
    }
    offset2 = end8;
  }
};
ViewDesc2.prototype.parseRange = function parseRange2(from12, to, base2) {
  var this$1$1 = this;
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from12, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset2 = 0, i = 0; ; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (fromOffset == -1 && from12 <= end8) {
      var childBase = offset2 + child15.border;
      if (from12 >= childBase && to <= end8 - child15.border && child15.node && child15.contentDOM && this$1$1.contentDOM.contains(child15.contentDOM)) {
        return child15.parseRange(from12 - childBase, to - childBase, base2 + childBase);
      }
      from12 = base2 + offset2;
      for (var j = i; j > 0; j--) {
        var prev2 = this$1$1.children[j - 1];
        if (prev2.size && prev2.dom.parentNode == this$1$1.contentDOM && !prev2.emptyChildAt(1)) {
          fromOffset = domIndex(prev2.dom) + 1;
          break;
        }
        from12 -= prev2.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && to <= end8) {
      to = base2 + end8;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next2 = this$1$1.children[j$1];
        if (next2.size && next2.dom.parentNode == this$1$1.contentDOM && !next2.emptyChildAt(-1)) {
          toOffset = domIndex(next2.dom);
          break;
        }
        to += next2.size;
      }
      if (toOffset == -1) {
        toOffset = this$1$1.contentDOM.childNodes.length;
      }
      break;
    }
    offset2 = end8;
  }
  return { node: this.contentDOM, from: from12, to, fromOffset, toOffset };
};
ViewDesc2.prototype.emptyChildAt = function emptyChildAt2(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child15 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child15.size == 0 || child15.emptyChildAt(side);
};
ViewDesc2.prototype.domAfterPos = function domAfterPos2(pos) {
  var ref = this.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  if (node18.nodeType != 1 || offset2 == node18.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node18.childNodes[offset2];
};
ViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root2) {
  var this$1$1 = this;
  var from12 = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset2 = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (from12 > offset2 && to < end8) {
      return child15.setSelection(anchor - offset2 - child15.border, head - offset2 - child15.border, root2);
    }
    offset2 = end8;
  }
  var anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head);
  var domSel = root2.getSelection(), range = document.createRange();
  if (isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  if (domSel.extend) {
    range.setEnd(anchorDOM.node, anchorDOM.offset);
    range.collapse(false);
  } else {
    if (anchor > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
  }
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (domSel.extend) {
    domSel.extend(headDOM.node, headDOM.offset);
  }
};
ViewDesc2.prototype.ignoreMutation = function ignoreMutation2(_mutation) {
  return !this.contentDOM;
};
prototypeAccessors$1$4.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc2.prototype.markDirty = function markDirty3(from12, to) {
  var this$1$1 = this;
  for (var offset2 = 0, i = 0; i < this.children.length; i++) {
    var child15 = this$1$1.children[i], end8 = offset2 + child15.size;
    if (offset2 == end8 ? from12 <= end8 && to >= offset2 : from12 < end8 && to > offset2) {
      var startInside = offset2 + child15.border, endInside = end8 - child15.border;
      if (from12 >= startInside && to <= endInside) {
        this$1$1.dirty = from12 == offset2 || to == end8 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from12 == startInside && to == endInside && child15.contentLost) {
          child15.dirty = NODE_DIRTY;
        } else {
          child15.markDirty(from12 - startInside, to - startInside);
        }
        return;
      } else {
        child15.dirty = NODE_DIRTY;
      }
    }
    offset2 = end8;
  }
  this.dirty = CONTENT_DIRTY;
};
Object.defineProperties(ViewDesc2.prototype, prototypeAccessors$1$4);
var nothing = [];
var WidgetViewDesc = function(ViewDesc4) {
  function WidgetViewDesc2(parent, widget3) {
    ViewDesc4.call(this, parent, nothing, widget3.type.widget, null);
    this.widget = widget3;
  }
  if (ViewDesc4)
    WidgetViewDesc2.__proto__ = ViewDesc4;
  WidgetViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { beforePosition: {} };
  prototypeAccessors$12.beforePosition.get = function() {
    return this.widget.type.side < 0;
  };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget3(widget3) {
    return this.dirty == NOT_DIRTY && widget3.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    var stop7 = this.widget.spec.stopEvent;
    return stop7 ? stop7(event) : false;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc2);
var CursorWrapperDesc = function(WidgetViewDesc2) {
  function CursorWrapperDesc2() {
    WidgetViewDesc2.apply(this, arguments);
  }
  if (WidgetViewDesc2)
    CursorWrapperDesc2.__proto__ = WidgetViewDesc2;
  CursorWrapperDesc2.prototype = Object.create(WidgetViewDesc2 && WidgetViewDesc2.prototype);
  CursorWrapperDesc2.prototype.constructor = CursorWrapperDesc2;
  CursorWrapperDesc2.prototype.parseRule = function parseRule3() {
    var content2;
    for (var child15 = this.dom.firstChild; child15; child15 = child15.nextSibling) {
      var add4 = void 0;
      if (child15.nodeType == 3) {
        var text8 = child15.nodeValue.replace(/\ufeff/g, "");
        if (!text8) {
          continue;
        }
        add4 = document.createTextNode(text8);
      } else if (child15.textContent == "\uFEFF") {
        continue;
      } else {
        add4 = child15.cloneNode(true);
      }
      if (!content2) {
        content2 = document.createDocumentFragment();
      }
      content2.appendChild(add4);
    }
    if (content2) {
      return { skip: content2 };
    } else {
      return WidgetViewDesc2.prototype.parseRule.call(this);
    }
  };
  CursorWrapperDesc2.prototype.ignoreMutation = function ignoreMutation3() {
    return false;
  };
  return CursorWrapperDesc2;
}(WidgetViewDesc);
var MarkViewDesc = function(ViewDesc4) {
  function MarkViewDesc2(parent, mark15, dom, contentDOM) {
    ViewDesc4.call(this, parent, [], dom, contentDOM);
    this.mark = mark15;
  }
  if (ViewDesc4)
    MarkViewDesc2.__proto__ = ViewDesc4;
  MarkViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create22(parent, mark15, inline3, view2) {
    var custom = customNodeViews(view2)[mark15.type.name];
    var spec = custom && custom(mark15, view2);
    if (!spec || !spec.dom) {
      spec = prosemirrorModel$1.DOMSerializer.renderSpec(document, mark15.type.spec.toDOM(mark15, inline3));
    }
    return new MarkViewDesc2(parent, mark15, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule3() {
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark3(mark15) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark15);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty5(from12, to) {
    ViewDesc4.prototype.markDirty.call(this, from12, to);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY;
    }
  };
  return MarkViewDesc2;
}(ViewDesc2);
var NodeViewDesc = function(ViewDesc4) {
  function NodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2) {
    ViewDesc4.call(this, parent, node18.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node18;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view2);
    }
  }
  if (ViewDesc4)
    NodeViewDesc2.__proto__ = ViewDesc4;
  NodeViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$22 = { size: {}, border: {} };
  NodeViewDesc2.create = function create22(parent, node18, outerDeco, innerDeco, view2) {
    var custom = customNodeViews(view2)[node18.type.name], descObj;
    var spec = custom && custom(node18, view2, function() {
      if (descObj && descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node18.isText) {
      if (!dom) {
        dom = document.createTextNode(node18.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      var assign3;
      assign3 = prosemirrorModel$1.DOMSerializer.renderSpec(document, node18.type.spec.toDOM(node18)), dom = assign3.dom, contentDOM = assign3.contentDOM;
    }
    if (!contentDOM && !node18.isText && dom.nodeName != "BR") {
      dom.contentEditable = false;
      if (node18.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node18);
    if (spec) {
      return descObj = new CustomNodeViewDesc(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view2);
    } else if (node18.isText) {
      return new TextViewDesc(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2);
    } else {
      return new NodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule3() {
    var this$1$1 = this;
    if (this.contentDOM && !this.contentLost) {
      return { node: this.node.type.name, attrs: this.node.attrs, contentElement: this.contentDOM };
    } else {
      return { node: this.node.type.name, attrs: this.node.attrs, getContent: function() {
        return this$1$1.contentDOM ? prosemirrorModel$1.Fragment.empty : this$1$1.node.content;
      } };
    }
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode3(node18, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node18.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$22.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$22.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view2) {
    var this$1$1 = this;
    var updater = new ViewTreeUpdater2(this), inline3 = this.node.inlineContent;
    iterDeco(this.node, this.innerDeco, function(widget3, i) {
      if (widget3.spec.marks) {
        updater.syncToMarks(widget3.spec.marks, inline3, view2);
      } else if (widget3.type.side >= 0) {
        updater.syncToMarks(i == this$1$1.node.childCount ? prosemirrorModel$1.Mark.none : this$1$1.node.child(i).marks, inline3, view2);
      }
      updater.placeWidget(widget3);
    }, function(child15, outerDeco, innerDeco, i) {
      updater.syncToMarks(child15.marks, inline3, view2);
      updater.findNodeMatch(child15, outerDeco, innerDeco, i) || updater.updateNextNode(child15, outerDeco, innerDeco, view2, i) || updater.addNode(child15, outerDeco, innerDeco, view2);
    });
    updater.syncToMarks(nothing, inline3, view2);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      this.renderChildren();
    }
  };
  NodeViewDesc2.prototype.renderChildren = function renderChildren() {
    renderDescs(this.contentDOM, this.children, NodeViewDesc2.is);
    if (result.ios) {
      iosHacks(this.dom);
    }
  };
  NodeViewDesc2.prototype.update = function update4(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY || !node18.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node18, outerDeco, innerDeco, view2);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node18, outerDeco, innerDeco, view2) {
    this.updateOuterDeco(outerDeco);
    this.node = node18;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view2);
    }
    this.dirty = NOT_DIRTY;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(
      this.dom,
      this.nodeDOM,
      computeOuterDeco(this.outerDeco, this.node, needsWrap),
      computeOuterDeco(outerDeco, this.node, needsWrap)
    );
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$22);
  return NodeViewDesc2;
}(ViewDesc2);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view2) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view2);
}
var TextViewDesc = function(NodeViewDesc2) {
  function TextViewDesc2(parent, node18, outerDeco, innerDeco, dom, nodeDOM, view2) {
    NodeViewDesc2.call(this, parent, node18, outerDeco, innerDeco, dom, null, nodeDOM, view2);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  TextViewDesc2.prototype.parseRule = function parseRule3() {
    var parent = this.nodeDOM.parentNode;
    return parent ? { skip: parent } : { ignore: true };
  };
  TextViewDesc2.prototype.update = function update4(node18, outerDeco) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node18.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node18.text != this.node.text) && node18.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node18.text;
    }
    this.node = node18;
    this.dirty = NOT_DIRTY;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset2, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return mutation.type != "characterData";
  };
  return TextViewDesc2;
}(NodeViewDesc);
var BRHackViewDesc = function(ViewDesc4) {
  function BRHackViewDesc2() {
    ViewDesc4.apply(this, arguments);
  }
  if (ViewDesc4)
    BRHackViewDesc2.__proto__ = ViewDesc4;
  BRHackViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  BRHackViewDesc2.prototype.constructor = BRHackViewDesc2;
  BRHackViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  BRHackViewDesc2.prototype.matchesHack = function matchesHack3() {
    return this.dirty == NOT_DIRTY;
  };
  return BRHackViewDesc2;
}(ViewDesc2);
var CustomNodeViewDesc = function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view2) {
    NodeViewDesc2.call(this, parent, node18, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view2);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update4(node18, outerDeco, innerDeco, view2) {
    if (this.dirty == NODE_DIRTY) {
      return false;
    }
    if (this.spec.update) {
      var result$$1 = this.spec.update(node18, outerDeco);
      if (result$$1) {
        this.updateInner(node18, outerDeco, innerDeco, view2);
      }
      return result$$1;
    } else if (!this.contentDOM && !node18.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node18, outerDeco, innerDeco, view2);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection3(anchor, head, root2) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root2);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy12() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs) {
  var dom = parentDOM.firstChild;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
      }
      dom = dom.nextSibling;
    } else {
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node18, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result$$1 = [top];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs, cur = top;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result$$1.push(cur = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result$$1.length == 1) {
        result$$1.push(cur = top = new OuterDecoLevel(node18.isInline ? "span" : "div"));
      }
      if (name == "class") {
        cur.class = (cur.class ? cur.class + " " : "") + val;
      } else if (name == "style") {
        cur.style = (cur.style ? cur.style + ";" : "") + val;
      } else if (name != "nodeName") {
        cur[name] = val;
      }
    }
  }
  return result$$1;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM;
  }
  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev2 = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev2 && prev2.nodeName == deco.nodeName && curDOM != outerDOM && (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.appendChild(curDOM);
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev2 || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev2, cur) {
  for (var name in prev2) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev2[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev2.class != cur.class) {
    var prevList = prev2.class ? prev2.class.split(" ") : nothing;
    var curList = cur.class ? cur.class.split(" ") : nothing;
    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) {
        dom.classList.remove(prevList[i]);
      }
    }
    for (var i$12 = 0; i$12 < curList.length; i$12++) {
      if (prevList.indexOf(curList[i$12]) == -1) {
        dom.classList.add(curList[i$12]);
      }
    }
  }
  if (prev2.style != cur.style) {
    if (prev2.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev2.style)) {
        dom.style[m2[1].toLowerCase()] = "";
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node18) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node18, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
var ViewTreeUpdater2 = function ViewTreeUpdater3(top) {
  this.top = top;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatched = preMatch(top.node.content, top.children);
};
ViewTreeUpdater2.prototype.destroyBetween = function destroyBetween2(start16, end8) {
  var this$1$1 = this;
  if (start16 == end8) {
    return;
  }
  for (var i = start16; i < end8; i++) {
    this$1$1.top.children[i].destroy();
  }
  this.top.children.splice(start16, end8 - start16);
  this.changed = true;
};
ViewTreeUpdater2.prototype.destroyRest = function destroyRest2() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater2.prototype.syncToMarks = function syncToMarks2(marks9, inline3, view2) {
  var this$1$1 = this;
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks9.length), next2;
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks9[keep])) {
    keep++;
  }
  while (keep < depth) {
    this$1$1.destroyRest();
    this$1$1.top.dirty = NOT_DIRTY;
    this$1$1.index = this$1$1.stack.pop();
    this$1$1.top = this$1$1.stack.pop();
    depth--;
  }
  while (depth < marks9.length) {
    this$1$1.stack.push(this$1$1.top, this$1$1.index + 1);
    if (this$1$1.index < this$1$1.top.children.length && (next2 = this$1$1.top.children[this$1$1.index]).matchesMark(marks9[depth])) {
      this$1$1.top = next2;
    } else {
      var markDesc = MarkViewDesc.create(this$1$1.top, marks9[depth], inline3, view2);
      this$1$1.top.children.splice(this$1$1.index, 0, markDesc);
      this$1$1.top = markDesc;
      this$1$1.changed = true;
    }
    this$1$1.index = 0;
    depth++;
  }
};
ViewTreeUpdater2.prototype.findNodeMatch = function findNodeMatch2(node18, outerDeco, innerDeco, index8) {
  var this$1$1 = this;
  for (var i = this.index, children = this.top.children, e = Math.min(children.length, i + 5); i < e; i++) {
    var child15 = children[i], preMatched = void 0;
    if (child15.matchesNode(node18, outerDeco, innerDeco) && ((preMatched = this$1$1.preMatched.indexOf(child15)) == -1 || preMatched == index8)) {
      this$1$1.destroyBetween(this$1$1.index, i);
      this$1$1.index++;
      return true;
    }
  }
  return false;
};
ViewTreeUpdater2.prototype.updateNextNode = function updateNextNode2(node18, outerDeco, innerDeco, view2, index8) {
  if (this.index == this.top.children.length) {
    return false;
  }
  var next2 = this.top.children[this.index];
  if (next2 instanceof NodeViewDesc) {
    var preMatch2 = this.preMatched.indexOf(next2);
    if (preMatch2 > -1 && preMatch2 != index8) {
      return false;
    }
    var nextDOM = next2.dom;
    if (next2.update(node18, outerDeco, innerDeco, view2)) {
      if (next2.dom != nextDOM) {
        this.changed = true;
      }
      this.index++;
      return true;
    }
  }
  return false;
};
ViewTreeUpdater2.prototype.addNode = function addNode3(node18, outerDeco, innerDeco, view2) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node18, outerDeco, innerDeco, view2));
  this.changed = true;
};
ViewTreeUpdater2.prototype.placeWidget = function placeWidget2(widget3) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget3)) {
    this.index++;
  } else {
    var desc = new (widget3.spec.isCursorWrapper ? CursorWrapperDesc : WidgetViewDesc)(this.top, widget3);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater2.prototype.addTextblockHacks = function addTextblockHacks2() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
      this.index++;
    } else {
      var dom = document.createElement("br");
      this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));
      this.changed = true;
    }
  }
};
function preMatch(frag, descs) {
  var result$$1 = [], end8 = frag.childCount;
  for (var i = descs.length - 1; end8 > 0 && i >= 0; i--) {
    var desc = descs[i], node18 = desc.node;
    if (!node18) {
      continue;
    }
    if (node18 != frag.child(end8 - 1)) {
      break;
    }
    result$$1[--end8] = desc;
  }
  return result$$1;
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals5 = deco.locals(parent), offset2 = 0;
  if (locals5.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child15 = parent.child(i);
      onNode(child15, locals5, deco.forChild(offset2, child15), i);
      offset2 += child15.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
      var widget3 = locals5[decoIndex++], widgets = void 0;
      while (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
        (widgets || (widgets = [widget3])).push(locals5[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$12 = 0; i$12 < widgets.length; i$12++) {
          onWidget(widgets[i$12], parentIndex);
        }
      } else {
        onWidget(widget3, parentIndex);
      }
    }
    var child$1 = void 0;
    if (restNode) {
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset2) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals5.length && locals5[decoIndex].from == offset2) {
      active.push(locals5[decoIndex++]);
    }
    var end8 = offset2 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end8;
      if (decoIndex < locals5.length && locals5[decoIndex].from < cutAt) {
        cutAt = locals5[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end8) {
        restNode = child$1.cut(cutAt - offset2);
        child$1 = child$1.cut(0, cutAt - offset2);
        end8 = cutAt;
      }
    }
    onNode(child$1, active.length ? active.slice() : nothing, deco.forChild(offset2, child$1), parentIndex - 1);
    offset2 = end8;
  }
}
var cachedCustomViews;
var cachedCustomFor;
function customNodeViews(view2) {
  if (cachedCustomFor == view2._props) {
    return cachedCustomViews;
  }
  cachedCustomFor = view2._props;
  return cachedCustomViews = buildCustomViews(view2);
}
function buildCustomViews(view2) {
  var result$$1 = {};
  view2.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result$$1, prop)) {
        result$$1[prop] = obj[prop];
      }
    }
  });
  return result$$1;
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirrorState$3.Selection.findFrom($start, dir);
}
function apply$2(view2, sel) {
  view2.dispatch(view2.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view2, dir) {
  var sel = view2.state.selection;
  if (sel instanceof prosemirrorState$3.TextSelection) {
    if (!sel.empty) {
      return false;
    } else if (view2.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next2 = moveSelectionBlock(view2.state, dir);
      if (next2 && next2 instanceof prosemirrorState$3.NodeSelection) {
        return apply$2(view2, next2);
      }
      return false;
    } else {
      var $head = sel.$head, node18 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (node18 && prosemirrorState$3.NodeSelection.isSelectable(node18)) {
        var nodePos = dir < 0 ? $head.pos - node18.nodeSize : $head.pos;
        if (node18.isAtom || (desc = view2.docView.descAt(nodePos)) && !desc.contentDOM) {
          return apply$2(view2, new prosemirrorState$3.NodeSelection(dir < 0 ? view2.state.doc.resolve($head.pos - node18.nodeSize) : $head));
        }
      }
      return false;
    }
  } else if (sel instanceof prosemirrorState$3.NodeSelection && sel.node.isInline) {
    return apply$2(view2, new prosemirrorState$3.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view2.state, dir);
    if (next$1) {
      return apply$2(view2, next$1);
    }
    return false;
  }
}
function nodeLen(node18) {
  return node18.nodeType == 3 ? node18.nodeValue.length : node18.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view2) {
  var sel = view2.root.getSelection();
  var node18 = sel.anchorNode, offset2 = sel.anchorOffset;
  if (!node18) {
    return;
  }
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 > 0) {
      if (node18.nodeType != 1) {
        if (node18.nodeType == 3 && node18.nodeValue.charAt(offset2 - 1) == "\uFEFF") {
          moveNode = node18;
          moveOffset = --offset2;
        } else {
          break;
        }
      } else {
        var before8 = node18.childNodes[offset2 - 1];
        if (isIgnorable(before8)) {
          moveNode = node18;
          moveOffset = --offset2;
        } else if (before8.nodeType == 3) {
          node18 = before8;
          offset2 = node18.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node18)) {
      break;
    } else {
      var prev2 = node18.previousSibling;
      while (prev2 && isIgnorable(prev2)) {
        moveNode = node18.parentNode;
        moveOffset = domIndex(prev2);
        prev2 = prev2.previousSibling;
      }
      if (!prev2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom) {
          break;
        }
        offset2 = 0;
      } else {
        node18 = prev2;
        offset2 = nodeLen(node18);
      }
    }
  }
  if (moveNode) {
    setSel(view2, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view2) {
  var sel = view2.root.getSelection();
  var node18 = sel.anchorNode, offset2 = sel.anchorOffset;
  if (!node18) {
    return;
  }
  var len = nodeLen(node18);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node18.nodeType != 1) {
        break;
      }
      var after8 = node18.childNodes[offset2];
      if (isIgnorable(after8)) {
        moveNode = node18;
        moveOffset = ++offset2;
      } else {
        break;
      }
    } else if (isBlockNode(node18)) {
      break;
    } else {
      var next2 = node18.nextSibling;
      while (next2 && isIgnorable(next2)) {
        moveNode = next2.parentNode;
        moveOffset = domIndex(next2) + 1;
        next2 = next2.nextSibling;
      }
      if (!next2) {
        node18 = node18.parentNode;
        if (node18 == view2.dom) {
          break;
        }
        offset2 = len = 0;
      } else {
        node18 = next2;
        offset2 = 0;
        len = nodeLen(node18);
      }
    }
  }
  if (moveNode) {
    setSel(view2, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSel(view2, sel, node18, offset2) {
  var range = document.createRange();
  range.setEnd(node18, offset2);
  range.setStart(node18, offset2);
  sel.removeAllRanges();
  sel.addRange(range);
  view2.selectionReader.storeDOMState(view2.selection);
}
function selectVertically(view2, dir) {
  var sel = view2.state.selection;
  if (sel instanceof prosemirrorState$3.TextSelection && !sel.empty) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view2.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next2 = moveSelectionBlock(view2.state, dir);
    if (next2 && next2 instanceof prosemirrorState$3.NodeSelection) {
      return apply$2(view2, next2);
    }
  }
  if (!$from.parent.inlineContent) {
    var beyond = prosemirrorState$3.Selection.findFrom(dir < 0 ? $from : $to, dir);
    return beyond ? apply$2(view2, beyond) : true;
  }
  return false;
}
function stopNativeHorizontalDelete(view2, dir) {
  if (!(view2.state.selection instanceof prosemirrorState$3.TextSelection)) {
    return true;
  }
  var ref = view2.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view2.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view2.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view2.dispatch(tr);
    return true;
  }
  return false;
}
function getMods(event) {
  var result$$1 = "";
  if (event.ctrlKey) {
    result$$1 += "c";
  }
  if (event.metaKey) {
    result$$1 += "m";
  }
  if (event.altKey) {
    result$$1 += "a";
  }
  if (event.shiftKey) {
    result$$1 += "s";
  }
  return result$$1;
}
function captureKeyDown(view2, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || result.mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view2, -1) || skipIgnoredNodesLeft(view2);
  } else if (code == 46 || result.mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view2, 1) || skipIgnoredNodesRight(view2);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37) {
    return selectHorizontally(view2, -1) || skipIgnoredNodesLeft(view2);
  } else if (code == 39) {
    return selectHorizontally(view2, 1) || skipIgnoredNodesRight(view2);
  } else if (code == 38) {
    return selectVertically(view2, -1) || skipIgnoredNodesLeft(view2);
  } else if (code == 40) {
    return selectVertically(view2, 1) || skipIgnoredNodesRight(view2);
  } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
var TrackedRecord2 = function TrackedRecord3(prev2, mapping, state) {
  this.prev = prev2;
  this.mapping = mapping;
  this.state = state;
};
var TrackMappings2 = function TrackMappings3(state) {
  this.seen = [new TrackedRecord2(null, null, state)];
  prosemirrorState$3.EditorState.addApplyListener(this.track = this.track.bind(this));
};
TrackMappings2.prototype.destroy = function destroy7() {
  prosemirrorState$3.EditorState.removeApplyListener(this.track);
};
TrackMappings2.prototype.find = function find3(state) {
  var this$1$1 = this;
  for (var i = this.seen.length - 1; i >= 0; i--) {
    var record = this$1$1.seen[i];
    if (record.state == state) {
      return record;
    }
  }
};
TrackMappings2.prototype.track = function track2(old, tr, state) {
  var found2 = this.seen.length < 200 ? this.find(old) : null;
  if (found2) {
    this.seen.push(new TrackedRecord2(found2, tr.docChanged ? tr.mapping : null, state));
  }
};
TrackMappings2.prototype.getMapping = function getMapping2(state, appendTo) {
  var found2 = this.find(state);
  if (!found2) {
    return null;
  }
  var mappings = [];
  for (var rec = found2; rec; rec = rec.prev) {
    if (rec.mapping) {
      mappings.push(rec.mapping);
    }
  }
  var result2 = appendTo || new prosemirrorTransform$1.Mapping();
  for (var i = mappings.length - 1; i >= 0; i--) {
    result2.appendMapping(mappings[i]);
  }
  return result2;
};
var SelectionReader2 = function SelectionReader3(view2) {
  var this$1$1 = this;
  this.view = view2;
  this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;
  this.lastSelection = view2.state.selection;
  this.ignoreUpdates = false;
  this.poller = poller(this);
  view2.dom.addEventListener("focus", function() {
    return this$1$1.poller.start(hasFocusAndSelection(this$1$1.view));
  });
  view2.dom.addEventListener("blur", function() {
    return this$1$1.poller.stop();
  });
  if (!view2.editable) {
    this.poller.start(false);
  }
};
SelectionReader2.prototype.destroy = function destroy8() {
  this.poller.stop();
};
SelectionReader2.prototype.poll = function poll4(origin) {
  this.poller.poll(origin);
};
SelectionReader2.prototype.editableChanged = function editableChanged2() {
  if (!this.view.editable) {
    this.poller.start();
  } else if (!hasFocusAndSelection(this.view)) {
    this.poller.stop();
  }
};
SelectionReader2.prototype.domChanged = function domChanged2() {
  var sel = this.view.root.getSelection();
  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;
};
SelectionReader2.prototype.storeDOMState = function storeDOMState2(selection) {
  var sel = this.view.root.getSelection();
  this.lastAnchorNode = sel.anchorNode;
  this.lastAnchorOffset = sel.anchorOffset;
  this.lastHeadNode = sel.focusNode;
  this.lastHeadOffset = sel.focusOffset;
  this.lastSelection = selection;
};
SelectionReader2.prototype.clearDOMState = function clearDOMState2() {
  this.lastAnchorNode = this.lastSelection = null;
};
SelectionReader2.prototype.readFromDOM = function readFromDOM2(origin) {
  if (this.ignoreUpdates || !this.domChanged() || !hasFocusAndSelection(this.view)) {
    return;
  }
  if (!this.view.inDOMChange) {
    this.view.domObserver.flush();
  }
  if (this.view.inDOMChange) {
    return;
  }
  var domSel = this.view.root.getSelection(), doc2 = this.view.state.doc;
  var nearestDesc3 = this.view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc3.size == 0;
  var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc3 && !nearestDesc3.node) {
      nearestDesc3 = nearestDesc3.parent;
    }
    if (nearestDesc3 && nearestDesc3.node.isAtom && prosemirrorState$3.NodeSelection.isSelectable(nearestDesc3.node) && nearestDesc3.parent) {
      var pos = nearestDesc3.posBefore;
      selection = new prosemirrorState$3.NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    $anchor = doc2.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset));
  }
  if (!selection) {
    var bias = origin == "pointer" || this.view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(this.view, $anchor, $head, bias);
  }
  var preserve = !inWidget && head == selection.head && $anchor.pos == selection.anchor && (!this.view.cursorWrapper || domSel.isCollapsed && origin != "pointer");
  if (preserve) {
    this.storeDOMState(selection);
  }
  if (!this.view.state.selection.eq(selection)) {
    var tr = this.view.state.tr.setSelection(selection);
    if (origin == "pointer") {
      tr.setMeta("pointer", true);
    }
    this.view.dispatch(tr);
  } else if (!preserve) {
    selectionToDOM(this.view);
  }
};
var SelectionChangePoller2 = function SelectionChangePoller3(reader) {
  var this$1$1 = this;
  this.listening = false;
  this.curOrigin = null;
  this.originTime = 0;
  this.reader = reader;
  this.readFunc = function() {
    return reader.readFromDOM(this$1$1.originTime > Date.now() - 50 ? this$1$1.curOrigin : null);
  };
};
SelectionChangePoller2.prototype.poll = function poll5(origin) {
  this.curOrigin = origin;
  this.originTime = Date.now();
};
SelectionChangePoller2.prototype.start = function start11(andRead) {
  if (!this.listening) {
    var doc2 = this.reader.view.dom.ownerDocument;
    doc2.addEventListener("selectionchange", this.readFunc);
    this.listening = true;
    if (andRead) {
      this.readFunc();
    }
  }
};
SelectionChangePoller2.prototype.stop = function stop4() {
  if (this.listening) {
    var doc2 = this.reader.view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", this.readFunc);
    this.listening = false;
  }
};
var TimeoutPoller2 = function TimeoutPoller3(reader) {
  this.polling = null;
  this.reader = reader;
  this.pollFunc = this.doPoll.bind(this, null);
};
TimeoutPoller2.prototype.doPoll = function doPoll2(origin) {
  var view2 = this.reader.view;
  if (view2.focused || !view2.editable) {
    this.reader.readFromDOM(origin);
    this.polling = setTimeout(this.pollFunc, 100);
  } else {
    this.polling = null;
  }
};
TimeoutPoller2.prototype.poll = function poll6(origin) {
  clearTimeout(this.polling);
  this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0);
};
TimeoutPoller2.prototype.start = function start12() {
  if (this.polling == null) {
    this.poll();
  }
};
TimeoutPoller2.prototype.stop = function stop5() {
  clearTimeout(this.polling);
  this.polling = null;
};
function poller(reader) {
  return new ("onselectionchange" in document ? SelectionChangePoller2 : TimeoutPoller2)(reader);
}
function selectionToDOM(view2, takeFocus) {
  var sel = view2.state.selection;
  syncNodeSelection(view2, sel);
  if (view2.editable && !view2.hasFocus()) {
    if (!takeFocus) {
      return;
    }
    if (result.gecko && result.gecko_version <= 55) {
      view2.selectionReader.ignoreUpdates = true;
      view2.dom.focus();
      view2.selectionReader.ignoreUpdates = false;
    }
  } else if (!view2.editable && !hasSelection(view2) && !takeFocus) {
    return;
  }
  var reader = view2.selectionReader;
  if (reader.lastSelection && reader.lastSelection.eq(sel) && !reader.domChanged()) {
    return;
  }
  reader.ignoreUpdates = true;
  if (view2.cursorWrapper) {
    selectCursorWrapper(view2);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState$3.TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view2, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view2, sel.to);
      }
    }
    view2.docView.setSelection(anchor, head, view2.root);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditableFrom.contentEditable = "false";
      }
      if (resetEditableTo) {
        resetEditableTo.contentEditable = "false";
      }
    }
    if (sel.visible) {
      view2.dom.classList.remove("ProseMirror-hideselection");
    } else if (anchor != head) {
      view2.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view2);
      }
    }
  }
  reader.storeDOMState(sel);
  reader.ignoreUpdates = false;
}
var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
function temporarilyEditableNear(view2, pos) {
  var ref = view2.docView.domFromPos(pos);
  var node18 = ref.node;
  var offset2 = ref.offset;
  var after8 = offset2 < node18.childNodes.length ? node18.childNodes[offset2] : null;
  var before8 = offset2 ? node18.childNodes[offset2 - 1] : null;
  if ((!after8 || after8.contentEditable == "false") && (!before8 || before8.contentEditable == "false")) {
    if (after8) {
      after8.contentEditable = "true";
      return after8;
    } else if (before8) {
      before8.contentEditable = "true";
      return before8;
    }
  }
}
function removeClassOnSelectionChange(view2) {
  var doc2 = view2.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view2.hideSelectionGuard);
  var domSel = view2.root.getSelection();
  var node18 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view2.hideSelectionGuard = function() {
    if (domSel.anchorNode != node18 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view2.hideSelectionGuard);
      view2.dom.classList.remove("ProseMirror-hideselection");
    }
  });
}
function selectCursorWrapper(view2) {
  var domSel = view2.root.getSelection(), range = document.createRange();
  var node18 = view2.cursorWrapper.type.widget;
  range.setEnd(node18, node18.childNodes.length);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!view2.state.selection.visible && result.ie && result.ie_version <= 11) {
    node18.disabled = true;
    node18.disabled = false;
  }
}
function syncNodeSelection(view2, sel) {
  if (sel instanceof prosemirrorState$3.NodeSelection) {
    var desc = view2.docView.descAt(sel.from);
    if (desc != view2.lastSelectedViewDesc) {
      clearNodeSelection(view2);
      if (desc) {
        desc.selectNode();
      }
      view2.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view2);
  }
}
function clearNodeSelection(view2) {
  if (view2.lastSelectedViewDesc) {
    view2.lastSelectedViewDesc.deselectNode();
    view2.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view2, $anchor, $head, bias) {
  return view2.someProp("createSelectionBetween", function(f2) {
    return f2(view2, $anchor, $head);
  }) || prosemirrorState$3.TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view2) {
  if (view2.editable && view2.root.activeElement != view2.dom) {
    return false;
  }
  return hasSelection(view2);
}
function hasSelection(view2) {
  var sel = view2.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view2.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode);
  } catch (_) {
    return false;
  }
}
var DOMChange2 = function DOMChange3(view2, composing) {
  var this$1$1 = this;
  this.view = view2;
  this.state = view2.state;
  this.composing = composing;
  this.from = this.to = null;
  this.typeOver = false;
  this.timeout = composing ? null : setTimeout(function() {
    return this$1$1.finish();
  }, DOMChange3.commitTimeout);
  this.trackMappings = new TrackMappings2(view2.state);
  this.mapping = new prosemirrorTransform$1.Mapping();
  this.mappingTo = view2.state;
};
DOMChange2.prototype.addRange = function addRange2(from12, to) {
  if (this.from == null) {
    this.from = from12;
    this.to = to;
  } else {
    this.from = Math.min(from12, this.from);
    this.to = Math.max(to, this.to);
  }
};
DOMChange2.prototype.changedRange = function changedRange2() {
  if (this.from == null) {
    return rangeAroundSelection(this.state.selection);
  }
  var $from = this.state.doc.resolve(Math.min(this.from, this.state.selection.from)), $to = this.state.doc.resolve(this.to);
  var shared2 = $from.sharedDepth(this.to);
  return { from: $from.before(shared2 + 1), to: $to.after(shared2 + 1) };
};
DOMChange2.prototype.markDirty = function markDirty4(range) {
  if (this.from == null) {
    this.view.docView.markDirty((range = range || this.changedRange()).from, range.to);
  } else {
    this.view.docView.markDirty(this.from, this.to);
  }
};
DOMChange2.prototype.stateUpdated = function stateUpdated2(state) {
  if (this.trackMappings.getMapping(state, this.mapping)) {
    this.trackMappings.destroy();
    this.trackMappings = new TrackMappings2(state);
    this.mappingTo = state;
    return true;
  } else {
    this.markDirty();
    this.destroy();
    return false;
  }
};
DOMChange2.prototype.finish = function finish14(force) {
  clearTimeout(this.timeout);
  if (this.composing && !force) {
    return;
  }
  this.view.domObserver.flush();
  var range = this.changedRange();
  this.markDirty(range);
  this.destroy();
  var sel = this.state.selection, allowTypeOver = this.typeOver && sel instanceof prosemirrorState$3.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor);
  readDOMChange(this.view, this.mapping, this.state, range, allowTypeOver);
  if (this.view.docView.dirty) {
    this.view.updateState(this.view.state);
  }
};
DOMChange2.prototype.destroy = function destroy9() {
  clearTimeout(this.timeout);
  this.trackMappings.destroy();
  this.view.inDOMChange = null;
};
DOMChange2.prototype.compositionEnd = function compositionEnd2() {
  var this$1$1 = this;
  if (this.composing) {
    this.composing = false;
    this.timeout = setTimeout(function() {
      return this$1$1.finish();
    }, 50);
  }
};
DOMChange2.start = function start13(view2, composing) {
  if (view2.inDOMChange) {
    if (composing) {
      clearTimeout(view2.inDOMChange.timeout);
      view2.inDOMChange.composing = true;
    }
  } else {
    view2.inDOMChange = new DOMChange2(view2, composing);
  }
  return view2.inDOMChange;
};
DOMChange2.commitTimeout = 20;
function parseBetween(view2, oldState, range) {
  var ref = view2.docView.parseRange(range.from, range.to);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from12 = ref.from;
  var to = ref.to;
  var domSel = view2.root.getSelection(), find5 = null, anchor = domSel.anchorNode;
  if (anchor && view2.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find5 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find5.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  var startDoc = oldState.doc;
  var parser = view2.someProp("domParser") || prosemirrorModel$1.DOMParser.fromSchema(view2.state.schema);
  var $from = startDoc.resolve(from12);
  var sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find5,
    ruleFromNode: ruleFromNode(parser, $from),
    context: $from
  });
  if (find5 && find5[0].pos != null) {
    var anchor$1 = find5[0].pos, head = find5[1] && find5[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from12, head: head + from12 };
  }
  return { doc: doc2, sel, from: from12, to };
}
function ruleFromNode(parser, context) {
  return function(dom) {
    var desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        return parser.matchTag(document.createElement("li"), context);
      } else if (dom.parentNode.lastChild == dom) {
        return { ignore: true };
      }
    }
  };
}
function isAtEnd($pos, depth) {
  for (var i = depth || 0; i < $pos.depth; i++) {
    if ($pos.index(i) + 1 < $pos.node(i).childCount) {
      return false;
    }
  }
  return $pos.parentOffset == $pos.parent.content.size;
}
function isAtStart($pos, depth) {
  for (var i = depth || 0; i < $pos.depth; i++) {
    if ($pos.index(0) > 0) {
      return false;
    }
  }
  return $pos.parentOffset == 0;
}
function rangeAroundSelection(selection) {
  var $from = selection.$anchor.min(selection.$head), $to = selection.$anchor.max(selection.$head);
  if ($from.sameParent($to) && $from.parent.inlineContent && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {
    var startOff = Math.max(0, $from.parentOffset);
    var size = $from.parent.content.size;
    var endOff = Math.min(size, $to.parentOffset);
    if (startOff > 0) {
      startOff = $from.parent.childBefore(startOff).offset;
    }
    if (endOff < size) {
      var after8 = $from.parent.childAfter(endOff);
      endOff = after8.offset + after8.node.nodeSize;
    }
    var nodeStart = $from.start();
    return { from: nodeStart + startOff, to: nodeStart + endOff };
  } else {
    for (var depth = 0; ; depth++) {
      var fromStart = isAtStart($from, depth + 1), toEnd = isAtEnd($to, depth + 1);
      if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {
        var from12 = $from.before(depth + 1), to = $to.after(depth + 1);
        if (fromStart && $from.index(depth) > 0) {
          from12 -= $from.node(depth).child($from.index(depth) - 1).nodeSize;
        }
        if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount) {
          to += $to.node(depth).child($to.index(depth) + 1).nodeSize;
        }
        return { from: from12, to };
      }
    }
  }
}
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function readDOMChange(view2, mapping, oldState, range, allowTypeOver) {
  var parse16 = parseBetween(view2, oldState, range);
  var doc2 = oldState.doc, compare = doc2.slice(parse16.from, parse16.to);
  var preferredPos, preferredSide;
  if (view2.lastKeyCode === 8 && Date.now() - 100 < view2.lastKeyCodeTime) {
    preferredPos = oldState.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = oldState.selection.from;
    preferredSide = "start";
  }
  view2.lastKeyCode = null;
  var change = findDiff(compare.content, parse16.doc.content, parse16.from, preferredPos, preferredSide);
  if (!change) {
    if (allowTypeOver) {
      var state = view2.state, sel = state.selection;
      view2.dispatch(state.tr.replaceSelectionWith(state.schema.text(state.doc.textBetween(sel.from, sel.to)), true).scrollIntoView());
    } else if (parse16.sel) {
      var sel$1 = resolveSelection(view2, view2.state.doc, mapping, parse16.sel);
      if (sel$1 && !sel$1.eq(view2.state.selection)) {
        view2.dispatch(view2.state.tr.setSelection(sel$1));
      }
    }
    return;
  }
  var $from = parse16.doc.resolveNoCache(change.start - parse16.from);
  var $to = parse16.doc.resolveNoCache(change.endB - parse16.from);
  var nextSel;
  if (!$from.sameParent($to) && $from.pos < parse16.doc.content.size && (nextSel = prosemirrorState$3.Selection.findFrom(parse16.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos && view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, keyEvent(13, "Enter"));
  })) {
    return;
  }
  if (oldState.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, keyEvent(8, "Backspace"));
  })) {
    return;
  }
  var from12 = mapping.map(change.start), to = mapping.map(change.endA, -1);
  var tr, storedMarks, markChange, $from1;
  if ($from.sameParent($to) && $from.parent.inlineContent) {
    if ($from.pos == $to.pos) {
      tr = view2.state.tr.delete(from12, to);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange(
      $from.parent.content.cut($from.parentOffset, $to.parentOffset),
      $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())
    ))) {
      tr = view2.state.tr;
      if (markChange.type == "add") {
        tr.addMark(from12, to, markChange.mark);
      } else {
        tr.removeMark(from12, to, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text8 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view2.someProp("handleTextInput", function(f2) {
        return f2(view2, from12, to, text8);
      })) {
        return;
      }
      tr = view2.state.tr.insertText(text8, from12, to);
    }
  }
  if (!tr) {
    tr = view2.state.tr.replace(from12, to, parse16.doc.slice(change.start - parse16.from, change.endB - parse16.from));
  }
  if (parse16.sel) {
    var sel$2 = resolveSelection(view2, tr.doc, mapping, parse16.sel);
    if (sel$2) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view2.dispatch(tr.scrollIntoView());
}
function resolveSelection(view2, doc2, mapping, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween(
    view2,
    doc2.resolve(mapping.map(parsedSel.anchor)),
    doc2.resolve(mapping.map(parsedSel.head))
  );
}
function isMarkChange(cur, prev2) {
  var curMarks = cur.firstChild.marks, prevMarks = prev2.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark15, update4;
  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }
  for (var i$12 = 0; i$12 < curMarks.length; i$12++) {
    removed = curMarks[i$12].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark15 = added[0];
    type = "add";
    update4 = function(node18) {
      return node18.mark(mark15.addToSet(node18.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark15 = removed[0];
    type = "remove";
    update4 = function(node18) {
      return node18.mark(mark15.removeFromSet(node18.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev2.childCount; i$2++) {
    updated.push(update4(prev2.child(i$2)));
  }
  if (prosemirrorModel$1.Fragment.from(updated).eq(cur)) {
    return { mark: mark15, type };
  }
}
function looksLikeJoin(old, start16, end8, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end8 - start16 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start16);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end8 || skipClosingAndOpening($next, true, false) < end8) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end8 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end8++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next2 && !next2.isLeaf) {
      next2 = next2.firstChild;
      end8++;
    }
  }
  return end8;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start16 = a.findDiffStart(b, pos);
  if (start16 == null) {
    return null;
  }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start16 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start16;
  }
  if (endA < start16 && a.size < b.size) {
    var move3 = preferredPos <= start16 && preferredPos >= endA ? start16 - preferredPos : 0;
    start16 -= move3;
    endB = start16 + (endB - endA);
    endA = start16;
  } else if (endB < start16) {
    var move$1 = preferredPos <= start16 && preferredPos >= endB ? start16 - preferredPos : 0;
    start16 -= move$1;
    endA = start16 + (endA - endB);
    endB = start16;
  }
  return { start: start16, endA, endB };
}
function serializeForClipboard(view2, slice11) {
  var context = [];
  var content2 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node18 = content2.firstChild;
    context.push(node18.type.name, node18.type.hasRequiredAttrs() ? node18.attrs : null);
    content2 = node18.content;
  }
  var serializer = view2.someProp("clipboardSerializer") || prosemirrorModel$1.DOMSerializer.fromSchema(view2.state.schema);
  var wrap2 = document.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content2));
  var firstChild = wrap2.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = document.createElement(needsWrap[i]);
      while (wrap2.firstChild) {
        wrapper.appendChild(wrap2.firstChild);
      }
      wrap2.appendChild(wrapper);
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text8 = view2.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice11);
  }) || slice11.content.textBetween(0, slice11.content.size, "\n\n");
  return { dom: wrap2, text: text8 };
}
function parseFromClipboard(view2, text8, html2, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice11;
  if (!html2 && !text8) {
    return null;
  }
  if ((plainText || inCode || !html2) && text8) {
    view2.someProp("transformPastedText", function(f2) {
      text8 = f2(text8);
    });
    if (inCode) {
      return new prosemirrorModel$1.Slice(prosemirrorModel$1.Fragment.from(view2.state.schema.text(text8)), 0, 0);
    }
    var parsed = view2.someProp("clipboardTextParser", function(f2) {
      return f2(text8, $context);
    });
    if (parsed) {
      slice11 = parsed;
    } else {
      dom = document.createElement("div");
      text8.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
        dom.appendChild(document.createElement("p")).textContent = block;
      });
    }
  } else {
    view2.someProp("transformPastedHTML", function(f2) {
      return html2 = f2(html2);
    });
    dom = readHTML(html2);
  }
  if (!slice11) {
    var parser = view2.someProp("clipboardParser") || view2.someProp("domParser") || prosemirrorModel$1.DOMParser.fromSchema(view2.state.schema);
    slice11 = parser.parseSlice(dom, { preserveWhitespace: true, context: $context });
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (sliceData) {
    slice11 = addContext(new prosemirrorModel$1.Slice(
      slice11.content,
      Math.min(slice11.openStart, +sliceData[1]),
      Math.min(slice11.openEnd, +sliceData[2])
    ), sliceData[3]);
  } else {
    slice11 = prosemirrorModel$1.Slice.maxOpen(normalizeSiblings(slice11.content, $context), false);
  }
  view2.someProp("transformPasted", function(f2) {
    slice11 = f2(slice11);
  });
  return slice11;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d2) {
    var parent = $context.node(d2);
    var match2 = parent.contentMatchAt($context.index(d2));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node18) {
      if (!result2) {
        return;
      }
      var wrap2 = match2.findWrapping(node18.type), inLast;
      if (!wrap2) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap2, lastWrap, node18, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node18, wrap2);
        result2.push(wrapped);
        match2 = match2.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap2;
      }
    });
    if (result2) {
      return { v: prosemirrorModel$1.Fragment.from(result2) };
    }
  };
  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop(d);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers(node18, wrap2, from12) {
  if (from12 === void 0)
    from12 = 0;
  for (var i = wrap2.length - 1; i >= from12; i--) {
    node18 = wrap2[i].create(null, prosemirrorModel$1.Fragment.from(node18));
  }
  return node18;
}
function addToSibling(wrap2, lastWrap, node18, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap2, lastWrap, node18, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node18.type : wrap2[depth + 1])) {
      return sibling.copy(sibling.content.append(prosemirrorModel$1.Fragment.from(withWrappers(node18, wrap2, depth + 1))));
    }
  }
}
function closeRight(node18, depth) {
  if (depth == 0) {
    return node18;
  }
  var fragment = node18.content.replaceChild(node18.childCount - 1, closeRight(node18.lastChild, depth - 1));
  var fill = node18.contentMatchAt(node18.childCount).fillBefore(prosemirrorModel$1.Fragment.empty, true);
  return node18.copy(fragment.append(fill));
}
var wrapMap = {
  thead: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var detachedDoc = null;
function readHTML(html2) {
  var metas = /(\s*<meta [^>]*>)*/.exec(html2);
  if (metas) {
    html2 = html2.slice(metas[0].length);
  }
  var doc2 = detachedDoc || (detachedDoc = document.implementation.createHTMLDocument("title"));
  var elt = doc2.createElement("div");
  var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(html2), wrap2, depth = 0;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html2 = wrap2.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html2 + wrap2.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
    depth = wrap2.length;
  }
  elt.innerHTML = html2;
  for (var i = 0; i < depth; i++) {
    elt = elt.firstChild;
  }
  return elt;
}
function addContext(slice11, context) {
  if (!slice11.size) {
    return slice11;
  }
  var schema2 = slice11.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice11;
  }
  var content2 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema2.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content2 = prosemirrorModel$1.Fragment.from(type.create(array[i + 1], content2));
    openStart++;
    openEnd++;
  }
  return new prosemirrorModel$1.Slice(content2, openStart, openEnd);
}
var observeOptions = { childList: true, characterData: true, attributes: true, subtree: true, characterDataOldValue: true };
var useCharData = result.ie && result.ie_version <= 11;
var DOMObserver2 = function DOMObserver3(view2) {
  var this$1$1 = this;
  this.view = view2;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    return this$1$1.registerMutations(mutations);
  });
  if (useCharData) {
    this.onCharData = function(e) {
      return this$1$1.registerMutation({ target: e.target, type: "characterData", oldValue: e.prevValue });
    };
  }
};
DOMObserver2.prototype.start = function start14() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions);
  }
  if (useCharData) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
};
DOMObserver2.prototype.stop = function stop6() {
  if (this.observer) {
    this.flush();
    this.observer.disconnect();
  }
  if (useCharData) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
};
DOMObserver2.prototype.flush = function flush2() {
  if (this.observer) {
    this.registerMutations(this.observer.takeRecords());
  }
};
DOMObserver2.prototype.registerMutations = function registerMutations2(mutations) {
  var this$1$1 = this;
  for (var i = 0; i < mutations.length; i++) {
    this$1$1.registerMutation(mutations[i]);
  }
};
DOMObserver2.prototype.registerMutation = function registerMutation2(mut) {
  if (!this.view.editable) {
    return;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable")) {
    return;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return;
  }
  var from12, to;
  if (mut.type == "childList") {
    var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target ? domIndex(mut.previousSibling) + 1 : 0;
    if (fromOffset == -1) {
      return;
    }
    from12 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target ? domIndex(mut.nextSibling) : mut.target.childNodes.length;
    if (toOffset == -1) {
      return;
    }
    to = desc.localPosFromDOM(mut.target, toOffset, 1);
  } else if (mut.type == "attributes") {
    from12 = desc.posAtStart - desc.border;
    to = desc.posAtEnd + desc.border;
  } else {
    from12 = desc.posAtStart;
    to = desc.posAtEnd;
    if (mut.target.nodeValue == mut.oldValue) {
      DOMChange2.start(this.view).typeOver = true;
    }
  }
  DOMChange2.start(this.view).addRange(from12, to);
};
var handlers = {};
var editHandlers = {};
function initInput(view2) {
  view2.shiftKey = false;
  view2.mouseDown = null;
  view2.inDOMChange = null;
  view2.lastKeyCode = null;
  view2.lastKeyCodeTime = 0;
  view2.domObserver = new DOMObserver2(view2);
  view2.domObserver.start();
  view2.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers[event2];
    view2.dom.addEventListener(event2, view2.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view2, event3) && !runCustomHandler(view2, event3) && (view2.editable || !(event3.type in editHandlers))) {
        handler(view2, event3);
      }
    });
  };
  for (var event in handlers)
    loop(event);
  ensureListeners(view2);
}
function destroyInput(view2) {
  view2.domObserver.stop();
  if (view2.inDOMChange) {
    view2.inDOMChange.destroy();
  }
  for (var type in view2.eventHandlers) {
    view2.dom.removeEventListener(type, view2.eventHandlers[type]);
  }
}
function ensureListeners(view2) {
  view2.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view2.eventHandlers[type]) {
        view2.dom.addEventListener(type, view2.eventHandlers[type] = function(event) {
          return runCustomHandler(view2, event);
        });
      }
    }
  });
}
function runCustomHandler(view2, event) {
  return view2.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view2, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view2, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node18 = event.target; node18 != view2.dom; node18 = node18.parentNode) {
    if (!node18 || node18.nodeType == 11 || node18.pmViewDesc && node18.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view2, event) {
  if (!runCustomHandler(view2, event) && handlers[event.type] && (view2.editable || !(event.type in editHandlers))) {
    handlers[event.type](view2, event);
  }
}
editHandlers.keydown = function(view2, event) {
  if (event.keyCode == 16) {
    view2.shiftKey = true;
  }
  if (view2.inDOMChange) {
    return;
  }
  view2.lastKeyCode = event.keyCode;
  view2.lastKeyCodeTime = Date.now();
  if (view2.someProp("handleKeyDown", function(f2) {
    return f2(view2, event);
  }) || captureKeyDown(view2, event)) {
    event.preventDefault();
  } else {
    view2.selectionReader.poll();
  }
};
editHandlers.keyup = function(view2, e) {
  if (e.keyCode == 16) {
    view2.shiftKey = false;
  }
};
editHandlers.keypress = function(view2, event) {
  if (view2.inDOMChange || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
    return;
  }
  if (view2.someProp("handleKeyPress", function(f2) {
    return f2(view2, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view2.state.selection;
  if (!(sel instanceof prosemirrorState$3.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text8 = String.fromCharCode(event.charCode);
    if (!view2.someProp("handleTextInput", function(f2) {
      return f2(view2, sel.$from.pos, sel.$to.pos, text8);
    })) {
      view2.dispatch(view2.state.tr.insertText(text8).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
var lastClick = { time: 0, x: 0, y: 0 };
var oneButLastClick = lastClick;
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view2, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view2.state.doc.resolve(inside);
  var loop = function(i2) {
    if (view2.someProp(propName, function(f2) {
      return i2 > $pos.depth ? f2(view2, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f2(view2, pos, $pos.node(i2), $pos.before(i2), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop(i);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection(view2, selection, origin) {
  if (!view2.focused) {
    view2.focus();
  }
  var tr = view2.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view2.dispatch(tr);
}
function selectClickedLeaf(view2, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view2.state.doc.resolve(inside), node18 = $pos.nodeAfter;
  if (node18 && node18.isAtom && prosemirrorState$3.NodeSelection.isSelectable(node18)) {
    updateSelection(view2, new prosemirrorState$3.NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view2, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view2.state.selection, selectedNode, selectAt;
  if (sel instanceof prosemirrorState$3.NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view2.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirrorState$3.NodeSelection.isSelectable(node18)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view2, prosemirrorState$3.NodeSelection.create(view2.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view2, pos, inside, event, selectNode) {
  return runHandlerOnContext(view2, "handleClickOn", pos, inside, event) || view2.someProp("handleClick", function(f2) {
    return f2(view2, pos, event);
  }) || (selectNode ? selectClickedNode(view2, inside) : selectClickedLeaf(view2, inside));
}
function handleDoubleClick(view2, pos, inside, event) {
  return runHandlerOnContext(view2, "handleDoubleClickOn", pos, inside, event) || view2.someProp("handleDoubleClick", function(f2) {
    return f2(view2, pos, event);
  });
}
function handleTripleClick(view2, pos, inside, event) {
  return runHandlerOnContext(view2, "handleTripleClickOn", pos, inside, event) || view2.someProp("handleTripleClick", function(f2) {
    return f2(view2, pos, event);
  }) || defaultTripleClick(view2, inside);
}
function defaultTripleClick(view2, inside) {
  var doc2 = view2.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view2, prosemirrorState$3.TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node18 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node18.inlineContent) {
      updateSelection(view2, prosemirrorState$3.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node18.content.size), "pointer");
    } else if (prosemirrorState$3.NodeSelection.isSelectable(node18)) {
      updateSelection(view2, prosemirrorState$3.NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view2) {
  if (!view2.inDOMChange) {
    return false;
  }
  view2.inDOMChange.finish(true);
  return true;
}
var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
handlers.mousedown = function(view2, event) {
  var flushed = forceDOMFlush(view2);
  var now2 = Date.now(), type;
  if (now2 - lastClick.time >= 500 || !isNear(event, lastClick) || event[selectNodeModifier]) {
    type = "singleClick";
  } else if (now2 - oneButLastClick.time >= 600 || !isNear(event, oneButLastClick)) {
    type = "doubleClick";
  } else {
    type = "tripleClick";
  }
  oneButLastClick = lastClick;
  lastClick = { time: now2, x: event.clientX, y: event.clientY };
  var pos = view2.posAtCoords(eventCoords(event));
  if (!pos) {
    return;
  }
  if (type == "singleClick") {
    view2.mouseDown = new MouseDown2(view2, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view2, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    view2.selectionReader.poll("pointer");
  }
};
var MouseDown2 = function MouseDown3(view2, pos, event, flushed) {
  var this$1$1 = this;
  this.view = view2;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view2.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view2.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  this.target = flushed ? null : event.target;
  if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || view2.state.selection instanceof prosemirrorState$3.NodeSelection && targetPos == view2.state.selection.from) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        return this$1$1.target.setAttribute("contentEditable", "false");
      }, 20);
    }
    this.view.domObserver.start();
  }
  view2.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view2.root.addEventListener("mousemove", this.move = this.move.bind(this));
  view2.selectionReader.poll("pointer");
};
MouseDown2.prototype.done = function done2() {
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = false;
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  this.view.mouseDown = null;
};
MouseDown2.prototype.up = function up2(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  if (this.allowDefault) {
    this.view.selectionReader.poll("pointer");
  } else if (handleSingleClick(this.view, this.pos.pos, this.pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (this.flushed) {
    updateSelection(this.view, prosemirrorState$3.Selection.near(this.view.state.doc.resolve(this.pos.pos)), "pointer");
    event.preventDefault();
  } else {
    this.view.selectionReader.poll("pointer");
  }
};
MouseDown2.prototype.move = function move2(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  this.view.selectionReader.poll("pointer");
};
handlers.touchdown = function(view2) {
  forceDOMFlush(view2);
  view2.selectionReader.poll("pointer");
};
handlers.contextmenu = function(view2) {
  return forceDOMFlush(view2);
};
editHandlers.compositionstart = editHandlers.compositionupdate = function(view2) {
  DOMChange2.start(view2, true);
};
editHandlers.compositionend = function(view2, e) {
  if (!view2.inDOMChange) {
    if (e.data) {
      DOMChange2.start(view2, true);
    } else {
      return;
    }
  }
  view2.inDOMChange.compositionEnd();
};
editHandlers.input = function(view2) {
  var change = DOMChange2.start(view2);
  if (!change.composing) {
    change.finish();
  }
};
function captureCopy(view2, dom) {
  var doc2 = dom.ownerDocument;
  var wrap2 = doc2.body.appendChild(doc2.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = doc2.createRange();
  range.selectNodeContents(dom);
  view2.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    doc2.body.removeChild(wrap2);
    view2.focus();
  }, 50);
}
var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios;
handlers.copy = editHandlers.cut = function(view2, e) {
  var sel = view2.state.selection, cut15 = e.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI ? null : e.clipboardData;
  var slice11 = sel.content();
  var ref = serializeForClipboard(view2, slice11);
  var dom = ref.dom;
  var text8 = ref.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text8);
  } else {
    captureCopy(view2, dom);
  }
  if (cut15) {
    view2.dispatch(view2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode(slice11) {
  return slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1 ? slice11.content.firstChild : null;
}
function capturePaste(view2, e) {
  var doc2 = view2.dom.ownerDocument;
  var plainText = view2.shiftKey || view2.state.selection.$from.parent.type.spec.code;
  var target = doc2.body.appendChild(doc2.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view2.focus();
    doc2.body.removeChild(target);
    if (plainText) {
      doPaste(view2, target.value, null, e);
    } else {
      doPaste(view2, target.textContent, target.innerHTML, e);
    }
  }, 50);
}
function doPaste(view2, text8, html2, e) {
  var slice11 = parseFromClipboard(view2, text8, html2, view2.shiftKey, view2.state.selection.$from);
  if (!slice11) {
    return false;
  }
  if (view2.someProp("handlePaste", function(f2) {
    return f2(view2, e, slice11);
  })) {
    return true;
  }
  var singleNode = sliceSingleNode(slice11);
  var tr = singleNode ? view2.state.tr.replaceSelectionWith(singleNode, view2.shiftKey) : view2.state.tr.replaceSelection(slice11);
  view2.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = function(view2, e) {
  var data = brokenClipboardAPI ? null : e.clipboardData;
  if (data && doPaste(view2, data.getData("text/plain"), data.getData("text/html"), e)) {
    e.preventDefault();
  } else {
    capturePaste(view2, e);
  }
};
var Dragging2 = function Dragging3(slice11, move3) {
  this.slice = slice11;
  this.move = move3;
};
function dropPos(slice11, $pos) {
  if (!slice11 || !slice11.content.size) {
    return $pos.pos;
  }
  var content2 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content2 = content2.firstChild.content;
  }
  for (var d = $pos.depth; d >= 0; d--) {
    var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
    if ($pos.node(d).canReplace(insertPos, insertPos, content2)) {
      return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return $pos.pos;
}
var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
handlers.dragstart = function(view2, e) {
  var mouseDown = view2.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e.dataTransfer) {
    return;
  }
  var sel = view2.state.selection;
  var pos = sel.empty ? null : view2.posAtCoords(eventCoords(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState$3.NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view2.dispatch(view2.state.tr.setSelection(prosemirrorState$3.NodeSelection.create(view2.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view2.docView.nearestDesc(e.target, true);
    if (!desc || !desc.node.type.spec.draggable || desc == view2.docView) {
      return;
    }
    view2.dispatch(view2.state.tr.setSelection(prosemirrorState$3.NodeSelection.create(view2.state.doc, desc.posBefore)));
  }
  var slice11 = view2.state.selection.content();
  var ref = serializeForClipboard(view2, slice11);
  var dom = ref.dom;
  var text8 = ref.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  if (!brokenClipboardAPI) {
    e.dataTransfer.setData("text/plain", text8);
  }
  view2.dragging = new Dragging2(slice11, !e[dragCopyModifier]);
};
handlers.dragend = function(view2) {
  window.setTimeout(function() {
    return view2.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function(_, e) {
  return e.preventDefault();
};
editHandlers.drop = function(view2, e) {
  var dragging = view2.dragging;
  view2.dragging = null;
  if (!e.dataTransfer) {
    return;
  }
  var eventPos = view2.posAtCoords(eventCoords(e));
  if (!eventPos) {
    return;
  }
  var $mouse = view2.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice11 = dragging && dragging.slice || parseFromClipboard(
    view2,
    e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
    brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"),
    false,
    $mouse
  );
  if (!slice11) {
    return;
  }
  e.preventDefault();
  if (view2.someProp("handleDrop", function(f2) {
    return f2(view2, e, slice11, dragging && dragging.move);
  })) {
    return;
  }
  var insertPos = dropPos(slice11, view2.state.doc.resolve($mouse.pos));
  var tr = view2.state.tr;
  if (dragging && dragging.move) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode2 = slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode2) {
    tr.replaceRangeWith(pos, pos, slice11.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice11);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode2 && prosemirrorState$3.NodeSelection.isSelectable(slice11.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice11.content.firstChild)) {
    tr.setSelection(new prosemirrorState$3.NodeSelection($pos));
  } else {
    tr.setSelection(selectionBetween(view2, $pos, tr.doc.resolve(tr.mapping.map(insertPos))));
  }
  view2.focus();
  view2.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = function(view2) {
  if (!view2.focused) {
    view2.dom.classList.add("ProseMirror-focused");
    view2.focused = true;
  }
};
handlers.blur = function(view2) {
  if (view2.focused) {
    view2.dom.classList.remove("ProseMirror-focused");
    view2.focused = false;
  }
};
for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}
function compareObjs(a, b) {
  if (a == b) {
    return true;
  }
  for (var p2 in a) {
    if (a[p2] !== b[p2]) {
      return false;
    }
  }
  for (var p$12 in b) {
    if (!(p$12 in a)) {
      return false;
    }
  }
  return true;
}
var WidgetType2 = function WidgetType3(widget3, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  if (!this.spec.raw) {
    if (widget3.nodeType != 1) {
      var wrap2 = document.createElement("span");
      wrap2.appendChild(widget3);
      widget3 = wrap2;
    }
    widget3.contentEditable = false;
    widget3.classList.add("ProseMirror-widget");
  }
  this.widget = widget3;
};
WidgetType2.prototype.map = function map13(mapping, span, offset2, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref.pos;
  var deleted = ref.deleted;
  return deleted ? null : new Decoration2(pos - offset2, pos - offset2, this);
};
WidgetType2.prototype.valid = function valid4() {
  return true;
};
WidgetType2.prototype.eq = function eq31(other) {
  return this == other || other instanceof WidgetType2 && (this.widget == other.widget || this.spec.key) && compareObjs(this.spec, other.spec);
};
var InlineType2 = function InlineType3(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
InlineType2.prototype.map = function map14(mapping, span, offset2, oldOffset) {
  var from12 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
  return from12 >= to ? null : new Decoration2(from12, to, this);
};
InlineType2.prototype.valid = function valid5(_, span) {
  return span.from < span.to;
};
InlineType2.prototype.eq = function eq32(other) {
  return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
InlineType2.is = function is2(span) {
  return span.type instanceof InlineType2;
};
var NodeType$1 = function NodeType8(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
NodeType$1.prototype.map = function map15(mapping, span, offset2, oldOffset) {
  var from12 = mapping.mapResult(span.from + oldOffset, 1);
  if (from12.deleted) {
    return null;
  }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from12.pos) {
    return null;
  }
  return new Decoration2(from12.pos - offset2, to.pos - offset2, this);
};
NodeType$1.prototype.valid = function valid6(node18, span) {
  var ref = node18.content.findIndex(span.from);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return offset2 == span.from && offset2 + node18.child(index8).nodeSize == span.to;
};
NodeType$1.prototype.eq = function eq33(other) {
  return this == other || other instanceof NodeType$1 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
var Decoration2 = function Decoration3(from12, to, type) {
  this.from = from12;
  this.to = to;
  this.type = type;
};
var prototypeAccessors$2$1 = { spec: {} };
Decoration2.prototype.copy = function copy9(from12, to) {
  return new Decoration2(from12, to, this.type);
};
Decoration2.prototype.eq = function eq34(other) {
  return this.type.eq(other.type) && this.from == other.from && this.to == other.to;
};
Decoration2.prototype.map = function map16(mapping, offset2, oldOffset) {
  return this.type.map(mapping, this, offset2, oldOffset);
};
Decoration2.widget = function widget2(pos, dom, spec) {
  return new Decoration2(pos, pos, new WidgetType2(dom, spec));
};
Decoration2.inline = function inline2(from12, to, attrs, spec) {
  return new Decoration2(from12, to, new InlineType2(attrs, spec));
};
Decoration2.node = function node14(from12, to, attrs, spec) {
  return new Decoration2(from12, to, new NodeType$1(attrs, spec));
};
prototypeAccessors$2$1.spec.get = function() {
  return this.type.spec;
};
Object.defineProperties(Decoration2.prototype, prototypeAccessors$2$1);
var none = [];
var noSpec = {};
var DecorationSet2 = function DecorationSet3(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};
DecorationSet2.create = function create15(doc2, decorations) {
  return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
};
DecorationSet2.prototype.find = function find4(start16, end8, predicate) {
  var result2 = [];
  this.findInner(start16 == null ? 0 : start16, end8 == null ? 1e9 : end8, result2, 0, predicate);
  return result2;
};
DecorationSet2.prototype.findInner = function findInner2(start16, end8, result2, offset2, predicate) {
  var this$1$1 = this;
  for (var i = 0; i < this.local.length; i++) {
    var span = this$1$1.local[i];
    if (span.from <= end8 && span.to >= start16 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
  }
  for (var i$12 = 0; i$12 < this.children.length; i$12 += 3) {
    if (this$1$1.children[i$12] < end8 && this$1$1.children[i$12 + 1] > start16) {
      var childOff = this$1$1.children[i$12] + 1;
      this$1$1.children[i$12 + 2].findInner(start16 - childOff, end8 - childOff, result2, offset2 + childOff, predicate);
    }
  }
};
DecorationSet2.prototype.map = function map17(mapping, doc2, options) {
  if (this == empty || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
};
DecorationSet2.prototype.mapInner = function mapInner2(mapping, node18, offset2, oldOffset, options) {
  var this$1$1 = this;
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this$1$1.local[i].map(mapping, offset2, oldOffset);
    if (mapped && mapped.type.valid(node18, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this$1$1.local[i].spec);
    }
  }
  if (this.children.length) {
    return mapChildren(this.children, newLocal, mapping, node18, offset2, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet2(newLocal.sort(byPos)) : empty;
  }
};
DecorationSet2.prototype.add = function add3(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty) {
    return DecorationSet2.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet2.prototype.addInner = function addInner2(doc2, decorations, offset2) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset2, found2;
    if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
    }
    childIndex += 3;
  });
  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
  return new DecorationSet2(
    local.length ? this.local.concat(local).sort(byPos) : this.local,
    children || this.children
  );
};
DecorationSet2.prototype.remove = function remove2(decorations) {
  if (decorations.length == 0 || this == empty) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet2.prototype.removeInner = function removeInner2(decorations, offset2) {
  var this$1$1 = this;
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found2 = void 0, from12 = children[i] + offset2, to = children[i + 1] + offset2;
    for (var j = 0, span = void 0; j < decorations.length; j++) {
      if (span = decorations[j]) {
        if (span.from > from12 && span.to < to) {
          decorations[j] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this$1$1.children) {
      children = this$1$1.children.slice();
    }
    var removed = children[i + 2].removeInner(found2, from12 + 1);
    if (removed != empty) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) {
    for (var i$12 = 0, span$1 = void 0; i$12 < decorations.length; i$12++) {
      if (span$1 = decorations[i$12]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].type.eq(span$1.type)) {
            if (local == this$1$1.local) {
              local = this$1$1.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet2(local, children) : empty;
};
DecorationSet2.prototype.forChild = function forChild3(offset2, node18) {
  var this$1$1 = this;
  if (this == empty) {
    return this;
  }
  if (node18.isLeaf) {
    return DecorationSet2.empty;
  }
  var child15, local;
  for (var i = 0; i < this.children.length; i += 3) {
    if (this$1$1.children[i] >= offset2) {
      if (this$1$1.children[i] == offset2) {
        child15 = this$1$1.children[i + 2];
      }
      break;
    }
  }
  var start16 = offset2 + 1, end8 = start16 + node18.content.size;
  for (var i$12 = 0; i$12 < this.local.length; i$12++) {
    var dec = this$1$1.local[i$12];
    if (dec.from < end8 && dec.to > start16 && dec.type instanceof InlineType2) {
      var from12 = Math.max(start16, dec.from) - start16, to = Math.min(end8, dec.to) - start16;
      if (from12 < to) {
        (local || (local = [])).push(dec.copy(from12, to));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet2(local.sort(byPos));
    return child15 ? new DecorationGroup2([localSet, child15]) : localSet;
  }
  return child15 || empty;
};
DecorationSet2.prototype.eq = function eq35(other) {
  var this$1$1 = this;
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i = 0; i < this.local.length; i++) {
    if (!this$1$1.local[i].eq(other.local[i])) {
      return false;
    }
  }
  for (var i$12 = 0; i$12 < this.children.length; i$12 += 3) {
    if (this$1$1.children[i$12] != other.children[i$12] || this$1$1.children[i$12 + 1] != other.children[i$12 + 1] || !this$1$1.children[i$12 + 2].eq(other.children[i$12 + 2])) {
      return false;
    }
  }
  return false;
};
DecorationSet2.prototype.locals = function locals3(node18) {
  return removeOverlap(this.localsInner(node18));
};
DecorationSet2.prototype.localsInner = function localsInner2(node18) {
  var this$1$1 = this;
  if (this == empty) {
    return none;
  }
  if (node18.inlineContent || !this.local.some(InlineType2.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this$1$1.local[i].type instanceof InlineType2)) {
      result2.push(this$1$1.local[i]);
    }
  }
  return result2;
};
var empty = new DecorationSet2();
DecorationSet2.empty = empty;
DecorationSet2.removeOverlap = removeOverlap;
var DecorationGroup2 = function DecorationGroup3(members) {
  this.members = members;
};
DecorationGroup2.prototype.forChild = function forChild4(offset2, child15) {
  var this$1$1 = this;
  if (child15.isLeaf) {
    return DecorationSet2.empty;
  }
  var found2 = [];
  for (var i = 0; i < this.members.length; i++) {
    var result2 = this$1$1.members[i].forChild(offset2, child15);
    if (result2 == empty) {
      continue;
    }
    if (result2 instanceof DecorationGroup2) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup2.from(found2);
};
DecorationGroup2.prototype.eq = function eq36(other) {
  var this$1$1 = this;
  if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length) {
    return false;
  }
  for (var i = 0; i < this.members.length; i++) {
    if (!this$1$1.members[i].eq(other.members[i])) {
      return false;
    }
  }
  return true;
};
DecorationGroup2.prototype.locals = function locals4(node18) {
  var this$1$1 = this;
  var result2, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals5 = this$1$1.members[i].localsInner(node18);
    if (!locals5.length) {
      continue;
    }
    if (!result2) {
      result2 = locals5;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j = 0; j < locals5.length; j++) {
        result2.push(locals5[j]);
      }
    }
  }
  return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
};
DecorationGroup2.from = function from9(members) {
  switch (members.length) {
    case 0:
      return empty;
    case 1:
      return members[0];
    default:
      return new DecorationGroup2(members);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node18, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i2 = 0; i2 < children.length; i2 += 3) {
      var end8 = children[i2 + 1], dSize = void 0;
      if (end8 == -1 || oldStart > end8 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i2] + oldOffset) {
        children[i2 + 1] = -1;
      } else if (dSize = newEnd - newStart - (oldEnd - oldStart) + (oldOffset - offset2)) {
        children[i2] += dSize;
        children[i2 + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$12 = 0; i$12 < children.length; i$12 += 3) {
    if (children[i$12 + 1] == -1) {
      var from12 = mapping.map(children[i$12] + oldOffset), fromLocal = from12 - offset2;
      if (fromLocal < 0 || fromLocal >= node18.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$12 + 1] + oldOffset, -1), toLocal = to - offset2;
      var ref = node18.content.findIndex(fromLocal);
      var index8 = ref.index;
      var childOffset = ref.offset;
      var childNode = node18.maybeChild(index8);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$12 + 2].mapInner(mapping, childNode, from12 + 1, children[i$12] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$12] = fromLocal;
          children[i$12 + 1] = toLocal;
          children[i$12 + 2] = mapped;
        } else {
          children.splice(i$12, 3);
          i$12 -= 3;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(
      children,
      newLocal ? moveSpans(newLocal, offset2) : [],
      mapping,
      offset2,
      oldOffset,
      options
    );
    var built = buildTree(decorations, node18, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] == -1) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet2(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result2.push(new Decoration2(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (var i2 = 0; i2 < set.local.length; i2++) {
      var mapped = set.local[i2].map(mapping, offset2, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set.local[i2].spec);
      }
    }
    for (var i$12 = 0; i$12 < set.children.length; i$12 += 3) {
      gather(set.children[i$12 + 2], set.children[i$12] + oldOffset2 + 1);
    }
  }
  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) {
      gather(children[i + 2], children[i] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node18, offset2) {
  if (node18.isLeaf) {
    return null;
  }
  var end8 = offset2 + node18.nodeSize, found2 = null;
  for (var i = 0, span = void 0; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end8) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) {
      result2.push(array[i]);
    }
  }
  return result2;
}
function buildTree(spans, node18, offset2, options) {
  var children = [], hasNulls = false;
  node18.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals5 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (var i = 0; i < locals5.length; i++) {
    if (!locals5[i].type.valid(node18, locals5[i])) {
      if (options.onRemove) {
        options.onRemove(locals5[i].spec);
      }
      locals5.splice(i--, 1);
    }
  }
  return locals5.length || children.length ? new DecorationSet2(locals5, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) {
      for (var j = i + 1; j < working.length; j++) {
        var next2 = working[j];
        if (next2.from == span.from) {
          if (next2.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next2.copy(next2.from, span.to);
            insertAhead(working, j + 1, next2.copy(span.to, next2.to));
          }
          continue;
        } else {
          if (next2.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i] = span.copy(span.from, next2.from);
            insertAhead(working, j, span.copy(next2.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }
  array.splice(i, 0, deco);
}
function viewDecorations(view2) {
  var found2 = [];
  view2.someProp("decorations", function(f2) {
    var result2 = f2(view2.state);
    if (result2 && result2 != empty) {
      found2.push(result2);
    }
  });
  if (view2.cursorWrapper) {
    found2.push(DecorationSet2.create(view2.state.doc, [view2.cursorWrapper]));
  }
  return DecorationGroup2.from(found2);
}
var EditorView2 = function EditorView3(place, props) {
  this._props = props;
  this.state = props.state;
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable(this);
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput(this);
  this.selectionReader = new SelectionReader2(this);
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$7 = { props: {}, root: {} };
prototypeAccessors$7.props.get = function() {
  var this$1$1 = this;
  if (this._props.state != this.state) {
    var prev2 = this._props;
    this._props = {};
    for (var name in prev2) {
      this$1$1._props[name] = prev2[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView2.prototype.update = function update2(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners(this);
  }
  this._props = props;
  this.updateState(props.state);
};
EditorView2.prototype.setProps = function setProps2(props) {
  var this$1$1 = this;
  var updated = {};
  for (var name in this$1$1._props) {
    updated[name] = this$1$1._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView2.prototype.updateState = function updateState2(state) {
  var this$1$1 = this;
  var prev2 = this.state;
  this.state = state;
  if (prev2.plugins != state.plugins) {
    ensureListeners(this);
  }
  this.domObserver.flush();
  if (this.inDOMChange && this.inDOMChange.stateUpdated(state)) {
    return;
  }
  var prevEditable = this.editable;
  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
  var scroll = prev2.config != state.config ? "reset" : state.scrollToSelection > prev2.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  var updateSel = updateDoc || !state.selection.eq(prev2.selection) || this.selectionReader.domChanged();
  var oldScrollPos = scroll == "preserve" && updateSel && storeScrollPos(this);
  if (updateSel) {
    this.domObserver.stop();
    if (updateDoc) {
      if (!this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      this.selectionReader.clearDOMState();
    }
    selectionToDOM(this);
    this.domObserver.start();
  }
  if (prevEditable != this.editable) {
    this.selectionReader.editableChanged();
  }
  this.updatePluginViews(prev2);
  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof prosemirrorState$3.NodeSelection) {
      scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect());
    } else {
      scrollRectIntoView(this, this.coordsAtPos(state.selection.head));
    }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};
EditorView2.prototype.destroyPluginViews = function destroyPluginViews2() {
  var view2;
  while (view2 = this.pluginViews.pop()) {
    if (view2.destroy) {
      view2.destroy();
    }
  }
};
EditorView2.prototype.updatePluginViews = function updatePluginViews2(prevState) {
  var this$1$1 = this;
  var plugins = this.state.plugins;
  if (!prevState || prevState.plugins != plugins) {
    this.destroyPluginViews();
    for (var i = 0; i < plugins.length; i++) {
      var plugin = plugins[i];
      if (plugin.spec.view) {
        this$1$1.pluginViews.push(plugin.spec.view(this$1$1));
      }
    }
  } else {
    for (var i$12 = 0; i$12 < this.pluginViews.length; i$12++) {
      var pluginView = this$1$1.pluginViews[i$12];
      if (pluginView.update) {
        pluginView.update(this$1$1, prevState);
      }
    }
  }
};
EditorView2.prototype.someProp = function someProp2(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i = 0; i < plugins.length; i++) {
      var prop$1 = plugins[i].props[propName];
      if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
        return value;
      }
    }
  }
};
EditorView2.prototype.hasFocus = function hasFocus2() {
  return this.root.activeElement == this.dom;
};
EditorView2.prototype.focus = function focus2() {
  this.domObserver.stop();
  selectionToDOM(this, true);
  this.domObserver.start();
  if (this.editable) {
    this.dom.focus();
  }
};
prototypeAccessors$7.root.get = function() {
  var this$1$1 = this;
  var cached = this._root;
  if (cached == null) {
    for (var search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
        return this$1$1._root = search;
      }
    }
  }
  return cached || document;
};
EditorView2.prototype.posAtCoords = function posAtCoords$12(coords) {
  var pos = posAtCoords(this, coords);
  if (this.inDOMChange && pos) {
    pos.pos = this.inDOMChange.mapping.map(pos.pos);
    if (pos.inside != -1) {
      pos.inside = this.inDOMChange.mapping.map(pos.inside);
    }
  }
  return pos;
};
EditorView2.prototype.coordsAtPos = function coordsAtPos$12(pos) {
  if (this.inDOMChange) {
    pos = this.inDOMChange.mapping.invert().map(pos);
  }
  return coordsAtPos(this, pos);
};
EditorView2.prototype.domAtPos = function domAtPos2(pos) {
  if (this.inDOMChange) {
    pos = this.inDOMChange.mapping.invert().map(pos);
  }
  return this.docView.domFromPos(pos);
};
EditorView2.prototype.endOfTextblock = function endOfTextblock$12(dir, state) {
  return endOfTextblock(this, state || this.state, dir);
};
EditorView2.prototype.destroy = function destroy10() {
  if (!this.docView) {
    return;
  }
  destroyInput(this);
  this.destroyPluginViews();
  this.selectionReader.destroy();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
EditorView2.prototype.dispatchEvent = function dispatchEvent$12(event) {
  return dispatchEvent(this, event);
};
EditorView2.prototype.dispatch = function dispatch2(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction(tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView2.prototype, prototypeAccessors$7);
function computeDocDeco(view2) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror" + (view2.focused ? " ProseMirror-focused" : "");
  attrs.contenteditable = String(view2.editable);
  view2.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view2.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration2.node(0, view2.state.doc.content.size, attrs)];
}
function nonInclusiveMark(mark15) {
  return mark15.type.spec.inclusive === false;
}
function cursorWrapperDOM(visible) {
  var span = document.createElement("span");
  span.textContent = "\uFEFF";
  if (!visible) {
    span.style.position = "absolute";
    span.style.left = "-100000px";
  }
  return span;
}
function updateCursorWrapper(view2) {
  var ref = view2.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var visible = ref.visible;
  var $pos = $head.pos == $anchor.pos && (!visible || $head.parent.inlineContent) ? $head : null;
  if ($pos && (!visible || view2.state.storedMarks || $pos.parent.content.length == 0 || $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.some(nonInclusiveMark))) {
    var marks9 = view2.state.storedMarks || $pos.marks();
    var spec = { isCursorWrapper: true, marks: marks9, raw: true, visible };
    if (!view2.cursorWrapper || !prosemirrorModel$1.Mark.sameSet(view2.cursorWrapper.spec.marks, marks9) || view2.cursorWrapper.type.widget.textContent != "\uFEFF" || view2.cursorWrapper.spec.visible != visible) {
      view2.cursorWrapper = Decoration2.widget($pos.pos, cursorWrapperDOM(visible), spec);
    } else if (view2.cursorWrapper.pos != $pos.pos) {
      view2.cursorWrapper = Decoration2.widget($pos.pos, view2.cursorWrapper.type.widget, spec);
    }
  } else {
    view2.cursorWrapper = null;
  }
}
function getEditable(view2) {
  return !view2.someProp("editable", function(value) {
    return value(view2.state) === false;
  });
}
dist$4.EditorView = EditorView2;
dist$4.Decoration = Decoration2;
dist$4.DecorationSet = DecorationSet2;
dist$4.__serializeForClipboard = serializeForClipboard;
dist$4.__parseFromClipboard = parseFromClipboard;
Object.defineProperty(dist$5, "__esModule", { value: true });
var prosemirrorKeymap = keymap$1;
var prosemirrorState$2 = dist$e;
var prosemirrorView = dist$4;
var prosemirrorModel = dist$3;
var GapCursor = function(Selection$$1) {
  function GapCursor2($pos) {
    Selection$$1.call(this, $pos, $pos);
  }
  if (Selection$$1)
    GapCursor2.__proto__ = Selection$$1;
  GapCursor2.prototype = Object.create(Selection$$1 && Selection$$1.prototype);
  GapCursor2.prototype.constructor = GapCursor2;
  GapCursor2.prototype.map = function map19(doc2, mapping) {
    var $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor2.valid($pos) ? new GapCursor2($pos) : Selection$$1.near($pos);
  };
  GapCursor2.prototype.content = function content2() {
    return prosemirrorModel.Slice.empty;
  };
  GapCursor2.prototype.eq = function eq41(other) {
    return other instanceof GapCursor2 && other.head == this.head;
  };
  GapCursor2.prototype.toJSON = function toJSON31() {
    return { type: "gapcursor", pos: this.head };
  };
  GapCursor2.fromJSON = function fromJSON32(doc2, json) {
    return new GapCursor2(doc2.resolve(json.pos));
  };
  GapCursor2.prototype.getBookmark = function getBookmark2() {
    return new GapBookmark(this.anchor);
  };
  GapCursor2.valid = function valid7($pos) {
    var parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {
      return false;
    }
    var override = parent.type.spec.allowGapCursor;
    if (override != null) {
      return override;
    }
    var deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  };
  GapCursor2.findFrom = function findFrom2($pos, dir, mustMove) {
    if (!mustMove && GapCursor2.valid($pos)) {
      return $pos;
    }
    var pos = $pos.pos, next2 = null;
    for (var d = $pos.depth; ; d--) {
      var parent = $pos.node(d);
      if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
        next2 = parent.maybeChild(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
        break;
      } else if (d == 0) {
        return null;
      }
      pos += dir;
      var $cur = $pos.doc.resolve(pos);
      if (GapCursor2.valid($cur)) {
        return $cur;
      }
    }
    for (; ; ) {
      next2 = dir > 0 ? next2.firstChild : next2.lastChild;
      if (!next2) {
        break;
      }
      pos += dir;
      var $cur$1 = $pos.doc.resolve(pos);
      if (GapCursor2.valid($cur$1)) {
        return $cur$1;
      }
    }
    return null;
  };
  return GapCursor2;
}(prosemirrorState$2.Selection);
GapCursor.prototype.visible = false;
prosemirrorState$2.Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = function GapBookmark2(pos) {
  this.pos = pos;
};
GapBookmark.prototype.map = function map18(mapping) {
  return new GapBookmark(mapping.map(this.pos));
};
GapBookmark.prototype.resolve = function resolve16(doc2) {
  var $pos = doc2.resolve(this.pos);
  return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState$2.Selection.near($pos);
};
function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index8 = $pos.index(d);
    if (index8 == 0) {
      continue;
    }
    for (var before8 = $pos.node(d).child(index8 - 1); ; before8 = before8.lastChild) {
      if (before8.isTextblock) {
        return false;
      }
      if (before8.childCount == 0 || before8.isAtom || before8.type.spec.isolating) {
        return true;
      }
    }
  }
  return true;
}
function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index8 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index8 == parent.childCount) {
      continue;
    }
    for (var after8 = parent.child(index8); ; after8 = after8.firstChild) {
      if (after8.isTextblock) {
        return false;
      }
      if (after8.childCount == 0 || after8.isAtom || after8.type.spec.isolating) {
        return true;
      }
    }
  }
  return true;
}
var gapCursor = function() {
  return new prosemirrorState$2.Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        if ($anchor.pos == $head.pos && GapCursor.valid($head)) {
          return new GapCursor($head);
        }
      },
      handleClick,
      handleKeyDown
    }
  });
};
var handleKeyDown = prosemirrorKeymap.keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch3, view2) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof prosemirrorState$2.TextSelection) {
      if (!view2.endOfTextblock(dirStr)) {
        return false;
      }
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setSelection(new GapCursor($found)));
    }
    return true;
  };
}
function handleClick(view2, pos, event) {
  var $pos = view2.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) {
    return false;
  }
  var ref = view2.posAtCoords({ left: event.clientX, top: event.clientY });
  var inside = ref.inside;
  if (inside > -1 && prosemirrorState$2.NodeSelection.isSelectable(view2.state.doc.nodeAt(inside))) {
    return false;
  }
  view2.dispatch(view2.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) {
    return null;
  }
  var node18 = document.createElement("div");
  node18.className = "ProseMirror-gapcursor";
  return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node18, { key: "gapcursor" })]);
}
var gapCursor_1 = dist$5.gapCursor = gapCursor;
dist$5.GapCursor = GapCursor;
var dist$2 = {};
var crel$1 = { exports: {} };
(function(module, exports) {
  (function(root2, factory) {
    {
      module.exports = factory();
    }
  })(commonjsGlobal, function() {
    var fn = "function", obj = "object", nodeType8 = "nodeType", textContent = "textContent", setAttribute = "setAttribute", attrMapString = "attrMap", isNodeString = "isNode", isElementString = "isElement", d = typeof document === obj ? document : {}, isType = function(a, type) {
      return typeof a === type;
    }, isNode2 = typeof Node === fn ? function(object) {
      return object instanceof Node;
    } : function(object) {
      return object && isType(object, obj) && nodeType8 in object && isType(object.ownerDocument, obj);
    }, isElement = function(object) {
      return crel2[isNodeString](object) && object[nodeType8] === 1;
    }, isArray3 = function(a) {
      return a instanceof Array;
    }, appendChild = function(element, child15) {
      if (isArray3(child15)) {
        child15.map(function(subChild) {
          appendChild(element, subChild);
        });
        return;
      }
      if (!crel2[isNodeString](child15)) {
        child15 = d.createTextNode(child15);
      }
      element.appendChild(child15);
    };
    function crel2() {
      var args = arguments, element = args[0], child15, settings = args[1], childIndex = 2, argumentsLength = args.length, attributeMap = crel2[attrMapString];
      element = crel2[isElementString](element) ? element : d.createElement(element);
      if (argumentsLength === 1) {
        return element;
      }
      if (!isType(settings, obj) || crel2[isNodeString](settings) || isArray3(settings)) {
        --childIndex;
        settings = null;
      }
      if (argumentsLength - childIndex === 1 && isType(args[childIndex], "string") && element[textContent] !== void 0) {
        element[textContent] = args[childIndex];
      } else {
        for (; childIndex < argumentsLength; ++childIndex) {
          child15 = args[childIndex];
          if (child15 == null) {
            continue;
          }
          if (isArray3(child15)) {
            for (var i = 0; i < child15.length; ++i) {
              appendChild(element, child15[i]);
            }
          } else {
            appendChild(element, child15);
          }
        }
      }
      for (var key in settings) {
        if (!attributeMap[key]) {
          if (isType(settings[key], fn)) {
            element[key] = settings[key];
          } else {
            element[setAttribute](key, settings[key]);
          }
        } else {
          var attr = attributeMap[key];
          if (typeof attr === fn) {
            attr(element, settings[key]);
          } else {
            element[setAttribute](attr, settings[key]);
          }
        }
      }
      return element;
    }
    crel2[attrMapString] = {};
    crel2[isElementString] = isElement;
    crel2[isNodeString] = isNode2;
    if (typeof Proxy !== "undefined") {
      crel2.proxy = new Proxy(crel2, {
        get: function(target, key) {
          !(key in crel2) && (crel2[key] = crel2.bind(null, key));
          return crel2[key];
        }
      });
    }
    return crel2;
  });
})(crel$1);
Object.defineProperty(dist$2, "__esModule", { value: true });
function _interopDefault$1(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var crel = _interopDefault$1(crel$1.exports);
var prosemirrorCommands = commands$1;
var prosemirrorHistory = history$1;
var prosemirrorState$1 = dist$e;
var SVG = "http://www.w3.org/2000/svg";
var XLINK = "http://www.w3.org/1999/xlink";
var prefix$1$1 = "ProseMirror-icon";
function hashPath(path) {
  var hash2 = 0;
  for (var i = 0; i < path.length; i++) {
    hash2 = (hash2 << 5) - hash2 + path.charCodeAt(i) | 0;
  }
  return hash2;
}
function getIcon(icon2) {
  var node18 = document.createElement("div");
  node18.className = prefix$1$1;
  if (icon2.path) {
    var name = "pm-icon-" + hashPath(icon2.path).toString(16);
    if (!document.getElementById(name)) {
      buildSVG(name, icon2);
    }
    var svg = node18.appendChild(document.createElementNS(SVG, "svg"));
    svg.style.width = icon2.width / icon2.height + "em";
    var use = svg.appendChild(document.createElementNS(SVG, "use"));
    use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location)[1] + "#" + name);
  } else if (icon2.dom) {
    node18.appendChild(icon2.dom.cloneNode(true));
  } else {
    node18.appendChild(document.createElement("span")).textContent = icon2.text || "";
    if (icon2.css) {
      node18.firstChild.style.cssText = icon2.css;
    }
  }
  return node18;
}
function buildSVG(name, data) {
  var collection = document.getElementById(prefix$1$1 + "-collection");
  if (!collection) {
    collection = document.createElementNS(SVG, "svg");
    collection.id = prefix$1$1 + "-collection";
    collection.style.display = "none";
    document.body.insertBefore(collection, document.body.firstChild);
  }
  var sym = document.createElementNS(SVG, "symbol");
  sym.id = name;
  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
  var path = sym.appendChild(document.createElementNS(SVG, "path"));
  path.setAttribute("d", data.path);
  collection.appendChild(sym);
}
var prefix$2 = "ProseMirror-menu";
var MenuItem = function MenuItem2(spec) {
  this.spec = spec;
};
MenuItem.prototype.render = function render(view2) {
  var spec = this.spec;
  var dom = spec.render ? spec.render(view2) : spec.icon ? getIcon(spec.icon) : spec.label ? crel("div", null, translate(view2, spec.label)) : null;
  if (!dom) {
    throw new RangeError("MenuItem without icon or label property");
  }
  if (spec.title) {
    var title = typeof spec.title === "function" ? spec.title(view2.state) : spec.title;
    dom.setAttribute("title", translate(view2, title));
  }
  if (spec.class) {
    dom.classList.add(spec.class);
  }
  if (spec.css) {
    dom.style.cssText += spec.css;
  }
  dom.addEventListener("mousedown", function(e) {
    e.preventDefault();
    spec.run(view2.state, view2.dispatch, view2, e);
  });
  function update4(state) {
    if (spec.select) {
      var selected = spec.select(state);
      dom.style.display = selected ? "" : "none";
      if (!selected) {
        return false;
      }
    }
    var enabled = true;
    if (spec.enable) {
      enabled = spec.enable(state) || false;
      setClass(dom, prefix$2 + "-disabled", !enabled);
    }
    if (spec.active) {
      var active = enabled && spec.active(state) || false;
      setClass(dom, prefix$2 + "-active", active);
    }
    return true;
  }
  return { dom, update: update4 };
};
function translate(view2, text8) {
  return view2._props.translate ? view2._props.translate(text8) : text8;
}
var lastMenuEvent = { time: 0, node: null };
function markMenuEvent(e) {
  lastMenuEvent.time = Date.now();
  lastMenuEvent.node = e.target;
}
function isMenuEvent(wrapper) {
  return Date.now() - 100 < lastMenuEvent.time && lastMenuEvent.node && wrapper.contains(lastMenuEvent.node);
}
var Dropdown = function Dropdown2(content2, options) {
  this.options = options || {};
  this.content = Array.isArray(content2) ? content2 : [content2];
};
Dropdown.prototype.render = function render2(view2) {
  var this$1$1 = this;
  var content2 = renderDropdownItems(this.content, view2);
  var label = crel(
    "div",
    {
      class: prefix$2 + "-dropdown " + (this.options.class || ""),
      style: this.options.css
    },
    translate(view2, this.options.label)
  );
  if (this.options.title) {
    label.setAttribute("title", translate(view2, this.options.title));
  }
  var wrap2 = crel("div", { class: prefix$2 + "-dropdown-wrap" }, label);
  var open = null, listeningOnClose = null;
  var close2 = function() {
    if (open && open.close()) {
      open = null;
      window.removeEventListener("mousedown", listeningOnClose);
    }
  };
  label.addEventListener("mousedown", function(e) {
    e.preventDefault();
    markMenuEvent(e);
    if (open) {
      close2();
    } else {
      open = this$1$1.expand(wrap2, content2.dom);
      window.addEventListener("mousedown", listeningOnClose = function() {
        if (!isMenuEvent(wrap2)) {
          close2();
        }
      });
    }
  });
  function update4(state) {
    var inner = content2.update(state);
    wrap2.style.display = inner ? "" : "none";
    return inner;
  }
  return { dom: wrap2, update: update4 };
};
Dropdown.prototype.expand = function expand(dom, items) {
  var menuDOM = crel("div", { class: prefix$2 + "-dropdown-menu " + (this.options.class || "") }, items);
  var done3 = false;
  function close2() {
    if (done3) {
      return;
    }
    done3 = true;
    dom.removeChild(menuDOM);
    return true;
  }
  dom.appendChild(menuDOM);
  return { close: close2, node: menuDOM };
};
function renderDropdownItems(items, view2) {
  var rendered = [], updates = [];
  for (var i = 0; i < items.length; i++) {
    var ref = items[i].render(view2);
    var dom = ref.dom;
    var update4 = ref.update;
    rendered.push(crel("div", { class: prefix$2 + "-dropdown-item" }, dom));
    updates.push(update4);
  }
  return { dom: rendered, update: combineUpdates(updates, rendered) };
}
function combineUpdates(updates, nodes2) {
  return function(state) {
    var something = false;
    for (var i = 0; i < updates.length; i++) {
      var up3 = updates[i](state);
      nodes2[i].style.display = up3 ? "" : "none";
      if (up3) {
        something = true;
      }
    }
    return something;
  };
}
var DropdownSubmenu = function DropdownSubmenu2(content2, options) {
  this.options = options || {};
  this.content = Array.isArray(content2) ? content2 : [content2];
};
DropdownSubmenu.prototype.render = function render3(view2) {
  var items = renderDropdownItems(this.content, view2);
  var label = crel("div", { class: prefix$2 + "-submenu-label" }, translate(view2, this.options.label));
  var wrap2 = crel(
    "div",
    { class: prefix$2 + "-submenu-wrap" },
    label,
    crel("div", { class: prefix$2 + "-submenu" }, items.dom)
  );
  var listeningOnClose = null;
  label.addEventListener("mousedown", function(e) {
    e.preventDefault();
    markMenuEvent(e);
    setClass(wrap2, prefix$2 + "-submenu-wrap-active");
    if (!listeningOnClose) {
      window.addEventListener("mousedown", listeningOnClose = function() {
        if (!isMenuEvent(wrap2)) {
          wrap2.classList.remove(prefix$2 + "-submenu-wrap-active");
          window.removeEventListener("mousedown", listeningOnClose);
          listeningOnClose = null;
        }
      });
    }
  });
  function update4(state) {
    var inner = items.update(state);
    wrap2.style.display = inner ? "" : "none";
    return inner;
  }
  return { dom: wrap2, update: update4 };
};
function renderGrouped(view2, content2) {
  var result2 = document.createDocumentFragment();
  var updates = [], separators = [];
  for (var i = 0; i < content2.length; i++) {
    var items = content2[i], localUpdates = [], localNodes = [];
    for (var j = 0; j < items.length; j++) {
      var ref = items[j].render(view2);
      var dom = ref.dom;
      var update$1 = ref.update;
      var span = crel("span", { class: prefix$2 + "item" }, dom);
      result2.appendChild(span);
      localNodes.push(span);
      localUpdates.push(update$1);
    }
    if (localUpdates.length) {
      updates.push(combineUpdates(localUpdates, localNodes));
      if (i < content2.length - 1) {
        separators.push(result2.appendChild(separator()));
      }
    }
  }
  function update4(state) {
    var something = false, needSep = false;
    for (var i2 = 0; i2 < updates.length; i2++) {
      var hasContent = updates[i2](state);
      if (i2) {
        separators[i2 - 1].style.display = needSep && hasContent ? "" : "none";
      }
      needSep = hasContent;
      if (hasContent) {
        something = true;
      }
    }
    return something;
  }
  return { dom: result2, update: update4 };
}
function separator() {
  return crel("span", { class: prefix$2 + "separator" });
}
var icons = {
  join: {
    width: 800,
    height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024,
    height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: { text: "\u2B1A", css: "font-weight: bold" },
  undo: {
    width: 1024,
    height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024,
    height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805,
    height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585,
    height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896,
    height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951,
    height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768,
    height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768,
    height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640,
    height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
};
var joinUpItem = new MenuItem({
  title: "Join with above block",
  run: prosemirrorCommands.joinUp,
  select: function(state) {
    return prosemirrorCommands.joinUp(state);
  },
  icon: icons.join
});
var liftItem = new MenuItem({
  title: "Lift out of enclosing block",
  run: prosemirrorCommands.lift,
  select: function(state) {
    return prosemirrorCommands.lift(state);
  },
  icon: icons.lift
});
var selectParentNodeItem = new MenuItem({
  title: "Select parent node",
  run: prosemirrorCommands.selectParentNode,
  select: function(state) {
    return prosemirrorCommands.selectParentNode(state);
  },
  icon: icons.selectParentNode
});
var undoItem = new MenuItem({
  title: "Undo last change",
  run: prosemirrorHistory.undo,
  enable: function(state) {
    return prosemirrorHistory.undo(state);
  },
  icon: icons.undo
});
var redoItem = new MenuItem({
  title: "Redo last undone change",
  run: prosemirrorHistory.redo,
  enable: function(state) {
    return prosemirrorHistory.redo(state);
  },
  icon: icons.redo
});
function wrapItem(nodeType8, options) {
  var passedOptions = {
    run: function run(state, dispatch3) {
      return prosemirrorCommands.wrapIn(nodeType8, options.attrs)(state, dispatch3);
    },
    select: function select(state) {
      return prosemirrorCommands.wrapIn(nodeType8, options.attrs instanceof Function ? null : options.attrs)(state);
    }
  };
  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }
  return new MenuItem(passedOptions);
}
function blockTypeItem(nodeType8, options) {
  var command = prosemirrorCommands.setBlockType(nodeType8, options.attrs);
  var passedOptions = {
    run: command,
    enable: function enable(state) {
      return command(state);
    },
    active: function active(state) {
      var ref = state.selection;
      var $from = ref.$from;
      var to = ref.to;
      var node18 = ref.node;
      if (node18) {
        return node18.hasMarkup(nodeType8, options.attrs);
      }
      return to <= $from.end() && $from.parent.hasMarkup(nodeType8, options.attrs);
    }
  };
  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }
  return new MenuItem(passedOptions);
}
function setClass(dom, cls, on) {
  if (on) {
    dom.classList.add(cls);
  } else {
    dom.classList.remove(cls);
  }
}
var prefix$2$1 = "ProseMirror-menubar";
function isIOS() {
  if (typeof navigator == "undefined") {
    return false;
  }
  var agent2 = navigator.userAgent;
  return !/Edge\/\d/.test(agent2) && /AppleWebKit/.test(agent2) && /Mobile\/\w+/.test(agent2);
}
function menuBar(options) {
  return new prosemirrorState$1.Plugin({
    view: function view2(editorView) {
      return new MenuBarView(editorView, options);
    }
  });
}
var MenuBarView = function MenuBarView2(editorView, options) {
  var this$1$1 = this;
  this.editorView = editorView;
  this.options = options;
  this.wrapper = crel("div", { class: prefix$2$1 + "-wrapper" });
  this.menu = this.wrapper.appendChild(crel("div", { class: prefix$2$1 }));
  this.menu.className = prefix$2$1;
  this.spacer = null;
  editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
  this.wrapper.appendChild(editorView.dom);
  this.maxHeight = 0;
  this.widthForMaxHeight = 0;
  this.floating = false;
  var ref = renderGrouped(this.editorView, this.options.content);
  var dom = ref.dom;
  var update4 = ref.update;
  this.contentUpdate = update4;
  this.menu.appendChild(dom);
  this.update();
  if (options.floating && !isIOS()) {
    this.updateFloat();
    var potentialScrollers = getAllWrapping(this.wrapper);
    this.scrollFunc = function(e) {
      var root2 = this$1$1.editorView.root;
      if (!(root2.body || root2).contains(this$1$1.wrapper)) {
        potentialScrollers.forEach(function(el) {
          return el.removeEventListener("scroll", this$1$1.scrollFunc);
        });
      } else {
        this$1$1.updateFloat(e.target.getBoundingClientRect && e.target);
      }
    };
    potentialScrollers.forEach(function(el) {
      return el.addEventListener("scroll", this$1$1.scrollFunc);
    });
  }
};
MenuBarView.prototype.update = function update3() {
  this.contentUpdate(this.editorView.state);
  if (this.floating) {
    this.updateScrollCursor();
  } else {
    if (this.menu.offsetWidth != this.widthForMaxHeight) {
      this.widthForMaxHeight = this.menu.offsetWidth;
      this.maxHeight = 0;
    }
    if (this.menu.offsetHeight > this.maxHeight) {
      this.maxHeight = this.menu.offsetHeight;
      this.menu.style.minHeight = this.maxHeight + "px";
    }
  }
};
MenuBarView.prototype.updateScrollCursor = function updateScrollCursor() {
  var selection = this.editorView.root.getSelection();
  if (!selection.focusNode) {
    return;
  }
  var rects = selection.getRangeAt(0).getClientRects();
  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
  if (!selRect) {
    return;
  }
  var menuRect = this.menu.getBoundingClientRect();
  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
    var scrollable = findWrappingScrollable(this.wrapper);
    if (scrollable) {
      scrollable.scrollTop -= menuRect.bottom - selRect.top;
    }
  }
};
MenuBarView.prototype.updateFloat = function updateFloat(scrollAncestor) {
  var parent = this.wrapper, editorRect = parent.getBoundingClientRect(), top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;
  if (this.floating) {
    if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
      this.floating = false;
      this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
      this.menu.style.display = "";
      this.spacer.parentNode.removeChild(this.spacer);
      this.spacer = null;
    } else {
      var border = (parent.offsetWidth - parent.clientWidth) / 2;
      this.menu.style.left = editorRect.left + border + "px";
      this.menu.style.display = editorRect.top > window.innerHeight ? "none" : "";
      if (scrollAncestor) {
        this.menu.style.top = top + "px";
      }
    }
  } else {
    if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
      this.floating = true;
      var menuRect = this.menu.getBoundingClientRect();
      this.menu.style.left = menuRect.left + "px";
      this.menu.style.width = menuRect.width + "px";
      if (scrollAncestor) {
        this.menu.style.top = top + "px";
      }
      this.menu.style.position = "fixed";
      this.spacer = crel("div", { class: prefix$2$1 + "-spacer", style: "height: " + menuRect.height + "px" });
      parent.insertBefore(this.spacer, this.menu);
    }
  }
};
MenuBarView.prototype.destroy = function destroy11() {
  if (this.wrapper.parentNode) {
    this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
  }
};
function selectionIsInverted(selection) {
  if (selection.anchorNode == selection.focusNode) {
    return selection.anchorOffset > selection.focusOffset;
  }
  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;
}
function findWrappingScrollable(node18) {
  for (var cur = node18.parentNode; cur; cur = cur.parentNode) {
    if (cur.scrollHeight > cur.clientHeight) {
      return cur;
    }
  }
}
function getAllWrapping(node18) {
  var res = [window];
  for (var cur = node18.parentNode; cur; cur = cur.parentNode) {
    res.push(cur);
  }
  return res;
}
var MenuItem_1 = dist$2.MenuItem = MenuItem;
var Dropdown_1 = dist$2.Dropdown = Dropdown;
var DropdownSubmenu_1 = dist$2.DropdownSubmenu = DropdownSubmenu;
dist$2.renderGrouped = renderGrouped;
var icons_1 = dist$2.icons = icons;
var joinUpItem_1 = dist$2.joinUpItem = joinUpItem;
var liftItem_1 = dist$2.liftItem = liftItem;
var selectParentNodeItem_1 = dist$2.selectParentNodeItem = selectParentNodeItem;
var undoItem_1 = dist$2.undoItem = undoItem;
var redoItem_1 = dist$2.redoItem = redoItem;
var wrapItem_1 = dist$2.wrapItem = wrapItem;
var blockTypeItem_1 = dist$2.blockTypeItem = blockTypeItem;
var menuBar_1 = dist$2.menuBar = menuBar;
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: true });
var prosemirrorState = dist$e;
var prosemirrorTransform = dist$c;
var InputRule = function InputRule2(match2, handler) {
  this.match = match2;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};
function stringHandler(string) {
  return function(state, match2, start16, end8) {
    var insert = string;
    if (match2[1]) {
      var offset2 = match2[0].lastIndexOf(match2[1]);
      insert += match2[0].slice(offset2 + match2[1].length);
      start16 += offset2;
      var cutOff = start16 - end8;
      if (cutOff > 0) {
        insert = match2[0].slice(offset2 - cutOff, offset2) + insert;
        start16 = end8;
      }
    }
    var marks9 = state.doc.resolve(start16).marks();
    return state.tr.replaceWith(start16, end8, state.schema.text(insert, marks9));
  };
}
var MAX_MATCH = 500;
function inputRules(ref) {
  var rules = ref.rules;
  return new prosemirrorState.Plugin({
    state: {
      init: function init5() {
        return null;
      },
      apply: function apply8(tr, prev2) {
        var stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev2;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view2, from12, to, text8) {
        var this$1$1 = this;
        var state = view2.state, $from = state.doc.resolve(from12);
        if ($from.parent.type.spec.code) {
          return false;
        }
        var textBefore = $from.parent.textBetween(
          Math.max(0, $from.parentOffset - MAX_MATCH),
          $from.parentOffset,
          null,
          "\uFFFC"
        ) + text8;
        for (var i = 0; i < rules.length; i++) {
          var match2 = rules[i].match.exec(textBefore);
          var tr = match2 && rules[i].handler(state, match2, from12 - (match2[0].length - text8.length), to);
          if (!tr) {
            continue;
          }
          view2.dispatch(tr.setMeta(this$1$1, { transform: tr, from: from12, to, text: text8 }));
          return true;
        }
        return false;
      }
    },
    isInputRules: true
  });
}
function undoInputRule(state, dispatch3) {
  var plugins = state.plugins;
  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i], undoable = void 0;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch3) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        var marks9 = tr.doc.resolve(undoable.from).marks();
        dispatch3(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks9)));
      }
      return true;
    }
  }
  return false;
}
var emDash = new InputRule(/--$/, "\u2014");
var ellipsis = new InputRule(/\.\.\.$/, "\u2026");
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "\u201C");
var closeDoubleQuote = new InputRule(/"$/, "\u201D");
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "\u2018");
var closeSingleQuote = new InputRule(/'$/, "\u2019");
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];
function wrappingInputRule(regexp2, nodeType8, getAttrs2, joinPredicate) {
  return new InputRule(regexp2, function(state, match2, start16, end8) {
    var attrs = getAttrs2 instanceof Function ? getAttrs2(match2) : getAttrs2;
    var tr = state.tr.delete(start16, end8);
    var $start = tr.doc.resolve(start16), range = $start.blockRange(), wrapping = range && prosemirrorTransform.findWrapping(range, nodeType8, attrs);
    if (!wrapping) {
      return null;
    }
    tr.wrap(range, wrapping);
    var before8 = tr.doc.resolve(start16 - 1).nodeBefore;
    if (before8 && before8.type == nodeType8 && prosemirrorTransform.canJoin(tr.doc, start16 - 1) && (!joinPredicate || joinPredicate(match2, before8))) {
      tr.join(start16 - 1);
    }
    return tr;
  });
}
function textblockTypeInputRule(regexp2, nodeType8, getAttrs2) {
  return new InputRule(regexp2, function(state, match2, start16, end8) {
    var $start = state.doc.resolve(start16);
    var attrs = getAttrs2 instanceof Function ? getAttrs2(match2) : getAttrs2;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType8)) {
      return null;
    }
    return state.tr.delete(start16, end8).setBlockType(start16, start16, nodeType8, attrs);
  });
}
dist$1.InputRule = InputRule;
var inputRules_1 = dist$1.inputRules = inputRules;
var undoInputRule_1 = dist$1.undoInputRule = undoInputRule;
var emDash_1 = dist$1.emDash = emDash;
var ellipsis_1 = dist$1.ellipsis = ellipsis;
dist$1.openDoubleQuote = openDoubleQuote;
dist$1.closeDoubleQuote = closeDoubleQuote;
dist$1.openSingleQuote = openSingleQuote;
dist$1.closeSingleQuote = closeSingleQuote;
var smartQuotes_1 = dist$1.smartQuotes = smartQuotes;
var wrappingInputRule_1 = dist$1.wrappingInputRule = wrappingInputRule;
var textblockTypeInputRule_1 = dist$1.textblockTypeInputRule = textblockTypeInputRule;
const prefix$1 = "ProseMirror-prompt";
function openPrompt(options) {
  let wrapper = document.body.appendChild(document.createElement("div"));
  wrapper.className = prefix$1;
  let mouseOutside = (e) => {
    if (!wrapper.contains(e.target))
      close2();
  };
  setTimeout(() => window.addEventListener("mousedown", mouseOutside), 50);
  let close2 = () => {
    window.removeEventListener("mousedown", mouseOutside);
    if (wrapper.parentNode)
      wrapper.parentNode.removeChild(wrapper);
  };
  let domFields = [];
  for (let name in options.fields)
    domFields.push(options.fields[name].render());
  let submitButton = document.createElement("button");
  submitButton.type = "submit";
  submitButton.className = prefix$1 + "-submit";
  submitButton.textContent = "OK";
  let cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.className = prefix$1 + "-cancel";
  cancelButton.textContent = "Cancel";
  cancelButton.addEventListener("click", close2);
  let form = wrapper.appendChild(document.createElement("form"));
  if (options.title)
    form.appendChild(document.createElement("h5")).textContent = options.title;
  domFields.forEach((field) => {
    form.appendChild(document.createElement("div")).appendChild(field);
  });
  let buttons = form.appendChild(document.createElement("div"));
  buttons.className = prefix$1 + "-buttons";
  buttons.appendChild(submitButton);
  buttons.appendChild(document.createTextNode(" "));
  buttons.appendChild(cancelButton);
  let box = wrapper.getBoundingClientRect();
  wrapper.style.top = (window.innerHeight - box.height) / 2 + "px";
  wrapper.style.left = (window.innerWidth - box.width) / 2 + "px";
  let submit = () => {
    let params = getValues(options.fields, domFields);
    if (params) {
      close2();
      options.callback(params);
    }
  };
  form.addEventListener("submit", (e) => {
    e.preventDefault();
    submit();
  });
  form.addEventListener("keydown", (e) => {
    if (e.keyCode == 27) {
      e.preventDefault();
      close2();
    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
      e.preventDefault();
      submit();
    } else if (e.keyCode == 9) {
      window.setTimeout(() => {
        if (!wrapper.contains(document.activeElement))
          close2();
      }, 500);
    }
  });
  let input = form.elements[0];
  if (input)
    input.focus();
}
function getValues(fields, domFields) {
  let result2 = /* @__PURE__ */ Object.create(null), i = 0;
  for (let name in fields) {
    let field = fields[name], dom = domFields[i++];
    let value = field.read(dom), bad = field.validate(value);
    if (bad) {
      reportInvalid(dom, bad);
      return null;
    }
    result2[name] = field.clean(value);
  }
  return result2;
}
function reportInvalid(dom, message) {
  let parent = dom.parentNode;
  let msg = parent.appendChild(document.createElement("div"));
  msg.style.left = dom.offsetLeft + dom.offsetWidth + 2 + "px";
  msg.style.top = dom.offsetTop - 5 + "px";
  msg.className = "ProseMirror-invalid";
  msg.textContent = message;
  setTimeout(() => parent.removeChild(msg), 1500);
}
class Field {
  constructor(options) {
    this.options = options;
  }
  read(dom) {
    return dom.value;
  }
  validateType(value) {
    return null;
  }
  validate(value) {
    if (!value && this.options.required)
      return "Required field";
    return this.validateType(value) || (this.options.validate ? this.options.validate(value) : null);
  }
  clean(value) {
    return this.options.clean ? this.options.clean(value) : value;
  }
}
class TextField extends Field {
  render() {
    let input = document.createElement("input");
    input.type = "text";
    input.placeholder = this.options.label;
    input.value = this.options.value || "";
    input.autocomplete = "off";
    return input;
  }
}
function canInsert(state, nodeType8) {
  let $from = state.selection.$from;
  for (let d = $from.depth; d >= 0; d--) {
    let index8 = $from.index(d);
    if ($from.node(d).canReplaceWith(index8, index8, nodeType8))
      return true;
  }
  return false;
}
function insertImageItem(nodeType8) {
  return new MenuItem_1({
    title: "Insert image",
    label: "Image",
    enable(state) {
      return canInsert(state, nodeType8);
    },
    run(state, _, view2) {
      let { from: from12, to } = state.selection, attrs = null;
      if (state.selection instanceof NodeSelection_1 && state.selection.node.type == nodeType8)
        attrs = state.selection.node.attrs;
      openPrompt({
        title: "Insert image",
        fields: {
          src: new TextField({ label: "Location", required: true, value: attrs && attrs.src }),
          title: new TextField({ label: "Title", value: attrs && attrs.title }),
          alt: new TextField({
            label: "Description",
            value: attrs ? attrs.alt : state.doc.textBetween(from12, to, " ")
          })
        },
        callback(attrs2) {
          view2.dispatch(view2.state.tr.replaceSelectionWith(nodeType8.createAndFill(attrs2)));
          view2.focus();
        }
      });
    }
  });
}
function cmdItem(cmd, options) {
  let passedOptions = {
    label: options.title,
    run: cmd
  };
  for (let prop in options)
    passedOptions[prop] = options[prop];
  if (!options.enable && !options.select)
    passedOptions[options.enable ? "enable" : "select"] = (state) => cmd(state);
  return new MenuItem_1(passedOptions);
}
function markActive(state, type) {
  let { from: from12, $from, to, empty: empty2 } = state.selection;
  if (empty2)
    return !!type.isInSet(state.storedMarks || $from.marks());
  else
    return state.doc.rangeHasMark(from12, to, type);
}
function markItem(markType, options) {
  let passedOptions = {
    active(state) {
      return markActive(state, markType);
    }
  };
  for (let prop in options)
    passedOptions[prop] = options[prop];
  return cmdItem(toggleMark_1(markType), passedOptions);
}
function linkItem(markType) {
  return new MenuItem_1({
    title: "Add or remove link",
    icon: icons_1.link,
    active(state) {
      return markActive(state, markType);
    },
    enable(state) {
      return !state.selection.empty;
    },
    run(state, dispatch3, view2) {
      if (markActive(state, markType)) {
        toggleMark_1(markType)(state, dispatch3);
        return true;
      }
      openPrompt({
        title: "Create a link",
        fields: {
          href: new TextField({
            label: "Link target",
            required: true
          }),
          title: new TextField({ label: "Title" })
        },
        callback(attrs) {
          toggleMark_1(markType, attrs)(view2.state, view2.dispatch);
          view2.focus();
        }
      });
    }
  });
}
function wrapListItem(nodeType8, options) {
  return cmdItem(wrapInList_1(nodeType8, options.attrs), options);
}
function buildMenuItems(schema2) {
  let r2 = {};
  let mark15;
  if (mark15 = schema2.marks.strong)
    r2.toggleStrong = markItem(mark15, { title: "Toggle strong style", icon: icons_1.strong });
  if (mark15 = schema2.marks.em)
    r2.toggleEm = markItem(mark15, { title: "Toggle emphasis", icon: icons_1.em });
  if (mark15 = schema2.marks.code)
    r2.toggleCode = markItem(mark15, { title: "Toggle code font", icon: icons_1.code });
  if (mark15 = schema2.marks.link)
    r2.toggleLink = linkItem(mark15);
  let node18;
  if (node18 = schema2.nodes.image)
    r2.insertImage = insertImageItem(node18);
  if (node18 = schema2.nodes.bullet_list)
    r2.wrapBulletList = wrapListItem(node18, {
      title: "Wrap in bullet list",
      icon: icons_1.bulletList
    });
  if (node18 = schema2.nodes.ordered_list)
    r2.wrapOrderedList = wrapListItem(node18, {
      title: "Wrap in ordered list",
      icon: icons_1.orderedList
    });
  if (node18 = schema2.nodes.blockquote)
    r2.wrapBlockQuote = wrapItem_1(node18, {
      title: "Wrap in block quote",
      icon: icons_1.blockquote
    });
  if (node18 = schema2.nodes.paragraph)
    r2.makeParagraph = blockTypeItem_1(node18, {
      title: "Change to paragraph",
      label: "Plain"
    });
  if (node18 = schema2.nodes.code_block)
    r2.makeCodeBlock = blockTypeItem_1(node18, {
      title: "Change to code block",
      label: "Code"
    });
  if (node18 = schema2.nodes.heading)
    for (let i = 1; i <= 10; i++)
      r2["makeHead" + i] = blockTypeItem_1(node18, {
        title: "Change to heading " + i,
        label: "Level " + i,
        attrs: { level: i }
      });
  if (node18 = schema2.nodes.horizontal_rule) {
    let hr = node18;
    r2.insertHorizontalRule = new MenuItem_1({
      title: "Insert horizontal rule",
      label: "Horizontal rule",
      enable(state) {
        return canInsert(state, hr);
      },
      run(state, dispatch3) {
        dispatch3(state.tr.replaceSelectionWith(hr.create()));
      }
    });
  }
  let cut15 = (arr) => arr.filter((x2) => x2);
  r2.insertMenu = new Dropdown_1(cut15([r2.insertImage, r2.insertHorizontalRule]), { label: "Insert" });
  r2.typeMenu = new Dropdown_1(cut15([r2.makeParagraph, r2.makeCodeBlock, r2.makeHead1 && new DropdownSubmenu_1(cut15([
    r2.makeHead1,
    r2.makeHead2,
    r2.makeHead3,
    r2.makeHead4,
    r2.makeHead5,
    r2.makeHead6
  ]), { label: "Heading" })]), { label: "Type..." });
  r2.inlineMenu = [cut15([r2.toggleStrong, r2.toggleEm, r2.toggleCode, r2.toggleLink])];
  r2.blockMenu = [cut15([
    r2.wrapBulletList,
    r2.wrapOrderedList,
    r2.wrapBlockQuote,
    joinUpItem_1,
    liftItem_1,
    selectParentNodeItem_1
  ])];
  r2.fullMenu = r2.inlineMenu.concat([[r2.insertMenu, r2.typeMenu]], [[undoItem_1, redoItem_1]], r2.blockMenu);
  return r2;
}
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function buildKeymap(schema2, mapKeys) {
  let keys3 = {}, type;
  function bind2(key, cmd) {
    if (mapKeys) {
      let mapped = mapKeys[key];
      if (mapped === false)
        return;
      if (mapped)
        key = mapped;
    }
    keys3[key] = cmd;
  }
  bind2("Mod-z", undo_1);
  bind2("Shift-Mod-z", redo_1);
  bind2("Backspace", undoInputRule_1);
  if (!mac)
    bind2("Mod-y", redo_1);
  bind2("Alt-ArrowUp", joinUp_1);
  bind2("Alt-ArrowDown", joinDown_1);
  bind2("Mod-BracketLeft", lift_1);
  bind2("Escape", selectParentNode_1);
  if (type = schema2.marks.strong) {
    bind2("Mod-b", toggleMark_1(type));
    bind2("Mod-B", toggleMark_1(type));
  }
  if (type = schema2.marks.em) {
    bind2("Mod-i", toggleMark_1(type));
    bind2("Mod-I", toggleMark_1(type));
  }
  if (type = schema2.marks.code)
    bind2("Mod-`", toggleMark_1(type));
  if (type = schema2.nodes.bullet_list)
    bind2("Shift-Ctrl-8", wrapInList_1(type));
  if (type = schema2.nodes.ordered_list)
    bind2("Shift-Ctrl-9", wrapInList_1(type));
  if (type = schema2.nodes.blockquote)
    bind2("Ctrl->", wrapIn_1(type));
  if (type = schema2.nodes.hard_break) {
    let br = type, cmd = chainCommands_1(exitCode_1, (state, dispatch3) => {
      if (dispatch3)
        dispatch3(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true;
    });
    bind2("Mod-Enter", cmd);
    bind2("Shift-Enter", cmd);
    if (mac)
      bind2("Ctrl-Enter", cmd);
  }
  if (type = schema2.nodes.list_item) {
    bind2("Enter", splitListItem_1(type));
    bind2("Mod-[", liftListItem_1(type));
    bind2("Mod-]", sinkListItem_1(type));
  }
  if (type = schema2.nodes.paragraph)
    bind2("Shift-Ctrl-0", setBlockType_1(type));
  if (type = schema2.nodes.code_block)
    bind2("Shift-Ctrl-\\", setBlockType_1(type));
  if (type = schema2.nodes.heading)
    for (let i = 1; i <= 6; i++)
      bind2("Shift-Ctrl-" + i, setBlockType_1(type, { level: i }));
  if (type = schema2.nodes.horizontal_rule) {
    let hr = type;
    bind2("Mod-_", (state, dispatch3) => {
      if (dispatch3)
        dispatch3(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
      return true;
    });
  }
  return keys3;
}
function blockQuoteRule(nodeType8) {
  return wrappingInputRule_1(/^\s*>\s$/, nodeType8);
}
function orderedListRule(nodeType8) {
  return wrappingInputRule_1(/^(\d+)\.\s$/, nodeType8, (match2) => ({ order: +match2[1] }), (match2, node18) => node18.childCount + node18.attrs.order == +match2[1]);
}
function bulletListRule(nodeType8) {
  return wrappingInputRule_1(/^\s*([-+*])\s$/, nodeType8);
}
function codeBlockRule(nodeType8) {
  return textblockTypeInputRule_1(/^```$/, nodeType8);
}
function headingRule(nodeType8, maxLevel) {
  return textblockTypeInputRule_1(new RegExp("^(#{1," + maxLevel + "})\\s$"), nodeType8, (match2) => ({ level: match2[1].length }));
}
function buildInputRules(schema2) {
  let rules = smartQuotes_1.concat(ellipsis_1, emDash_1), type;
  if (type = schema2.nodes.blockquote)
    rules.push(blockQuoteRule(type));
  if (type = schema2.nodes.ordered_list)
    rules.push(orderedListRule(type));
  if (type = schema2.nodes.bullet_list)
    rules.push(bulletListRule(type));
  if (type = schema2.nodes.code_block)
    rules.push(codeBlockRule(type));
  if (type = schema2.nodes.heading)
    rules.push(headingRule(type, 6));
  return inputRules_1({ rules });
}
function exampleSetup(options) {
  let plugins = [
    buildInputRules(options.schema),
    keymap_2(buildKeymap(options.schema, options.mapKeys)),
    keymap_2(baseKeymap_1),
    dropCursor_1(),
    gapCursor_1()
  ];
  if (options.menuBar !== false)
    plugins.push(menuBar_1({
      floating: options.floatingMenu !== false,
      content: options.menuContent || buildMenuItems(options.schema).fullMenu
    }));
  if (options.history !== false)
    plugins.push(history_2());
  return plugins.concat(new Plugin_1({
    props: {
      attributes: { class: "ProseMirror-example-setup-style" }
    }
  }));
}
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject$3(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err8) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from12;
  var to = toObject$3(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from12 = Object(arguments[s]);
    for (var key in from12) {
      if (hasOwnProperty$4.call(from12, key)) {
        to[key] = from12[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from12);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from12, symbols[i])) {
          to[symbols[i]] = from12[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n$1 = 60103, p$1 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$1 = 60109, r$1 = 60110, t = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  n$1 = w("react.element");
  p$1 = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q$1 = w("react.provider");
  r$1 = w("react.context");
  t = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}
var x = "function" === typeof Symbol && Symbol.iterator;
function y$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$1 = {};
function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C.prototype;
function E$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
var F$1 = E$1.prototype = new D$1();
F$1.constructor = E$1;
l(F$1, C.prototype);
F$1.isPureReactComponent = true;
var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
function J(a, b, c) {
  var e, d = {}, k = null, h = null;
  if (null != b)
    for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
      H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    d.children = c;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    d.children = f2;
  }
  if (a && a.defaultProps)
    for (e in g2 = a.defaultProps, g2)
      void 0 === d[e] && (d[e] = g2[e]);
  return { $$typeof: n$1, type: a, key: k, ref: h, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return "object" === typeof a && null !== a && a.$$typeof === n$1;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e, d) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k)
    a = null;
  var h = false;
  if (null === a)
    h = true;
  else
    switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n$1:
          case p$1:
            h = true;
        }
    }
  if (h)
    return h = a, d = d(h), a = "" === e ? "." + N$1(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = "" === e ? "." : e + ":";
  if (Array.isArray(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k = a[g2];
      var f2 = e + N$1(k, g2);
      h += O$1(k, b, c, f2, d);
    }
  else if (f2 = y$1(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k = a.next()).done; )
      k = k.value, f2 = e + N$1(k, g2++), h += O$1(k, b, c, f2, d);
  else if ("object" === k)
    throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}
function P$1(a, b, c) {
  if (null == a)
    return a;
  var e = [], d = 0;
  O$1(a, e, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e;
}
function Q(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      0 === a._status && (a._status = 2, a._result = b2);
    });
  }
  if (1 === a._status)
    return a._result;
  throw a._result;
}
var R$1 = { current: null };
function S$1() {
  var a = R$1.current;
  if (null === a)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (null === a || void 0 === a)
    throw Error(z(267, a));
  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = G$1.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b)
      H$1.call(b, f2) && !I$1.hasOwnProperty(f2) && (e[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    e.children = c;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    e.children = g2;
  }
  return {
    $$typeof: n$1,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};
react_production_min.createContext = function(a, b) {
  void 0 === b && (b = null);
  a = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var React = react.exports;
var React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  "default": React
}, [react.exports]);
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f2, g2, h, k;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w = function() {
      if (null !== t2)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w, 0), b;
        }
    };
    f2 = function(a) {
      null !== t2 ? setTimeout(f2, 0, a) : (t2 = a, setTimeout(w, 0));
    };
    g2 = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E;
    };
    k = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a = exports.unstable_now();
        E = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f2 = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a, b) {
      C2 = x2(function() {
        a(exports.unstable_now());
      }, b);
    };
    h = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (void 0 !== e && 0 < I2(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return void 0 === a ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (void 0 !== b) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length; d < e; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (void 0 !== n2 && 0 > I2(n2, c))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); null !== b; ) {
      if (null === b.callback)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f2(V2);
      else {
        var b = J2(M2);
        null !== b && g2(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
        var d = O2.callback;
        if ("function" === typeof d) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e = d(O2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? O2.callback = e : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g2(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), null === J2(L2) && a === J2(M2) && (S2 ? h() : S2 = true, g2(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f2(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m$1 = objectAssign, r = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (null === b || "undefined" === typeof b || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B(a, b, c, d, e, f2, g2) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    oa,
    pa
  );
  D[b] = new B(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f2 = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
  f2 || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;
function La(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var Ma;
function Na(a) {
  if (void 0 === Ma)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && "string" === typeof k.stack) {
      for (var e = k.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e.length - 1, h = f2.length - 1; 1 <= g2 && 0 <= h && e[g2] !== f2[h]; )
        h--;
      for (; 1 <= g2 && 0 <= h; g2--, h--)
        if (e[g2] !== f2[h]) {
          if (1 !== g2 || 1 !== h) {
            do
              if (g2--, h--, 0 > h || e[g2] !== f2[h])
                return "\n" + e[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m$1({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function $a(a, b) {
  b = b.checked;
  null != b && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function bb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    null != a2 && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m$1({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML)
    throw Error(y(91));
  return m$1({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var ub = m$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
      throw Error(y(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children)
        throw Error(y(60));
      if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (null != b.style && "object" !== typeof b.style)
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e, f2, g2, h, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e, f2, g2, h, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f2, g2, h, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function $b(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b)
      return b.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (null === b)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (null === e)
      break;
    var f2 = e.alternate;
    if (null === f2) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f2.child) {
      for (f2 = e.child; f2; ) {
        if (f2 === c)
          return ac(e), a;
        if (f2 === d)
          return ac(e), b;
        f2 = f2.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e, d = f2;
    else {
      for (var g2 = false, h = e.child; h; ) {
        if (h === c) {
          g2 = true;
          c = e;
          d = f2;
          break;
        }
        if (h === d) {
          g2 = true;
          d = e;
          c = f2;
          break;
        }
        h = h.sibling;
      }
      if (!g2) {
        for (h = f2.child; h; ) {
          if (h === c) {
            g2 = true;
            c = f2;
            d = e;
            break;
          }
          if (h === d) {
            g2 = true;
            d = f2;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g2)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (3 !== c.tag)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (5 === b.tag || 6 === b.tag)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; null !== b; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}
function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = rc(b, c, d, e, f2), null !== b && (b = Cb(b), null !== b && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), true;
    case "pointerover":
      var f2 = e.pointerId;
      nc.set(f2, tc(nc.get(f2) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f2 = e.pointerId, oc.set(f2, tc(oc.get(f2) || null, a, b, c, d, e)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (null !== b) {
    var c = Zb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = $b(c), null !== b) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (3 === b && c.stateNode.hydrate) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null !== c)
      return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (null !== a.blockedOn) {
      a = Cb(a.blockedOn);
      null !== a && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null !== c) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    null === a.blockedOn && jc.shift();
  }
  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== kc && Bc(kc, a);
  null !== lc && Bc(lc, a);
  null !== mc && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
    vc(c), null === c.blockedOn && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}
var Qc = r.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if (0 !== (1 & a))
    return F = 15, 1;
  if (0 !== (2 & a))
    return F = 14, 2;
  if (0 !== (4 & a))
    return F = 13, 4;
  var b = 24 & a;
  if (0 !== b)
    return F = 12, b;
  if (0 !== (a & 32))
    return F = 11, 32;
  b = 192 & a;
  if (0 !== b)
    return F = 10, b;
  if (0 !== (a & 256))
    return F = 9, 256;
  b = 3584 & a;
  if (0 !== b)
    return F = 8, b;
  if (0 !== (a & 4096))
    return F = 7, 4096;
  b = 4186112 & a;
  if (0 !== b)
    return F = 6, b;
  b = 62914560 & a;
  if (0 !== b)
    return F = 5, b;
  if (a & 67108864)
    return F = 4, 67108864;
  if (0 !== (a & 134217728))
    return F = 3, 134217728;
  b = 805306368 & a;
  if (0 !== b)
    return F = 2, b;
  if (0 !== (1073741824 & a))
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c)
    return F = 0;
  var d = 0, e = 0, f2 = a.expiredLanes, g2 = a.suspendedLanes, h = a.pingedLanes;
  if (0 !== f2)
    d = f2, e = F = 15;
  else if (f2 = c & 134217727, 0 !== f2) {
    var k = f2 & ~g2;
    0 !== k ? (d = Rc(k), e = F) : (h &= f2, 0 !== h && (d = Rc(h), e = F));
  } else
    f2 = c & ~g2, 0 !== f2 ? (d = Rc(f2), e = F) : 0 !== h && (d = Rc(h), e = F);
  if (0 === d)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (0 !== b && b !== d && 0 === (b & g2)) {
    Rc(b);
    if (e <= F)
      return b;
    F = e;
  }
  b = a.entangledLanes;
  if (0 !== b)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id$2(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f2 = yc(a, b, c, d);
      if (null === f2)
        e && sc(a, d);
      else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f2, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f2, a, b, c, d))
            return;
          sc(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);
  if (null !== e) {
    var f2 = Zb(e);
    if (null === f2)
      e = null;
    else {
      var g2 = f2.tag;
      if (13 === g2) {
        e = $b(f2);
        if (null !== e)
          return e;
        e = null;
      } else if (3 === g2) {
        if (f2.stateNode.hydrate)
          return 3 === f2.tag ? f2.stateNode.containerInfo : null;
        e = null;
      } else
        f2 !== e && (e = null);
    }
  }
  jd(a, b, d, e, c);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g2 = c - a;
  for (d = 1; d <= g2 && b[c - d] === e[f2 - d]; d++)
    ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f2, g2) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m$1(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m$1({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b)
      return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if ("change" === a)
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b) {
  if ("click" === a)
    return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a)
    return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b)
        for (var g2 = d.length - 1; 0 <= g2; g2--) {
          var h = d[g2], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f2 && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f2 = k;
        }
      else
        for (g2 = 0; g2 < d.length; g2++) {
          h = d[g2];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f2 && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f2 = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c;
  "selectionchange" === a && 9 !== c.nodeType && (f2 = c.ownerDocument);
  if (null !== d && !b && Ye.has(a)) {
    if ("scroll" !== a)
      return;
    e |= 2;
    f2 = d;
  }
  var g2 = $e(f2), h = a + "__" + (b ? "capture" : "bubble");
  g2.has(h) || (b && (e |= 4), af(f2, a, e, b), g2.add(h));
}
function af(a, b, c, d) {
  var e = Nc.get(b);
  switch (void 0 === e ? 2 : e) {
    case 0:
      e = gd;
      break;
    case 1:
      e = id$2;
      break;
    default:
      e = hd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
  d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g2 = d.tag;
        if (3 === g2 || 4 === g2) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e)
            break;
          if (4 === g2)
            for (g2 = d.return; null !== g2; ) {
              var k = g2.tag;
              if (3 === k || 4 === k) {
                if (k = g2.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h; ) {
            g2 = wc(h);
            if (null === g2)
              return;
            k = g2.tag;
            if (5 === k || 6 === k) {
              d = f2 = g2;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f2, e2 = xb(c), g3 = [];
    a: {
      var h2 = Mc.get(a);
      if (void 0 !== h2) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w = 0 !== (b & 4), z2 = !w && "scroll" === a, u2 = w ? null !== h2 ? h2 + "Capture" : null : h2;
        w = [];
        for (var t2 = d2, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w.length && (h2 = new k2(h2, x2, null, c, e2), g3.push({ event: h2, listeners: w }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h2 = "mouseover" === a || "pointerover" === a;
        k2 = "mouseout" === a || "pointerout" === a;
        if (h2 && 0 === (b & 16) && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              w = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k2 ? h2 : ue(k2);
            q2 = null == x2 ? h2 : ue(x2);
            h2 = new w(v2, t2 + "leave", k2, c, e2);
            h2.target = z2;
            h2.relatedTarget = q2;
            v2 = null;
            wc(e2) === d2 && (w = new w(u2, t2 + "enter", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);
            z2 = v2;
            if (k2 && x2)
              b: {
                w = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w = gf(w), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w === u2 || null !== u2 && w === u2.alternate)
                    break b;
                  w = gf(w);
                  u2 = gf(u2);
                }
                w = null;
              }
            else
              w = null;
            null !== k2 && hf(g3, h2, k2, w, false);
            null !== x2 && null !== z2 && hf(g3, z2, x2, w, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k2 = h2.nodeName && h2.nodeName.toLowerCase();
        if ("select" === k2 || "input" === k2 && "file" === h2.type)
          var J2 = ve;
        else if (me(h2))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne(g3, J2, c, e2);
          break a;
        }
        K2 && K2(a, h2, d2);
        "focusout" === a && (K2 = h2._wrapperState) && K2.controlled && "number" === h2.type && bb(h2, "number", h2.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe = K2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c, e2);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a, c) && (L2 = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L2 = "onCompositionStart");
      L2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          e2
        ), g3.push({ event: e2, listeners: d2 }), e2.data = Q2);
    }
    se(g3, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e = a, f2 = e.stateNode;
    5 === e.tag && null !== f2 && (e = f2, f2 = Ob(a, c), null != f2 && d.unshift(ef(a, f2, e)), f2 = Ob(a, b), null != f2 && d.push(ef(a, f2, e)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f2 = b._reactName, g2 = []; null !== c && c !== d; ) {
    var h = c, k = h.alternate, l2 = h.stateNode;
    if (null !== k && k === d)
      break;
    5 === h.tag && null !== l2 && (h = l2, e ? (k = Ob(c, f2), null != k && g2.unshift(ef(c, k, h))) : e || (k = Ob(c, f2), null != k && g2.push(ef(c, k, h))));
    c = c.return;
  }
  0 !== g2.length && a.push({ event: b, listeners: g2 });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a) {
  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
}
function rf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b)
          return a;
        b--;
      } else
        "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child)
        for (a = sf(a); null !== a; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f2;
  for (f2 in c)
    e[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Ff(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b);
  I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in a))
      throw Error(y(108, Ra(b) || "Unknown", e));
  return m$1({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}
var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (null !== bg) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (null !== c);
        }
      });
      ag = null;
    } catch (c) {
      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b) {
  if (a && a.defaultProps) {
    b = m$1({}, b);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; null !== a; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (null === c || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, null !== c && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && false !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (null !== a) {
    a = a.shared;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e = f2 = g2 : f2 = f2.next = g2;
        c = c.next;
      } while (null !== c);
      null === f2 ? e = f2 = b : f2 = f2.next = b;
    } else
      e = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k = h, l2 = k.next;
    k.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k;
    var n2 = a.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (null !== f2) {
    A2 = e.baseState;
    g2 = 0;
    n2 = l2 = k = null;
    do {
      h = f2.lane;
      var p2 = f2.eventTime;
      if ((d & h) === h) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f2;
          h = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p2, A2, h);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h = "function" === typeof C2 ? C2.call(p2, A2, h) : C2;
              if (null === h || void 0 === h)
                break a;
              A2 = m$1({}, A2, h);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f2.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f2] : h.push(f2));
      } else
        p2 = { eventTime: p2, lane: h, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g2 |= h;
      f2 = f2.next;
      if (null === f2)
        if (h = e.shared.pending, null === h)
          break;
        else
          f2 = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);
    null === n2 && (k = A2);
    e.baseState = k;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    Dg |= g2;
    a.lanes = g2;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e)
          throw Error(y(191, e));
        e.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : m$1({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f2 = zg(d, e);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  Ag(a, f2);
  Jg(a, e, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f2 = zg(d, e);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  Ag(a, f2);
  Jg(a, e, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e = zg(c, d);
  e.tag = 2;
  void 0 !== b && null !== b && (e.callback = b);
  Ag(a, e);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f2) : true;
}
function Mg(a, b, c) {
  var d = false, e = Cf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e.context = vg(f2) : (f2 = Ff(b) ? Df : M.current, e.context = Ef(a, f2));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (Gg(a, b, f2, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        null === a2 ? delete b2[e] : b2[e] = a2;
      };
      b._stringRef = e;
      return b;
    }
    if ("string" !== typeof a)
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if ("textarea" !== a.type)
    throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
      null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g2(b2) {
    a && null === b2.alternate && (b2.flags = 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (null !== b2 && b2.elementType === c2.type)
      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag)
      return b2 = Xg(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if ("string" === typeof b2 || "number" === typeof b2)
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(
          b2,
          a2.mode,
          c2,
          null
        ), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e2 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 || "number" === typeof c2)
      return null !== e2 ? null : h(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return null !== e2 ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e2) {
    if ("string" === typeof d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
        case ta:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e2, g3, h2, k2) {
    for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h2.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e2, u2, h2[z2], k2);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === n3.alternate && b(e2, u2);
      g3 = f2(n3, g3, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h2.length)
      return c(e2, u2), l3;
    if (null === u2) {
      for (; z2 < h2.length; z2++)
        u2 = A2(e2, h2[z2], k2), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e2, u2); z2 < h2.length; z2++)
      q2 = C2(u2, e2, z2, h2[z2], k2), null !== q2 && (a && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  function w(e2, g3, h2, k2) {
    var l3 = La(h2);
    if ("function" !== typeof l3)
      throw Error(y(150));
    h2 = l3.call(h2);
    if (null == h2)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h2.next(); null !== u2 && !n3.done; z2++, n3 = h2.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w2 = p2(e2, u2, n3.value, k2);
      if (null === w2) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === w2.alternate && b(e2, u2);
      g3 = f2(w2, g3, z2);
      null === t2 ? l3 = w2 : t2.sibling = w2;
      t2 = w2;
      u2 = q2;
    }
    if (n3.done)
      return c(e2, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h2.next())
        n3 = A2(e2, n3.value, k2), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h2.next())
      n3 = C2(u2, e2, z2, n3.value, k2), null !== n3 && (a && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  return function(a2, d2, f3, h2) {
    var k2 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
    k2 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case sa:
          a: {
            l3 = f3.key;
            for (k2 = d2; null !== k2; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f3.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f3.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f3.type) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f3.props);
                      d2.ref = Qg(a2, k2, f3);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f3.type === ua ? (d2 = Xg(f3.props.children, a2.mode, h2, f3.key), d2.return = a2, a2 = d2) : (h2 = Vg(f3.type, f3.key, f3.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f3), h2.return = a2, a2 = h2);
          }
          return g2(a2);
        case ta:
          a: {
            for (k2 = f3.key; null !== d2; ) {
              if (d2.key === k2)
                if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f3, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g2(a2);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f3, a2.mode, h2), d2.return = a2, a2 = d2), g2(a2);
    if (Pg(f3))
      return x2(a2, d2, f3, h2);
    if (La(f3))
      return w(a2, d2, f3, h2);
    l3 && Rg(a2, f3);
    if ("undefined" === typeof f3 && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I(ch, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H(ah);
  I(ah, b);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 64))
        return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (null === b)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e, f2) {
  xh = f2;
  R = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = null === a || null === a.memoizedState ? Dh : Eh;
  a = c(d, e);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y(301));
      f2 += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }
  vh.current = Gh;
  b = null !== S && null !== S.next;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T ? R.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (null === S) {
    var a = R.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = S.next;
  var b = null === T ? R.memoizedState : T.next;
  if (null !== b)
    T = b, S = a;
  else {
    if (null === a)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    null === T ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e) {
      var g2 = e.next;
      e.next = f2.next;
      f2.next = g2;
    }
    d.baseQueue = e = f2;
    c.pending = null;
  }
  if (null !== e) {
    e = e.next;
    d = d.baseState;
    var h = g2 = f2 = null, k = e;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        null === h ? (g2 = h = n2, f2 = d) : h = h.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (null !== k && k !== e);
    null === h ? f2 = d : h.next = g2;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f2;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g2 = e = e.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e);
    He(f2, b.memoizedState) || (ug = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (null !== e)
    a = e === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;
  if (null === e)
    throw Error(y(349));
  var f2 = b._getVersion, g2 = f2(b._source), h = vh.current, k = h.useState(function() {
    return Mh(e, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w = R;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f2(b._source);
    if (!He(g2, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
      a2 = e.mutableReadLanes;
      e.entangledLanes |= a2;
      for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
        var k2 = 31 - Vc(h2), v2 = 1 << k2;
        d2[k2] |= a2;
        h2 &= ~v2;
      }
    }
  }, [c, b, d]);
  h.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w);
        e.mutableReadLanes |= d2 & e.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R.updateQueue;
  null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e = Hh();
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== S) {
    var g2 = S.memoizedState;
    f2 = g2.destroy;
    if (null !== d && Bh(d, g2.deps)) {
      Rh(b, c, f2, d);
      return;
    }
  }
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, f2, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if ("function" === typeof b)
    return a = a(), b(a), function() {
      b(null);
    };
  if (null !== b && void 0 !== b)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function() {
    a(true);
  });
  gg(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e = Ig(a), f2 = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g2 = b.pending;
  null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b.pending = f2;
  g2 = a.alternate;
  if (a === R || null !== g2 && g2 === R)
    zh = yh = true;
  else {
    if (0 === a.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b.lastRenderedReducer, null !== g2))
      try {
        var h = b.lastRenderedState, k = g2(h, c);
        f2.eagerReducer = g2;
        f2.eagerState = k;
        if (He(k, h))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(
    null,
    b,
    a
  ), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    0 === (R.mode & 2) && (R.flags |= 516, Rh(
      5,
      function() {
        c("r:" + (tf++).toString(36));
      },
      void 0,
      null
    ));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e) {
  c = c.render;
  var f2 = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f2, e);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}
function ii(a, b, c, d, e, f2) {
  if (null === a) {
    var g2 = c.type;
    if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b.tag = 15, b.type = g2, ki(a, b, g2, d, e, f2);
    a = Vg(c.type, null, d, b, b.mode, f2);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g2 = a.child;
  if (0 === (e & f2) && (e = g2.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref))
    return hi(a, b, f2);
  b.flags |= 1;
  a = Tg(g2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e, f2) {
  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, 0 !== (f2 & e))
      0 !== (a.flags & 16384) && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f2);
  return li(a, b, c, d, f2);
}
function mi(a, b, c) {
  var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
    if (0 === (b.mode & 4))
      b.memoizedState = { baseLanes: 0 }, ni(b, c);
    else if (0 !== (c & 1073741824))
      b.memoizedState = { baseLanes: 0 }, ni(b, null !== f2 ? f2.baseLanes : c);
    else
      return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  else
    null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e) {
  var f2 = Ff(c) ? Df : M.current;
  f2 = Ef(b, f2);
  tg(b, e);
  c = Ch(a, b, c, d, f2, e);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}
function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f2 = true;
    Jf(b);
  } else
    f2 = false;
  tg(b, e);
  if (null === b.stateNode)
    null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
  else if (null === a) {
    var g2 = b.stateNode, h = b.memoizedProps;
    g2.props = h;
    var k = g2.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h !== d || k !== l2) && Ng(b, g2, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g2.state = p2;
    Cg(b, d, g2, e);
    k = b.memoizedState;
    h !== d || p2 !== k || N.current || wg ? ("function" === typeof n2 && (Gg(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g2.props = d, g2.state = k, g2.context = l2, d = h) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), d = false);
  } else {
    g2 = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : lg(b.type, h);
    g2.props = l2;
    A2 = b.pendingProps;
    p2 = g2.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h !== A2 || p2 !== k) && Ng(b, g2, d, k);
    wg = false;
    p2 = b.memoizedState;
    g2.state = p2;
    Cg(b, d, g2, e);
    var x2 = b.memoizedState;
    h !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
      d,
      x2,
      k
    ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, x2, k)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g2.props = d, g2.state = x2, g2.context = k, d = l2) : ("function" !== typeof g2.componentDidUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f2, e);
}
function qi(a, b, c, d, e, f2) {
  oi(a, b);
  var g2 = 0 !== (b.flags & 64);
  if (!d && !g2)
    return e && Kf(b, c, false), hi(a, b, f2);
  d = b.stateNode;
  ei.current = b;
  var h = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g2 ? (b.child = Yg(b, a.child, null, f2), b.child = Yg(b, null, h, f2)) : fi(a, b, h, f2);
  b.memoizedState = d.state;
  e && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e = P.current, f2 = false, g2;
  (g2 = 0 !== (b.flags & 64)) || (g2 = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
  g2 ? (f2 = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
  I(P, e & 1);
  if (null === a) {
    void 0 !== d.fallback && ph(b);
    a = d.children;
    e = d.fallback;
    if (f2)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if ("number" === typeof d.unstable_expectedLoadTime)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (null !== a.memoizedState) {
    if (f2)
      return d = wi(a, b, d.children, d.fallback, c), f2 = b.child, e = a.child.memoizedState, f2.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f2.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f2)
    return d = wi(a, b, d.children, d.fallback, c), f2 = b.child, e = a.child.memoizedState, f2.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f2.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e = a.mode, f2 = a.child;
  b = { mode: "hidden", children: b };
  0 === (e & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b) : f2 = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f2.return = a;
  c.return = a;
  f2.sibling = c;
  a.child = f2;
  return c;
}
function xi(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, { mode: "visible", children: c });
  0 === (b.mode & 2) && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e) {
  var f2 = b.mode, g2 = a.child;
  a = g2.sibling;
  var h = { mode: "hidden", children: c };
  0 === (f2 & 2) && b.child !== g2 ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g2 = c.lastEffect, null !== g2 ? (b.firstEffect = c.firstEffect, b.lastEffect = g2, g2.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g2, h);
  null !== a ? d = Tg(a, d) : (d = Xg(d, f2, e, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e, f2) {
  var g2 = a.memoizedState;
  null === g2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f2 } : (g2.isBackwards = b, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d, g2.tail = c, g2.tailMode = e, g2.lastEffect = f2);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (null !== a && 0 !== (a.flags & 64))
      a:
        for (a = b.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && yi(a, c);
          else if (19 === a.tag)
            yi(a, c);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I(P, d);
  if (0 === (b.mode & 2))
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; )
          a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, false, e, c, f2, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === ih(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        zi(b, true, c, null, f2, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if (0 !== (c & b.childLanes)) {
    if (null !== a && b.child !== a.child)
      throw Error(y(153));
    if (null !== b.child) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f2 = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f2 = [];
        break;
      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f2 = [];
        break;
      case "select":
        e = m$1({}, e, { value: void 0 });
        d = m$1({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
    }
    vb(c, d);
    var g2;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2])
        if ("style" === l2) {
          var h = e[l2];
          for (g2 in h)
            h.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h = null != e ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h && (null != k || null != h))
        if ("style" === l2)
          if (h) {
            for (g2 in h)
              !h.hasOwnProperty(g2) || k && k.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
            for (g2 in k)
              k.hasOwnProperty(g2) && h[g2] !== k[g2] && (c || (c = {}), c[g2] = k[g2]);
          } else
            c || (f2 || (f2 = []), f2.push(l2, c)), c = k;
        else
          "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f2 = f2 || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f2 = f2 || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && G("scroll", a), f2 || h === k || (f2 = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f2 = f2 || []).push(l2, k));
    }
    c && (f2 = f2 || []).push(
      "style",
      c
    );
    var l2 = f2;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; )
          null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e = dh(ch.current);
      c = b.type;
      if (null !== a && null != b.stateNode)
        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (null === b.stateNode)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[wf] = b;
          d[xf] = f2;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f2);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f2), G("invalid", d);
          }
          vb(c, f2);
          a = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e = f2[g2], "children" === g2 ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g2) && null != e && "onScroll" === g2 && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g2 = 9 === e.nodeType ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? "script" === c ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), "select" === c && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g2 = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;
            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++)
                G(Xe[e], a);
              e = d;
              break;
            case "source":
              G("error", a);
              e = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;
            case "details":
              G("toggle", a);
              e = d;
              break;
            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e = m$1({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;
            default:
              e = d;
          }
          vb(c, e);
          var h = e;
          for (f2 in h)
            if (h.hasOwnProperty(f2)) {
              var k = h[f2];
              "style" === f2 ? tb(a, k) : "dangerouslySetInnerHTML" === f2 ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f2 ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k && "onScroll" === f2 && G("scroll", a) : null != k && qa(a, f2, k, g2));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              null != d.value && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f2 = d.value;
              null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              "function" === typeof e.onClick && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && null != b.stateNode)
        Ei(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode)
          throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H(P);
      d = b.memoizedState;
      if (0 !== (b.flags & 64))
        return b.lanes = c, b;
      d = null !== d;
      c = false;
      null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
      if (d && !c && 0 !== (b.mode & 2))
        if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
          0 === V && (V = 3);
        else {
          if (0 === V || 3 === V)
            V = 4;
          null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H(P);
      d = b.memoizedState;
      if (null === d)
        return null;
      f2 = 0 !== (b.flags & 64);
      g2 = d.rendering;
      if (null === g2)
        if (f2)
          Fi(d, false);
        else {
          if (0 !== V || null !== a && 0 !== (a.flags & 64))
            for (a = b.child; null !== a; ) {
              g2 = ih(a);
              if (null !== g2) {
                b.flags |= 64;
                Fi(d, false);
                f2 = g2.updateQueue;
                null !== f2 && (b.updateQueue = f2, b.flags |= 4);
                null === d.lastEffect && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; null !== c; )
                  f2 = c, a = d, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          null !== d.tail && O() > Ji && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a = ih(g2), null !== a) {
            if (b.flags |= 64, f2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g2.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = d.last, null !== c ? c.sibling = g2 : b.child = g2, d.last = g2);
      }
      return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f2 ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if (0 !== (b & 64))
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f2) {
    e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = "function" === typeof WeakMap ? WeakMap : Map;
function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (null !== b)
    if ("function" === typeof b)
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && null !== a) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          if (3 === (a.tag & 3)) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          var e = a;
          d = e.next;
          e = e.tag;
          0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(
        d,
        b.memoizedState,
        a.__reactInternalSnapshotBeforeUpdate
      )));
      b = c.updateQueue;
      null !== b && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (null !== b) {
        a = null;
        if (null !== c.child)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (5 === c.tag) {
      var d = c.stateNode;
      if (b)
        d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (6 === c.tag)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f2) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (null !== a && (a = a.lastEffect, null !== a)) {
        var c = a = a.next;
        do {
          var d = c, e = d.destroy;
          d = d.tag;
          if (void 0 !== e)
            if (0 !== (d & 4))
              Zi(b, c);
            else {
              d = b;
              try {
                e();
              } catch (f2) {
                Wi(d, f2);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if ("function" === typeof a.componentWillUnmount)
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f2) {
          Wi(
            b,
            f2
          );
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function fj(a) {
  a: {
    for (var b = a.return; null !== b; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; null === c.sibling; ) {
          if (null === c.return || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
          if (c.flags & 2)
            continue b;
          if (null === c.child || 4 === c.tag)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e = 5 === d || 6 === d;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
  else if (4 !== d && (a = a.child, null !== a))
    for (gj(a, b, c), a = a.sibling; null !== a; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e = 5 === d || 6 === d;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (hj(a, b, c), a = a.sibling; null !== a; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e, f2; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (null === d)
            throw Error(y(160));
          e = d.stateNode;
          switch (d.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e = e.containerInfo;
              f2 = true;
              break a;
            case 4:
              e = e.containerInfo;
              f2 = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (5 === c.tag || 6 === c.tag) {
      a:
        for (var g2 = a, h = c, k = h; ; )
          if (bj(g2, k), null !== k.child && 4 !== k.tag)
            k.child.return = k, k = k.child;
          else {
            if (k === h)
              break a;
            for (; null === k.sibling; ) {
              if (null === k.return || k.return === h)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f2 ? (g2 = e, h = c.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h) : g2.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (4 === c.tag) {
      if (null !== c.child) {
        e = c.stateNode.containerInfo;
        f2 = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
      4 === c.tag && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = null !== c ? c.lastEffect : null;
      if (null !== c) {
        var d = c = c.next;
        do
          3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (null != c) {
        d = b.memoizedProps;
        var e = null !== a ? a.memoizedProps : d;
        a = b.type;
        var f2 = b.updateQueue;
        b.updateQueue = null;
        if (null !== f2) {
          c[xf] = d;
          "input" === a && "radio" === d.type && null != d.name && $a(c, d);
          wb(a, e);
          b = wb(a, d);
          for (e = 0; e < f2.length; e += 2) {
            var g2 = f2[e], h = f2[e + 1];
            "style" === g2 ? tb(c, h) : "dangerouslySetInnerHTML" === g2 ? ob(c, h) : "children" === g2 ? pb(c, h) : qa(c, g2, h, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f2 = d.value, null != f2 ? fb(c, !!d.multiple, f2, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b.stateNode)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b.memoizedState && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, null !== b.memoizedState);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if (0 === (a & 2))
    return 1;
  if (0 === (a & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
    return b;
  }
  a = eg();
  0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (null === a)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, 4 === V && Ii(a, W));
  var d = eg();
  1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f2 = a.expirationTimes, g2 = a.pendingLanes; 0 < g2; ) {
    var h = 31 - Vc(g2), k = 1 << h, l2 = f2[h];
    if (-1 === l2) {
      if (0 === (k & d) || 0 !== (k & e)) {
        l2 = b;
        Rc(k);
        var n2 = F;
        f2[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g2 &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F;
  if (0 === d)
    null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (null !== c) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X & 48))
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (0 === c)
    return null;
  var d = c;
  var e = X;
  X |= 16;
  var f2 = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  while (1);
  qg();
  oj.current = f2;
  X = e;
  null !== Y ? d = 0 : (U = null, W = 0, d = V);
  if (0 !== (tj & Hi))
    Qj(a, 0);
  else if (0 !== d) {
    2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
    if (1 === d)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (0 !== Uc(a, 0))
            break;
          e = a.suspendedLanes;
          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e = -1; 0 < c; ) {
          var g2 = 31 - Vc(c);
          f2 = 1 << g2;
          g2 = d[g2];
          g2 > e && (e = g2);
          c &= ~f2;
        }
        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if (0 !== (X & 48))
    throw Error(y(327));
  Oj();
  if (a === U && 0 !== (a.expiredLanes & W)) {
    var b = W;
    var c = Tj(a, b);
    0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
  if (1 === c)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function ni(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, pf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R.memoizedState; null !== d; ) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (null === c || null === c.return) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c.return, h = c, k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;
        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l2 = k;
          if (0 === (h.mode & 2)) {
            var n2 = h.alternate;
            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var A2 = 0 !== (P.current & 1), p2 = g2;
          do {
            var C2;
            if (C2 = 13 === p2.tag) {
              var x2 = p2.memoizedState;
              if (null !== x2)
                C2 = null !== x2.dehydrated ? true : false;
              else {
                var w = p2.memoizedProps;
                C2 = void 0 === w.fallback ? false : true !== w.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p2.mode & 2)) {
                p2.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (1 === h.tag)
                  if (null === h.alternate)
                    h.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h, t2);
                  }
                h.lanes |= 1;
                break a;
              }
              k = void 0;
              h = b;
              var q2 = f2.pingCache;
              null === q2 ? (q2 = f2.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), void 0 === k && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
              if (!k.has(h)) {
                k.add(h);
                var v2 = Yj.bind(null, f2, l2, h);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (null !== p2);
          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V && (V = 2);
        k = Mi(k, h);
        p2 = g2;
        do {
          switch (p2.tag) {
            case 3:
              f2 = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi(p2, f2, b);
              Bg(p2, J2);
              break a;
            case 1:
              f2 = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f2, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (null !== p2);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return null === a ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (null !== Y)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; null !== Y; )
    bk(Y);
}
function Rj() {
  for (; null !== Y && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  null === b ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 2048)) {
      c = Gi(c, b, qj);
      if (null !== c) {
        Y = c;
        return;
      }
      c = b;
      if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
        for (var d = 0, e = c.child; null !== e; )
          d |= e.lanes | e.childLanes, e = e.sibling;
        c.childLanes = d;
      }
      null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (null !== c) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === V && (V = 5);
}
function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X & 48))
    throw Error(y(327));
  var c = a.finishedWork;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e = d, f2 = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;
  for (var g2 = a.eventTimes, h = a.expirationTimes; 0 < f2; ) {
    var k = 31 - Vc(f2), l2 = 1 << k;
    e[k] = 0;
    g2[k] = -1;
    h[k] = -1;
    f2 &= ~l2;
  }
  null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (null !== d) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h = { start: g2.selectionStart, end: g2.selectionEnd };
      else
        a:
          if (h = (h = g2.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && 0 !== l2.rangeCount) {
            h = l2.anchorNode;
            f2 = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h.nodeType, k.nodeType;
            } catch (va) {
              h = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w !== h || 0 !== f2 && 3 !== w.nodeType || (A2 = n2 + f2);
                  w !== k || 0 !== l2 && 3 !== w.nodeType || (p2 = n2 + l2);
                  3 === w.nodeType && (n2 += w.nodeValue.length);
                  if (null === (u2 = w.firstChild))
                    break;
                  z2 = w;
                  w = u2;
                }
                for (; ; ) {
                  if (w === g2)
                    break b;
                  z2 === h && ++C2 === f2 && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if (null !== (u2 = w.nextSibling))
                    break;
                  w = z2;
                  z2 = w.parentNode;
                }
                w = u2;
              }
            h = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
          } else
            h = null;
      h = h || { start: 0, end: 0 };
    } else
      h = null;
    lf = { focusedElem: g2, selectionRange: h };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Ij = null;
    Z = d;
    do
      try {
        for (g2 = a; null !== Z; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h = Z;
              cj(g2, h);
              var J2 = h.alternate;
              dj(h);
              null !== J2 && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g2.start, h), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h), !v2.extend && J2 > g2 && (h = g2, g2 = J2, J2 = h), h = Le(t2, J2), f2 = Le(t2, g2), h && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; null !== Z; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (null !== Q2) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Z = null;
    $f();
    X = e;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; null !== Z; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  0 === d && (Ti = null);
  1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if (0 !== (X & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z; ) {
    var a = Z.alternate;
    Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    0 !== (b & 256) && Xi(a, Z);
    0 === (b & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a = yj;
  yj = null;
  if (0 !== (X & 48))
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e = c[d], f2 = c[d + 1], g2 = e.destroy;
    e.destroy = void 0;
    if ("function" === typeof g2)
      try {
        g2();
      } catch (k) {
        if (null === f2)
          throw Error(y(330));
        Wi(f2, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f2 = c[d + 1];
    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (null === f2)
        throw Error(y(330));
      Wi(f2, k);
    }
  }
  for (h = a.current.firstEffect; null !== h; )
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  null !== a && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (3 === a.tag)
    gk(a, a, b);
  else
    for (var c = a.return; null !== c; ) {
      if (3 === c.tag) {
        gk(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;
        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (null !== c)
            $c(c, 1, e), Mj(c, e);
          else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f2) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  null !== c && c.delete(b);
  b = 0;
  0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  null !== a && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (null !== a)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if (0 !== (c & d))
      ug = 0 !== (a.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I(mg, e._currentValue);
          e._currentValue = d;
          break;
        case 13:
          if (null !== b.memoizedState) {
            if (0 !== (c & b.child.childLanes))
              return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return null !== b ? b.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 64)) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;
      if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f2 = true;
          Jf(b);
        } else
          f2 = false;
        b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
        xg(b);
        var g2 = d.getDerivedStateFromProps;
        "function" === typeof g2 && Gg(b, d, g2, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f2, c);
      } else
        b.tag = 0, fi(null, b, e, c), b = b.child;
      return b;
    case 16:
      e = b.elementType;
      a: {
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f2 = e._init;
        e = f2(e._payload);
        b.type = e;
        f2 = b.tag = hk(e);
        a = lg(e, a);
        switch (f2) {
          case 0:
            b = li(null, b, e, a, c);
            break a;
          case 1:
            b = pi(null, b, e, a, c);
            break a;
          case 11:
            b = gi(null, b, e, a, c);
            break a;
          case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);
            break a;
        }
        throw Error(y(306, e, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (null === a || null === d)
        throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = null !== e ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e)
        sh(), b = hi(a, b, c);
      else {
        e = b.stateNode;
        if (f2 = e.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f2 = lh = true;
        if (f2) {
          a = e.mutableSourceEagerHydrationData;
          if (null != a)
            for (e = 0; e < a.length; e += 2)
              f2 = a[e], f2._workInProgressVersionPrimary = a[e + 1], th.push(f2);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e.children, nf(d, e) ? g2 = null : null !== f2 && nf(d, f2) && (b.flags |= 16), oi(a, b), fi(a, b, g2, c), b.child;
    case 6:
      return null === a && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(
        a,
        b,
        b.pendingProps.children,
        c
      ), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g2 = b.memoizedProps;
        f2 = e.value;
        var h = b.type._context;
        I(mg, h._currentValue);
        h._currentValue = f2;
        if (null !== g2)
          if (h = g2.value, f2 = He(h, f2) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f2) : 1073741823) | 0, 0 === f2) {
            if (g2.children === e.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h = b.child, null !== h && (h.return = b); null !== h; ) {
              var k = h.dependencies;
              if (null !== k) {
                g2 = h.child;
                for (var l2 = k.firstContext; null !== l2; ) {
                  if (l2.context === d && 0 !== (l2.observedBits & f2)) {
                    1 === h.tag && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));
                    h.lanes |= c;
                    l2 = h.alternate;
                    null !== l2 && (l2.lanes |= c);
                    sg(h.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;
              if (null !== g2)
                g2.return = h;
              else
                for (g2 = h; null !== g2; ) {
                  if (g2 === b) {
                    g2 = null;
                    break;
                  }
                  h = g2.sibling;
                  if (null !== h) {
                    h.return = g2.return;
                    g2 = h;
                    break;
                  }
                  g2 = g2.return;
                }
              h = g2;
            }
        fi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, f2 = b.pendingProps, d = f2.children, tg(b, c), e = vg(
        e,
        f2.unstable_observedBits
      ), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e = b.type, f2 = lg(e, b.pendingProps), f2 = lg(e.type, f2), ii(a, b, e, f2, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if ("function" === typeof a)
    return ji(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e, f2) {
  var g2 = 2;
  d = a;
  if ("function" === typeof a)
    ji(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e, f2, b);
        case Ha:
          g2 = 8;
          e |= 16;
          break;
        case wa:
          g2 = 8;
          e |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f2, a;
        case Ba:
          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f2, a;
        case Ca:
          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f2, a;
        case Ia:
          return vi(c, e, f2, b);
        case Ja:
          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f2, a;
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case za:
                g2 = 9;
                break a;
              case Aa:
                g2 = 11;
                break a;
              case Da:
                g2 = 14;
                break a;
              case Ea:
                g2 = 16;
                d = null;
                break a;
              case Fa:
                g2 = 22;
                break a;
            }
          throw Error(y(130, null == a ? a : typeof a, ""));
      }
  b = nh(g2, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current, f2 = Hg(), g2 = Ig(e);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || 1 !== c.tag)
          throw Error(y(170));
        var h = c;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;
            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h = h.return;
        } while (null !== h);
        throw Error(y(171));
      }
      if (1 === c.tag) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }
      c = h;
    } else
      c = Cf;
  null === b.context ? b.context = c : b.pendingContext = c;
  b = zg(f2, g2);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  Ag(e, b);
  Jg(e, g2, f2);
  return g2;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function ok2(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, null != c && true === c.hydrate);
  b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(8 === a.nodeType ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function sk(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if ("function" === typeof e) {
      var h = e;
      e = function() {
        var a2 = mk(g2);
        h.call(a2);
      };
    }
    lk(b, g2, a, e);
  } else {
    f2 = c._reactRootContainer = sk(c, d);
    g2 = f2._internalRoot;
    if ("function" === typeof e) {
      var k = e;
      e = function() {
        var a2 = mk(g2);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g2, a, e);
    });
  }
  return mk(g2);
}
ec = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 4, b);
    ok2(a, 4);
  }
};
fc = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok2(a, 67108864);
  }
};
gc = function(a) {
  if (13 === a.tag) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok2(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e) {
  var f2 = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f2, 0 === X && (wj(), ig());
  }
};
Ib = function() {
  0 === (X & 49) && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render)
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if (0 !== (c & 48))
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err8) {
    console.error(err8);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
var lib$3 = { exports: {} };
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err8 = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err8.name = "Invariant Violation";
    throw err8;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
(function(module, exports) {
  exports.__esModule = true;
  var _react3 = react.exports;
  _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function createEventEmitter(value) {
    var handlers2 = [];
    return {
      on: function on(handler) {
        handlers2.push(handler);
      },
      off: function off(handler) {
        handlers2 = handlers2.filter(function(h) {
          return h !== handler;
        });
      },
      get: function get4() {
        return value;
      },
      set: function set(newValue) {
        value = newValue;
        handlers2.forEach(function(handler) {
          return handler(value);
        });
      }
    };
  }
  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }
  var uniqueId = 0;
  function createReactContext2(defaultValue) {
    var _Provider$childContex, _Consumer$contextType;
    var contextProp = "__create-react-context-" + uniqueId++ + "__";
    var Provider2 = function(_Component) {
      _inherits2(Provider3, _Component);
      function Provider3() {
        var _temp2, _this, _ret;
        _classCallCheck2(this, Provider3);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp2 = (_this = _possibleConstructorReturn2(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp2), _possibleConstructorReturn2(_this, _ret);
      }
      Provider3.prototype.getChildContext = function getChildContext() {
        var _ref;
        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };
      Provider3.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          this.emitter.set(nextProps.value);
        }
      };
      Provider3.prototype.render = function render4() {
        return this.props.children;
      };
      return Provider3;
    }(_react3.Component);
    Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes22.default.object.isRequired, _Provider$childContex);
    var Consumer = function(_Component2) {
      _inherits2(Consumer2, _Component2);
      function Consumer2() {
        var _temp2, _this2, _ret2;
        _classCallCheck2(this, Consumer2);
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn2(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
          value: _this2.getValue()
        }, _this2.onUpdate = function() {
          _this2.setState({
            value: _this2.getValue()
          });
        }, _temp2), _possibleConstructorReturn2(_this2, _ret2);
      }
      Consumer2.prototype.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
      };
      Consumer2.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };
      Consumer2.prototype.getValue = function getValue2() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };
      Consumer2.prototype.render = function render4() {
        return onlyChild(this.props.children)(this.state.value);
      };
      return Consumer2;
    }(_react3.Component);
    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes22.default.object, _Consumer$contextType);
    return {
      Provider: Provider2,
      Consumer
    };
  }
  exports.default = createReactContext2;
  module.exports = exports["default"];
})(lib$3, lib$3.exports);
var createReactContext = /* @__PURE__ */ getDefaultExportFromCjs(lib$3.exports);
var _typeof$e = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
function _possibleConstructorReturn$c(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var StateContext = createReactContext(null);
var Container = function() {
  function Container2() {
    var _this = this;
    _classCallCheck$c(this, Container2);
    this._listeners = [];
    CONTAINER_DEBUG_CALLBACKS.forEach(function(cb2) {
      return cb2(_this);
    });
  }
  Container2.prototype.setState = function setState(updater, callback) {
    var _this2 = this;
    return Promise.resolve().then(function() {
      var nextState = void 0;
      if (typeof updater === "function") {
        nextState = updater(_this2.state);
      } else {
        nextState = updater;
      }
      if (nextState == null) {
        if (callback)
          callback();
        return;
      }
      _this2.state = Object.assign({}, _this2.state, nextState);
      var promises = _this2._listeners.map(function(listener) {
        return listener();
      });
      return Promise.all(promises).then(function() {
        if (callback) {
          return callback();
        }
      });
    });
  };
  Container2.prototype.subscribe = function subscribe(fn) {
    this._listeners.push(fn);
  };
  Container2.prototype.unsubscribe = function unsubscribe(fn) {
    this._listeners = this._listeners.filter(function(f2) {
      return f2 !== fn;
    });
  };
  return Container2;
}();
var DUMMY_STATE = {};
var Subscribe = function(_React$Component) {
  _inherits$c(Subscribe2, _React$Component);
  function Subscribe2() {
    var _temp2, _this3, _ret;
    _classCallCheck$c(this, Subscribe2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp2 = (_this3 = _possibleConstructorReturn$c(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this3), _this3.state = {}, _this3.instances = [], _this3.unmounted = false, _this3.onUpdate = function() {
      return new Promise(function(resolve19) {
        if (!_this3.unmounted) {
          _this3.setState(DUMMY_STATE, resolve19);
        } else {
          resolve19();
        }
      });
    }, _temp2), _possibleConstructorReturn$c(_this3, _ret);
  }
  Subscribe2.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;
    this._unsubscribe();
  };
  Subscribe2.prototype._unsubscribe = function _unsubscribe() {
    var _this4 = this;
    this.instances.forEach(function(container) {
      container.unsubscribe(_this4.onUpdate);
    });
  };
  Subscribe2.prototype._createInstances = function _createInstances(map19, containers) {
    var _this5 = this;
    this._unsubscribe();
    if (map19 === null) {
      throw new Error("You must wrap your <Subscribe> components with a <Provider>");
    }
    var safeMap = map19;
    var instances = containers.map(function(ContainerItem) {
      var instance = void 0;
      if ((typeof ContainerItem === "undefined" ? "undefined" : _typeof$e(ContainerItem)) === "object" && ContainerItem instanceof Container) {
        instance = ContainerItem;
      } else {
        instance = safeMap.get(ContainerItem);
        if (!instance) {
          instance = new ContainerItem();
          safeMap.set(ContainerItem, instance);
        }
      }
      instance.unsubscribe(_this5.onUpdate);
      instance.subscribe(_this5.onUpdate);
      return instance;
    });
    this.instances = instances;
    return instances;
  };
  Subscribe2.prototype.render = function render4() {
    var _this6 = this;
    return React.createElement(
      StateContext.Consumer,
      null,
      function(map19) {
        return _this6.props.children.apply(null, _this6._createInstances(map19, _this6.props.to));
      }
    );
  };
  return Subscribe2;
}(React.Component);
function Provider(props) {
  return React.createElement(
    StateContext.Consumer,
    null,
    function(parentMap) {
      var childMap = new Map(parentMap);
      if (props.inject) {
        props.inject.forEach(function(instance) {
          childMap.set(instance.constructor, instance);
        });
      }
      return React.createElement(
        StateContext.Provider,
        { value: childMap },
        props.children
      );
    }
  );
}
var CONTAINER_DEBUG_CALLBACKS = [];
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$b(o, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function() {
    var Super = _getPrototypeOf$a(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result2);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var GlobalStateContainer = /* @__PURE__ */ function(_Container) {
  _inherits$b(GlobalStateContainer2, _Container);
  var _super = _createSuper$a(GlobalStateContainer2);
  function GlobalStateContainer2() {
    var _this;
    _classCallCheck$b(this, GlobalStateContainer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$a(_this), "state", {
      opened: false,
      tabIndex: "state",
      defaultSize: 0.5
    });
    _defineProperty$6(_assertThisInitialized$a(_this), "toggleDevTools", function() {
      var _this$state = _this.state, opened = _this$state.opened, defaultSize = _this$state.defaultSize;
      if (opened) {
        document.querySelector("html").style.marginBottom = "";
      } else {
        var size = defaultSize * window.innerHeight;
        document.querySelector("html").style.marginBottom = "".concat(size, "px");
      }
      _this.setState({
        opened: !opened
      });
    });
    _defineProperty$6(_assertThisInitialized$a(_this), "selectTab", function() {
      var tabIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      _this.setState({
        tabIndex
      });
    });
    _defineProperty$6(_assertThisInitialized$a(_this), "updateBodyMargin", function(devToolsSize) {
      var size = devToolsSize * window.innerHeight;
      document.querySelector("html").style.marginBottom = "".concat(size, "px");
    });
    return _this;
  }
  return GlobalStateContainer2;
}(Container);
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before8;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before8 = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before8 = _this.container.firstChild;
        } else {
          before8 = _this.before;
        }
      } else {
        before8 = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before8);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes2) {
    nodes2.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush3() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs$1 = Math.abs;
var from10 = String.fromCharCode;
var assign$2 = Object.assign;
function hash(value, length2) {
  return (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$17(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index8) {
  return value.charCodeAt(index8) | 0;
}
function substr(value, begin, end8) {
  return value.slice(begin, end8);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append8(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character$1 = 0;
var characters = "";
function node$1(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign$2(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character$1;
}
function prev() {
  character$1 = position > 0 ? charat(characters, --position) : 0;
  if (column--, character$1 === 10)
    column = 1, line--;
  return character$1;
}
function next() {
  character$1 = position < length ? charat(characters, position++) : 0;
  if (column++, character$1 === 10)
    column = 1, line++;
  return character$1;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice9(begin, end8) {
  return substr(characters, begin, end8);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice9(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character$1 = peek())
    if (character$1 < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character$1) > 3 ? "" : " ";
}
function escaping(index8, count) {
  while (--count && next())
    if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
      break;
  return slice9(index8, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character$1) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character$1);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index8) {
  while (next())
    if (type + character$1 === 47 + 10)
      break;
    else if (type + character$1 === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice9(index8, position - 1) + "*" + from10(type === 47 ? type : next());
}
function identifier(index8) {
  while (!token(peek()))
    next();
  return slice9(index8, position);
}
function compile13(value) {
  return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$1(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index8 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && characters2.charCodeAt(length2 - 1) == 58) {
          if (indexof(characters2 += replace$17(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append8(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index8++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (property > 0 && strlen(characters2) - length2)
              append8(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$17(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append8(reference = ruleset(characters2, root2, parent, index8, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$1(value, reference, reference, rule && append8(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index8 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from10(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index8++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index8, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index8; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs$1(j = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace$17(y2, /&\f/g, rule[x2])))
        props[k++] = z2;
  return node$1(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from10(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$17(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$17(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$17(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$17(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$17(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$17(value, "-grow", "") + WEBKIT + value + MS + replace$17(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$17(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$17(replace$17(replace$17(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$17(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$17(replace$17(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$17(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$17(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace$17(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$17(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$17(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$17(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$17(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$17(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index8, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index8, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index8, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index8, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, { value: replace$17(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, { props: [replace$17(value, /:(read-\w+)/, ":" + MOZ + "$1")] })], callback);
                case "::placeholder":
                  return serialize([
                    copy$1(element, { props: [replace$17(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }),
                    copy$1(element, { props: [replace$17(value, /:(plac\w+)/, ":" + MOZ + "$1")] }),
                    copy$1(element, { props: [replace$17(value, /:(plac\w+)/, MS + "input-$1")] })
                  ], callback);
              }
              return "";
            });
      }
  }
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index8) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index8] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice9(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index8 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index8] = 1;
        }
        parsed[index8] += identifierWithPointTracking(position - 1, points, index8);
        break;
      case 2:
        parsed[index8] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index8] = peek() === 58 ? "&\f" : "";
          points[index8] = parsed[index8].length;
          break;
        }
      default:
        parsed[index8] += from10(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node18) {
      var dataEmotionAttribute = node18.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node18);
      node18.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node18) {
        var attrib = node18.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node18);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile13(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser === false) && cache.registered[className] === void 0) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= k >>> 24;
    h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result2 = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result2);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create22) {
  return create22();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var EmotionCacheContext = /* @__PURE__ */ react.exports.createContext(
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var cache = react.exports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ react.exports.createContext({});
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = react.exports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ react.exports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$4({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
var jsonTreeTheme = {
  scheme: "monokai",
  base00: "#363755",
  base01: "#604D49",
  base02: "#6D5A55",
  base03: "#D1929B",
  base04: "#B79F8D",
  base05: "#F9F8F2",
  base06: "#F7F4F1",
  base07: "#FAF8F5",
  base08: "#FA3E7E",
  base09: "#FD993C",
  base0A: "#F6BF81",
  base0B: "#B8E248",
  base0C: "#B4EFE4",
  base0D: "#85D9EF",
  base0E: "#BE87FF",
  base0F: "#D6724C"
};
var mainTheme = {
  main: "#ffa2b1",
  main20: "rgba(255, 162, 177, .2)",
  main40: "rgba(255, 162, 177, .4)",
  main60: "rgba(255, 162, 177, .6)",
  main80: "rgba(255, 162, 177, .8)",
  main90: "rgba(255, 162, 177, .9)",
  mainBg: "#363755",
  softerMain: "#BB91A3",
  white: "#fff",
  white05: "rgba(255, 255, 255, .05)",
  white10: "rgba(255, 255, 255, .1)",
  white20: "rgba(255, 255, 255, .2)",
  white60: "rgba(255, 255, 255, .6)",
  white80: "rgba(255, 255, 255, .8)",
  black30: "rgba(0, 0, 0, .3)",
  lightYellow: "#FFF9C4",
  lightPink: "#FB4B85",
  darkGreen: "#81AF6D",
  syntax: jsonTreeTheme
};
var FloattingButton = newStyled("div")({
  position: "fixed",
  bottom: "16px",
  right: "16px",
  background: mainTheme.mainBg,
  boxShadow: "0 0 30px ".concat(mainTheme.black30),
  borderRadius: "50%",
  padding: "4px 6px",
  transition: "opacity 0.3s",
  zIndex: 99999,
  "&:hover": {
    opacity: 0.7,
    cursor: "pointer"
  },
  "& svg": {
    width: "34px",
    height: "34px",
    position: "relative",
    bottom: "-2px"
  }
});
FloattingButton.displayName = "FloattingButton";
function DevToolsCollapsed(props) {
  return /* @__PURE__ */ React.createElement(FloattingButton, {
    onClick: props.onClick
  }, /* @__PURE__ */ React.createElement("svg", {
    width: "530",
    height: "530",
    viewBox: "0 0 530 530",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink"
  }, /* @__PURE__ */ React.createElement("title", null, "prosemirror"), /* @__PURE__ */ React.createElement("desc", null, "Created using Figma"), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#a",
    transform: "matrix(2 0 0 2 118 116)",
    fill: "#FFF"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#b",
    transform: "rotate(16 59.054 420.192) scale(2)",
    fill: "#FFF"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#c",
    transform: "matrix(2 0 0 2 154.024 141.58)",
    fill: "#363755"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#d",
    transform: "matrix(2 0 0 2 220 334.8)",
    fill: "#FFF"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#e",
    transform: "matrix(2 0 0 2 218.826 262.052)",
    fill: "#363755"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#f",
    transform: "matrix(2 0 0 2 197.108 184.998)",
    fill: "#FFF"
  }), /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#g",
    transform: "matrix(2 0 0 2 221.8 216)",
    fill: "#363755"
  }), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("path", {
    id: "a",
    d: "M73.5 0C32.859 0 0 32.859 0 73.5S32.859 147 73.5 147 147 114.141 147 73.5 114.069 0 73.5 0z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "b",
    d: "M193.601 107.116c0-13.376 8.238-23.91 20.619-31.153-2.244-7.447-5.19-14.6-8.824-21.32-13.886 3.633-25.12-1.799-34.568-11.26-9.449-9.437-12.344-20.672-8.709-34.571A111.362 111.362 0 0 0 140.799 0c-7.243 12.37-20.339 20.594-33.689 20.594-13.363 0-26.446-8.225-33.701-20.594A110.888 110.888 0 0 0 52.1 8.812c3.634 13.9.753 25.134-8.721 34.57-9.436 9.462-20.67 14.894-34.569 11.26A112.178 112.178 0 0 0 0 75.963c12.369 7.243 20.593 17.777 20.593 31.153 0 13.352-8.224 26.448-20.593 33.704a113.338 113.338 0 0 0 8.811 21.321c13.899-3.634 25.133-.752 34.569 8.697 9.448 9.462 12.355 20.696 8.721 34.57a112.653 112.653 0 0 0 21.32 8.837c7.243-12.407 20.338-20.619 33.702-20.619 13.35 0 26.446 8.225 33.701 20.619a114.22 114.22 0 0 0 21.32-8.837c-3.634-13.874-.752-25.108 8.709-34.57 9.449-9.437 20.683-14.869 34.569-11.26a112.343 112.343 0 0 0 8.823-21.321c-12.406-7.256-20.644-17.789-20.644-31.141zm-86.491 46.57c-25.732 0-46.58-20.849-46.58-46.57 0-25.733 20.86-46.595 46.58-46.595 25.732 0 46.567 20.875 46.567 46.595 0 25.734-20.835 46.57-46.567 46.57z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "c",
    d: "M98.088 49.91c-6.9 83.9 10.8 103.401 10.8 103.401s-55.1 5.499-82.7-13.401c-30.5-20.9-26-67.5-25.9-94.6.1-28.4 25.6-45.8 49.9-45.3 29.1.5 50.2 21.6 47.9 49.9z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "d",
    d: "M.1.1c12.2 33.3 22.5 42.7 40 55.2 25.3 18 36.6 17.5 76.3 41C78.1 60.3 30.8 45.7 0 0l.1.1z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "e",
    d: "M.687 36.474c3 13.3 17.9 29.9 30.4 41.6 24.8 23.2 42 22.4 86 54.7-18.2-51.8-18.8-62-43.5-106.1-24.7-44-67.6-20.3-67.6-20.3s-8.4 16.6-5.3 29.9v.2z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "f",
    d: "M38.346 11.5s-4-11.6-18-11.5c-30 .2-28.8 52.1 16.9 52 39.6-.1 39.2-49.4 16.1-49.6-10.2-.2-15 9.1-15 9.1z"
  }), /* @__PURE__ */ React.createElement("path", {
    id: "g",
    d: "M26.5 15c10.8 0 2 14.9-.6 20.9-1.8-8.4-10.2-20.9.6-20.9zM10.2.1C4.6.1 0 4.6 0 10.3c0 5.6 4.5 10.2 10.2 10.2 5.6 0 10.2-4.5 10.2-10.2C20.4 4.7 15.9.1 10.2.1zM40.7 0c-4.8 0-8.8 4.5-8.8 10.2 0 5.6 3.9 10.2 8.8 10.2 4.8 0 8.8-4.5 8.8-10.2C49.5 4.6 45.6 0 40.7 0z"
  }))));
}
var lib$2 = {};
var Dock$1 = {};
var funcTag$2 = "[object Function]";
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
var objectProto$2 = Object.prototype;
var fnToString = Function.prototype.toString;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
var objToString = objectProto$2.toString;
var reIsNative$1 = RegExp(
  "^" + fnToString.call(hasOwnProperty$3).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function getNative$2(object, key) {
  var value = object == null ? void 0 : object[key];
  return isNative(value) ? value : void 0;
}
function isFunction$2(value) {
  return isObject$a(value) && objToString.call(value) == funcTag$2;
}
function isObject$a(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction$2(value)) {
    return reIsNative$1.test(fnToString.call(value));
  }
  return isObjectLike$2(value) && reIsHostCtor$1.test(value);
}
var lodash__getnative = getNative$2;
var getNative$1 = lodash__getnative;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$2 = Math.max, nativeNow = getNative$1(Date, "now");
var now = nativeNow || function() {
  return new Date().getTime();
};
function debounce(func, wait, options) {
  var args, maxTimeoutId, result2, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = wait < 0 ? 0 : +wait || 0;
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (isObject$9(options)) {
    leading = !!options.leading;
    maxWait = "maxWait" in options && nativeMax$2(+options.maxWait || 0, wait);
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (maxTimeoutId) {
      clearTimeout(maxTimeoutId);
    }
    lastCalled = 0;
    maxTimeoutId = timeoutId = trailingCall = void 0;
  }
  function complete(isCalled, id2) {
    if (id2) {
      clearTimeout(id2);
    }
    maxTimeoutId = timeoutId = trailingCall = void 0;
    if (isCalled) {
      lastCalled = now();
      result2 = func.apply(thisArg, args);
      if (!timeoutId && !maxTimeoutId) {
        args = thisArg = void 0;
      }
    }
  }
  function delayed() {
    var remaining = wait - (now() - stamp);
    if (remaining <= 0 || remaining > wait) {
      complete(trailingCall, maxTimeoutId);
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  }
  function maxDelayed() {
    complete(trailing, timeoutId);
  }
  function debounced() {
    args = arguments;
    stamp = now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);
    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
      if (isCalled) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result2 = func.apply(thisArg, args);
      } else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (isCalled && timeoutId) {
      timeoutId = clearTimeout(timeoutId);
    } else if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      isCalled = true;
      result2 = func.apply(thisArg, args);
    }
    if (isCalled && !timeoutId && !maxTimeoutId) {
      args = thisArg = void 0;
    }
    return result2;
  }
  debounced.cancel = cancel;
  return debounced;
}
function isObject$9(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
var lodash_debounce = debounce;
var autoprefix$1 = {};
Object.defineProperty(autoprefix$1, "__esModule", {
  value: true
});
var _extends$3 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
autoprefix$1.default = autoprefix;
var vendorSpecificProperties = ["animation", "animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction", "appearance", "backfaceVisibility", "backgroundClip", "borderImage", "borderImageSlice", "boxSizing", "boxShadow", "contentColumns", "transform", "transformOrigin", "transformStyle", "transition", "transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction", "perspective", "perspectiveOrigin", "userSelect"];
var prefixes = ["Moz", "Webkit", "ms", "O"];
function prefixProp(key, value) {
  return prefixes.reduce(function(obj, pre) {
    return obj[pre + key[0].toUpperCase() + key.substr(1)] = value, obj;
  }, {});
}
function autoprefix(style2) {
  return Object.keys(style2).reduce(function(obj, key) {
    return vendorSpecificProperties.indexOf(key) !== -1 ? _extends$3({}, obj, prefixProp(key, style2[key])) : obj;
  }, style2);
}
Object.defineProperty(Dock$1, "__esModule", {
  value: true
});
Dock$1.default = void 0;
var _extends$2 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$6 = function() {
  function defineProperties3(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor2 = props[i];
      descriptor2.enumerable = descriptor2.enumerable || false;
      descriptor2.configurable = true;
      if ("value" in descriptor2)
        descriptor2.writable = true;
      Object.defineProperty(target, descriptor2.key, descriptor2);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties3(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties3(Constructor, staticProps);
    return Constructor;
  };
}();
var _class, _temp;
var _react = react.exports;
var _react2 = _interopRequireDefault$7(_react);
var _propTypes = propTypes.exports;
var _propTypes2 = _interopRequireDefault$7(_propTypes);
var _lodash$1 = lodash_debounce;
var _lodash2$1 = _interopRequireDefault$7(_lodash$1);
var _autoprefix = autoprefix$1;
var _autoprefix2 = _interopRequireDefault$7(_autoprefix);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$a(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function autoprefixes(styles2) {
  return Object.keys(styles2).reduce(function(obj, key) {
    return obj[key] = (0, _autoprefix2.default)(styles2[key]), obj;
  }, {});
}
var styles = autoprefixes({
  wrapper: {
    position: "fixed",
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  dim: {
    position: "fixed",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    zIndex: 0,
    background: "rgba(0, 0, 0, 0.2)",
    opacity: 1
  },
  dimAppear: {
    opacity: 0
  },
  dimTransparent: {
    pointerEvents: "none"
  },
  dimHidden: {
    opacity: 0
  },
  dock: {
    position: "fixed",
    zIndex: 1,
    boxShadow: "0 0 4px rgba(0, 0, 0, 0.3)",
    background: "white",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  },
  dockHidden: {
    opacity: 0
  },
  dockResizing: {
    transition: "none"
  },
  dockContent: {
    width: "100%",
    height: "100%",
    overflow: "auto"
  },
  resizer: {
    position: "absolute",
    zIndex: 2,
    opacity: 0
  }
});
function getTransitions(duration) {
  return ["left", "top", "width", "height"].map(function(p2) {
    return p2 + " " + duration / 1e3 + "s ease-out";
  });
}
function getDockStyles(_ref, _ref2) {
  var fluid = _ref.fluid;
  var dockStyle = _ref.dockStyle;
  var dockHiddenStyle = _ref.dockHiddenStyle;
  var duration = _ref.duration;
  var position2 = _ref.position;
  var isVisible = _ref.isVisible;
  var size = _ref2.size;
  var isResizing = _ref2.isResizing;
  var fullWidth = _ref2.fullWidth;
  var fullHeight = _ref2.fullHeight;
  var posStyle = void 0;
  var absSize = fluid ? size * 100 + "%" : size + "px";
  function getRestSize(fullSize) {
    return fluid ? 100 - size * 100 + "%" : fullSize - size + "px";
  }
  switch (position2) {
    case "left":
      posStyle = {
        width: absSize,
        left: isVisible ? 0 : "-" + absSize
      };
      break;
    case "right":
      posStyle = {
        left: isVisible ? getRestSize(fullWidth) : fullWidth,
        width: absSize
      };
      break;
    case "top":
      posStyle = {
        top: isVisible ? 0 : "-" + absSize,
        height: absSize
      };
      break;
    case "bottom":
      posStyle = {
        top: isVisible ? getRestSize(fullHeight) : fullHeight,
        height: absSize
      };
      break;
  }
  var transitions = getTransitions(duration);
  return [styles.dock, (0, _autoprefix2.default)({
    transition: [].concat(_toConsumableArray(transitions), [!isVisible && "opacity 0.01s linear " + duration / 1e3 + "s"]).filter(function(t2) {
      return t2;
    }).join(",")
  }), dockStyle, (0, _autoprefix2.default)(posStyle), isResizing && styles.dockResizing, !isVisible && styles.dockHidden, !isVisible && dockHiddenStyle];
}
function getDimStyles(_ref3, _ref4) {
  var dimMode = _ref3.dimMode;
  var dimStyle = _ref3.dimStyle;
  var duration = _ref3.duration;
  var isVisible = _ref3.isVisible;
  var isTransitionStarted = _ref4.isTransitionStarted;
  return [styles.dim, (0, _autoprefix2.default)({
    transition: "opacity " + duration / 1e3 + "s ease-out"
  }), dimStyle, dimMode === "transparent" && styles.dimTransparent, !isVisible && styles.dimHidden, isTransitionStarted && isVisible && styles.dimAppear, isTransitionStarted && !isVisible && styles.dimDisappear];
}
function getResizerStyles(position2) {
  var resizerStyle = void 0;
  var size = 10;
  switch (position2) {
    case "left":
      resizerStyle = {
        right: -size / 2,
        width: size,
        top: 0,
        height: "100%",
        cursor: "col-resize"
      };
      break;
    case "right":
      resizerStyle = {
        left: -size / 2,
        width: size,
        top: 0,
        height: "100%",
        cursor: "col-resize"
      };
      break;
    case "top":
      resizerStyle = {
        bottom: -size / 2,
        height: size,
        left: 0,
        width: "100%",
        cursor: "row-resize"
      };
      break;
    case "bottom":
      resizerStyle = {
        top: -size / 2,
        height: size,
        left: 0,
        width: "100%",
        cursor: "row-resize"
      };
      break;
  }
  return [styles.resizer, (0, _autoprefix2.default)(resizerStyle)];
}
function getFullSize(position2, fullWidth, fullHeight) {
  return position2 === "left" || position2 === "right" ? fullWidth : fullHeight;
}
var Dock = (_temp = _class = function(_Component) {
  _inherits$a(Dock2, _Component);
  function Dock2(props) {
    _classCallCheck$a(this, Dock2);
    var _this = _possibleConstructorReturn$a(this, Object.getPrototypeOf(Dock2).call(this, props));
    _this.transitionEnd = function() {
      _this.setState({ isTransitionStarted: false });
    };
    _this.hideDim = function() {
      if (!_this.props.isVisible) {
        _this.setState({ isDimHidden: true });
      }
    };
    _this.handleDimClick = function() {
      if (_this.props.dimMode === "opaque") {
        _this.props.onVisibleChange && _this.props.onVisibleChange(false);
      }
    };
    _this.handleResize = function() {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(_this.updateWindowSize.bind(_this, true));
      } else {
        _this.updateWindowSize(true);
      }
    };
    _this.updateWindowSize = function(windowResize) {
      var sizeState = {
        fullWidth: window.innerWidth,
        fullHeight: window.innerHeight
      };
      if (windowResize) {
        _this.setState(_extends$2({}, sizeState, {
          isResizing: true,
          isWindowResizing: windowResize
        }));
        _this.debouncedUpdateWindowSizeEnd();
      } else {
        _this.setState(sizeState);
      }
    };
    _this.updateWindowSizeEnd = function() {
      _this.setState({
        isResizing: false,
        isWindowResizing: false
      });
    };
    _this.debouncedUpdateWindowSizeEnd = (0, _lodash2$1.default)(_this.updateWindowSizeEnd, 30);
    _this.handleWrapperLeave = function() {
      _this.setState({ isResizing: false });
    };
    _this.handleMouseDown = function() {
      _this.setState({ isResizing: true });
    };
    _this.handleMouseUp = function() {
      _this.setState({ isResizing: false });
    };
    _this.handleMouseMove = function(e) {
      if (!_this.state.isResizing || _this.state.isWindowResizing)
        return;
      e.preventDefault();
      var _this$props = _this.props;
      var position2 = _this$props.position;
      var fluid = _this$props.fluid;
      var _this$state = _this.state;
      var fullWidth = _this$state.fullWidth;
      var fullHeight = _this$state.fullHeight;
      var isControlled = _this$state.isControlled;
      var x2 = e.clientX;
      var y2 = e.clientY;
      var size = void 0;
      switch (position2) {
        case "left":
          size = fluid ? x2 / fullWidth : x2;
          break;
        case "right":
          size = fluid ? (fullWidth - x2) / fullWidth : fullWidth - x2;
          break;
        case "top":
          size = fluid ? y2 / fullHeight : y2;
          break;
        case "bottom":
          size = fluid ? (fullHeight - y2) / fullHeight : fullHeight - y2;
          break;
      }
      _this.props.onSizeChange && _this.props.onSizeChange(size);
      if (!isControlled) {
        _this.setState({ size });
      }
    };
    _this.state = {
      isControlled: typeof props.size !== "undefined",
      size: props.size || props.defaultSize,
      isDimHidden: !props.isVisible,
      fullWidth: typeof window !== "undefined" && window.innerWidth,
      fullHeight: typeof window !== "undefined" && window.innerHeight,
      isTransitionStarted: false,
      isWindowResizing: false
    };
    return _this;
  }
  _createClass$6(Dock2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener("mouseup", this.handleMouseUp);
      window.addEventListener("mousemove", this.handleMouseMove);
      window.addEventListener("resize", this.handleResize);
      if (!window.fullWidth) {
        this.updateWindowSize();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("mouseup", this.handleMouseUp);
      window.removeEventListener("mousemove", this.handleMouseMove);
      window.removeEventListener("resize", this.handleResize);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var isControlled = typeof nextProps.size !== "undefined";
      this.setState({ isControlled });
      if (isControlled && this.props.size !== nextProps.size) {
        this.setState({ size: nextProps.size });
      } else if (this.props.fluid !== nextProps.fluid) {
        this.updateSize(nextProps);
      }
      if (this.props.isVisible !== nextProps.isVisible) {
        this.setState({
          isTransitionStarted: true
        });
      }
    }
  }, {
    key: "updateSize",
    value: function updateSize(props) {
      var _state = this.state;
      var fullWidth = _state.fullWidth;
      var fullHeight = _state.fullHeight;
      this.setState({
        size: props.fluid ? this.state.size / getFullSize(props.position, fullWidth, fullHeight) : getFullSize(props.position, fullWidth, fullHeight) * this.state.size
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;
      if (this.props.isVisible !== prevProps.isVisible) {
        if (!this.props.isVisible) {
          window.setTimeout(function() {
            return _this2.hideDim();
          }, this.props.duration);
        } else {
          this.setState({ isDimHidden: false });
        }
        window.setTimeout(function() {
          return _this2.setState({ isTransitionStarted: false });
        }, 0);
      }
    }
  }, {
    key: "render",
    value: function render4() {
      var _props = this.props;
      var children = _props.children;
      var zIndex = _props.zIndex;
      var dimMode = _props.dimMode;
      var position2 = _props.position;
      var isVisible = _props.isVisible;
      var _state2 = this.state;
      var isResizing = _state2.isResizing;
      var size = _state2.size;
      var isDimHidden = _state2.isDimHidden;
      var dimStyles = Object.assign.apply(Object, [{}].concat(_toConsumableArray(getDimStyles(this.props, this.state))));
      var dockStyles = Object.assign.apply(Object, [{}].concat(_toConsumableArray(getDockStyles(this.props, this.state))));
      var resizerStyles = Object.assign.apply(Object, [{}].concat(_toConsumableArray(getResizerStyles(position2))));
      return _react2.default.createElement(
        "div",
        { style: Object.assign({}, styles.wrapper, { zIndex }) },
        dimMode !== "none" && !isDimHidden && _react2.default.createElement("div", { style: dimStyles, onClick: this.handleDimClick }),
        _react2.default.createElement(
          "div",
          { style: dockStyles },
          _react2.default.createElement("div", {
            style: resizerStyles,
            onMouseDown: this.handleMouseDown
          }),
          _react2.default.createElement(
            "div",
            { style: styles.dockContent },
            typeof children === "function" ? children({
              position: position2,
              isResizing,
              size,
              isVisible
            }) : children
          )
        )
      );
    }
  }]);
  return Dock2;
}(_react.Component), _class.propTypes = {
  position: _propTypes2.default.oneOf(["left", "right", "top", "bottom"]),
  zIndex: _propTypes2.default.number,
  fluid: _propTypes2.default.bool,
  size: _propTypes2.default.number,
  defaultSize: _propTypes2.default.number,
  dimMode: _propTypes2.default.oneOf(["none", "transparent", "opaque"]),
  isVisible: _propTypes2.default.bool,
  onVisibleChange: _propTypes2.default.func,
  onSizeChange: _propTypes2.default.func,
  dimStyle: _propTypes2.default.object,
  dockStyle: _propTypes2.default.object,
  duration: _propTypes2.default.number
}, _class.defaultProps = {
  position: "left",
  zIndex: 99999999,
  fluid: true,
  defaultSize: 0.3,
  dimMode: "opaque",
  duration: 200
}, _temp);
Dock$1.default = Dock;
Object.defineProperty(lib$2, "__esModule", {
  value: true
});
var _default$1 = lib$2.default = void 0;
var _Dock = Dock$1;
var _Dock2 = _interopRequireDefault$6(_Dock);
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
_default$1 = lib$2.default = _Dock2.default;
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$a(o, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function() {
    var Super = _getPrototypeOf$9(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result2);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
var TabList = newStyled("div")({
  display: "flex",
  listStyle: "none",
  borderBottom: "1px solid ".concat(mainTheme.main20)
});
TabList.displayName = "TabList";
var TabsStled = newStyled("div")({
  height: "100%",
  width: "100%"
});
TabsStled.displayName = "TabsStyled";
var TabStyled = newStyled("div")({
  color: mainTheme.white,
  textTransform: "uppercase",
  fontSize: "13px",
  padding: "16px 24px 14px",
  boxSizing: "border-box",
  userSelect: "none",
  "&:hover": {
    cursor: "pointer",
    background: mainTheme.white05
  },
  "&:focus": {
    outline: "none"
  }
}, function(props) {
  return {
    borderBottom: props.isSelected ? "2px solid ".concat(mainTheme.main) : "none"
  };
});
TabStyled.displayName = "TabStyled";
var Tab = /* @__PURE__ */ function(_React$Component) {
  _inherits$9(Tab2, _React$Component);
  var _super = _createSuper$9(Tab2);
  function Tab2() {
    _classCallCheck$9(this, Tab2);
    return _super.apply(this, arguments);
  }
  _createClass$5(Tab2, [{
    key: "render",
    value: function render4() {
      var _this = this;
      return /* @__PURE__ */ React.createElement(TabStyled, {
        isSelected: this.props.index === this.context.tabs.selectedIndex,
        onClick: function onClick() {
          (_this.context.tabs.onSelect || function() {
          })(_this.props.index);
        }
      }, this.props.children);
    }
  }]);
  return Tab2;
}(React.Component);
Tab.contextTypes = {
  tabs: PropTypes.object.isRequired
};
var TabPanelStyled = newStyled("div")({
  width: "100%",
  height: "calc(100% - 48px)",
  boxSizing: "border-box"
});
TabPanelStyled.displayName = "TabPanelStyled";
var TabPanel = /* @__PURE__ */ function(_React$Component2) {
  _inherits$9(TabPanel2, _React$Component2);
  var _super2 = _createSuper$9(TabPanel2);
  function TabPanel2() {
    _classCallCheck$9(this, TabPanel2);
    return _super2.apply(this, arguments);
  }
  _createClass$5(TabPanel2, [{
    key: "render",
    value: function render4() {
      return /* @__PURE__ */ React.createElement(TabPanelStyled, null, this.props.children({
        index: this.context.tabs.selectedIndex
      }));
    }
  }]);
  return TabPanel2;
}(React.Component);
TabPanel.contextTypes = {
  tabs: PropTypes.object.isRequired
};
var Tabs = /* @__PURE__ */ function(_React$Component3) {
  _inherits$9(Tabs2, _React$Component3);
  var _super3 = _createSuper$9(Tabs2);
  function Tabs2() {
    _classCallCheck$9(this, Tabs2);
    return _super3.apply(this, arguments);
  }
  _createClass$5(Tabs2, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        tabs: {
          onSelect: this.props.onSelect,
          selectedIndex: this.props.selectedIndex
        }
      };
    }
  }, {
    key: "render",
    value: function render4() {
      return /* @__PURE__ */ React.createElement(TabsStled, null, this.props.children);
    }
  }]);
  return Tabs2;
}(React.Component);
Tabs.childContextTypes = {
  tabs: PropTypes.object
};
var regeneratorRuntime$1 = { exports: {} };
var _typeof$b = { exports: {} };
(function(module) {
  function _typeof4(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof4(obj);
  }
  module.exports = _typeof4, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$b);
(function(module) {
  var _typeof4 = _typeof$b.exports["default"];
  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol2 = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol2.iterator || "@@iterator", asyncIteratorSymbol = $Symbol2.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol2.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err8) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap2(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
      return generator._invoke = function(innerFn2, self3, context2) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context2.method = method, context2.arg = arg; ; ) {
            var delegate = context2.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context2);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context2.method)
              context2.sent = context2._sent = context2.arg;
            else if ("throw" === context2.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context2.arg;
              context2.dispatchException(context2.arg);
            } else
              "return" === context2.method && context2.abrupt("return", context2.arg);
            state = "executing";
            var record = tryCatch(innerFn2, self3, context2);
            if ("normal" === record.type) {
              if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context2.done
              };
            }
            "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
          }
        };
      }(innerFn, self2, context), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err8) {
        return {
          type: "throw",
          arg: err8
        };
      }
    }
    exports.wrap = wrap2;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype2 = {};
    define(IteratorPrototype2, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype2 = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve19, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result2 = record.arg, value = result2.value;
          return value && "object" == _typeof4(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve19, reject);
          }, function(err8) {
            invoke("throw", err8, resolve19, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result2.value = unwrapped, resolve19(result2);
          }, function(error) {
            return invoke("throw", error, resolve19, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      this._invoke = function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve19, reject) {
            invoke(method, arg, resolve19, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (void 0 === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method))
            return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type)
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next2 = function next3() {
            for (; ++i < iterable.length; ) {
              if (hasOwn.call(iterable, i))
                return next3.value = iterable[i], next3.done = false, next3;
            }
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result2) {
        return result2.done ? result2.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(object) {
      var keys3 = [];
      for (var key in object) {
        keys3.push(key);
      }
      return keys3.reverse(), function next2() {
        for (; keys3.length; ) {
          var key2 = keys3.pop();
          if (key2 in object)
            return next2.value = key2, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          }
      },
      stop: function stop7() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish17(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var runtime = regeneratorRuntime$1.exports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
function style_html(html_source, options) {
  var multi_parser, indent_size, indent_character, max_char, brace_style, unformatted;
  options = options || {};
  indent_size = options.indent_size || 4;
  indent_character = options.indent_char || " ";
  brace_style = options.brace_style || "collapse";
  max_char = options.max_char == 0 ? Infinity : options.max_char || 70;
  unformatted = options.unformatted || ["a", "span", "bdo", "em", "strong", "dfn", "code", "samp", "kbd", "var", "cite", "abbr", "acronym", "q", "sub", "sup", "tt", "i", "b", "big", "small", "u", "s", "strike", "font", "ins", "del", "pre", "address", "dt", "h1", "h2", "h3", "h4", "h5", "h6"];
  function Parser() {
    this.pos = 0;
    this.token = "";
    this.current_mode = "CONTENT";
    this.tags = {
      parent: "parent1",
      parentcount: 1,
      parent1: ""
    };
    this.tag_type = "";
    this.token_text = this.last_token = this.last_text = this.token_type = "";
    this.Utils = {
      whitespace: "\n\r	 ".split(""),
      single_token: "br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?=".split(","),
      extra_liners: "head,body,/html".split(","),
      in_array: function(what, arr) {
        for (var i = 0; i < arr.length; i++) {
          if (what === arr[i]) {
            return true;
          }
        }
        return false;
      }
    };
    this.get_content = function() {
      var input_char = "", content2 = [], space2 = false;
      while (this.input.charAt(this.pos) !== "<") {
        if (this.pos >= this.input.length) {
          return content2.length ? content2.join("") : ["", "TK_EOF"];
        }
        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;
        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (content2.length) {
            space2 = true;
          }
          this.line_char_count--;
          continue;
        } else if (space2) {
          if (this.line_char_count >= this.max_char) {
            content2.push("\n");
            for (var i = 0; i < this.indent_level; i++) {
              content2.push(this.indent_string);
            }
            this.line_char_count = 0;
          } else {
            content2.push(" ");
            this.line_char_count++;
          }
          space2 = false;
        }
        content2.push(input_char);
      }
      return content2.length ? content2.join("") : "";
    };
    this.get_contents_to = function(name) {
      if (this.pos == this.input.length) {
        return ["", "TK_EOF"];
      }
      var content2 = "";
      var reg_match = new RegExp("</" + name + "\\s*>", "igm");
      reg_match.lastIndex = this.pos;
      var reg_array = reg_match.exec(this.input);
      var end_script = reg_array ? reg_array.index : this.input.length;
      if (this.pos < end_script) {
        content2 = this.input.substring(this.pos, end_script);
        this.pos = end_script;
      }
      return content2;
    };
    this.record_tag = function(tag) {
      if (this.tags[tag + "count"]) {
        this.tags[tag + "count"]++;
        this.tags[tag + this.tags[tag + "count"]] = this.indent_level;
      } else {
        this.tags[tag + "count"] = 1;
        this.tags[tag + this.tags[tag + "count"]] = this.indent_level;
      }
      this.tags[tag + this.tags[tag + "count"] + "parent"] = this.tags.parent;
      this.tags.parent = tag + this.tags[tag + "count"];
    };
    this.retrieve_tag = function(tag) {
      if (this.tags[tag + "count"]) {
        var temp_parent = this.tags.parent;
        while (temp_parent) {
          if (tag + this.tags[tag + "count"] === temp_parent) {
            break;
          }
          temp_parent = this.tags[temp_parent + "parent"];
        }
        if (temp_parent) {
          this.indent_level = this.tags[tag + this.tags[tag + "count"]];
          this.tags.parent = this.tags[temp_parent + "parent"];
        }
        delete this.tags[tag + this.tags[tag + "count"] + "parent"];
        delete this.tags[tag + this.tags[tag + "count"]];
        if (this.tags[tag + "count"] == 1) {
          delete this.tags[tag + "count"];
        } else {
          this.tags[tag + "count"]--;
        }
      }
    };
    this.get_tag = function() {
      var input_char = "", content2 = [], space2 = false, tag_start, tag_end;
      do {
        if (this.pos >= this.input.length) {
          return content2.length ? content2.join("") : ["", "TK_EOF"];
        }
        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;
        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          space2 = true;
          this.line_char_count--;
          continue;
        }
        if (input_char === "'" || input_char === '"') {
          if (!content2[1] || content2[1] !== "!") {
            input_char += this.get_unformatted(input_char);
            space2 = true;
          }
        }
        if (input_char === "=") {
          space2 = false;
        }
        if (content2.length && content2[content2.length - 1] !== "=" && input_char !== ">" && space2) {
          if (this.line_char_count >= this.max_char) {
            this.print_newline(false, content2);
            this.line_char_count = 0;
          } else {
            content2.push(" ");
            this.line_char_count++;
          }
          space2 = false;
        }
        if (input_char === "<") {
          tag_start = this.pos - 1;
        }
        content2.push(input_char);
      } while (input_char !== ">");
      var tag_complete = content2.join("");
      var tag_index;
      if (tag_complete.indexOf(" ") != -1) {
        tag_index = tag_complete.indexOf(" ");
      } else {
        tag_index = tag_complete.indexOf(">");
      }
      var tag_check2 = tag_complete.substring(1, tag_index).toLowerCase();
      if (tag_complete.charAt(tag_complete.length - 2) === "/" || this.Utils.in_array(tag_check2, this.Utils.single_token)) {
        this.tag_type = "SINGLE";
      } else if (tag_check2 === "script") {
        this.record_tag(tag_check2);
        this.tag_type = "SCRIPT";
      } else if (tag_check2 === "style") {
        this.record_tag(tag_check2);
        this.tag_type = "STYLE";
      } else if (this.Utils.in_array(tag_check2, unformatted)) {
        var comment2 = this.get_unformatted("</" + tag_check2 + ">", tag_complete);
        content2.push(comment2);
        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)) {
          content2.splice(0, 0, this.input.charAt(tag_start - 1));
        }
        tag_end = this.pos - 1;
        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)) {
          content2.push(this.input.charAt(tag_end + 1));
        }
        this.tag_type = "SINGLE";
      } else if (tag_check2.charAt(0) === "!") {
        if (tag_check2.indexOf("[if") != -1) {
          if (tag_complete.indexOf("!IE") != -1) {
            var comment2 = this.get_unformatted("-->", tag_complete);
            content2.push(comment2);
          }
          this.tag_type = "START";
        } else if (tag_check2.indexOf("[endif") != -1) {
          this.tag_type = "END";
          this.unindent();
        } else if (tag_check2.indexOf("[cdata[") != -1) {
          var comment2 = this.get_unformatted("]]>", tag_complete);
          content2.push(comment2);
          this.tag_type = "SINGLE";
        } else {
          var comment2 = this.get_unformatted("-->", tag_complete);
          content2.push(comment2);
          this.tag_type = "SINGLE";
        }
      } else {
        if (tag_check2.charAt(0) === "/") {
          this.retrieve_tag(tag_check2.substring(1));
          this.tag_type = "END";
        } else {
          this.record_tag(tag_check2);
          this.tag_type = "START";
        }
        if (this.Utils.in_array(tag_check2, this.Utils.extra_liners)) {
          this.print_newline(true, this.output);
        }
      }
      return content2.join("");
    };
    this.get_unformatted = function(delimiter2, orig_tag) {
      if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter2) != -1) {
        return "";
      }
      var input_char = "";
      var content2 = "";
      var space2 = true;
      do {
        if (this.pos >= this.input.length) {
          return content2;
        }
        input_char = this.input.charAt(this.pos);
        this.pos++;
        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (!space2) {
            this.line_char_count--;
            continue;
          }
          if (input_char === "\n" || input_char === "\r") {
            content2 += "\n";
            this.line_char_count = 0;
            continue;
          }
        }
        content2 += input_char;
        this.line_char_count++;
        space2 = true;
      } while (content2.toLowerCase().indexOf(delimiter2) == -1);
      return content2;
    };
    this.get_token = function() {
      var token2;
      if (this.last_token === "TK_TAG_SCRIPT" || this.last_token === "TK_TAG_STYLE") {
        var type = this.last_token.substr(7);
        token2 = this.get_contents_to(type);
        if (typeof token2 !== "string") {
          return token2;
        }
        return [token2, "TK_" + type];
      }
      if (this.current_mode === "CONTENT") {
        token2 = this.get_content();
        if (typeof token2 !== "string") {
          return token2;
        } else {
          return [token2, "TK_CONTENT"];
        }
      }
      if (this.current_mode === "TAG") {
        token2 = this.get_tag();
        if (typeof token2 !== "string") {
          return token2;
        } else {
          var tag_name_type = "TK_TAG_" + this.tag_type;
          return [token2, tag_name_type];
        }
      }
    };
    this.get_full_indent = function(level) {
      level = this.indent_level + level || 0;
      if (level < 1)
        return "";
      return Array(level + 1).join(this.indent_string);
    };
    this.printer = function(js_source, indent_character2, indent_size2, max_char2, brace_style2) {
      this.input = js_source || "";
      this.output = [];
      this.indent_character = indent_character2;
      this.indent_string = "";
      this.indent_size = indent_size2;
      this.brace_style = brace_style2;
      this.indent_level = 0;
      this.max_char = max_char2;
      this.line_char_count = 0;
      for (var i = 0; i < this.indent_size; i++) {
        this.indent_string += this.indent_character;
      }
      this.print_newline = function(ignore, arr) {
        this.line_char_count = 0;
        if (!arr || !arr.length) {
          return;
        }
        if (!ignore) {
          while (this.Utils.in_array(arr[arr.length - 1], this.Utils.whitespace)) {
            arr.pop();
          }
        }
        arr.push("\n");
        for (var i2 = 0; i2 < this.indent_level; i2++) {
          arr.push(this.indent_string);
        }
      };
      this.print_token = function(text9) {
        this.output.push(text9);
      };
      this.indent = function() {
        this.indent_level++;
      };
      this.unindent = function() {
        if (this.indent_level > 0) {
          this.indent_level--;
        }
      };
    };
    return this;
  }
  multi_parser = new Parser();
  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style);
  while (true) {
    var t2 = multi_parser.get_token();
    multi_parser.token_text = t2[0];
    multi_parser.token_type = t2[1];
    if (multi_parser.token_type === "TK_EOF") {
      break;
    }
    switch (multi_parser.token_type) {
      case "TK_TAG_START":
        multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.indent();
        multi_parser.current_mode = "CONTENT";
        break;
      case "TK_TAG_STYLE":
      case "TK_TAG_SCRIPT":
        multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = "CONTENT";
        break;
      case "TK_TAG_END":
        if (multi_parser.last_token === "TK_CONTENT" && multi_parser.last_text === "") {
          var tag_name = multi_parser.token_text.match(/\w+/)[0];
          var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/<\s*(\w+)/);
          if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name)
            multi_parser.print_newline(true, multi_parser.output);
        }
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = "CONTENT";
        break;
      case "TK_TAG_SINGLE":
        var tag_check = multi_parser.token_text.match(/^\s*<([a-z]+)/i);
        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
          multi_parser.print_newline(false, multi_parser.output);
        }
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = "CONTENT";
        break;
      case "TK_CONTENT":
        if (multi_parser.token_text !== "") {
          multi_parser.print_token(multi_parser.token_text);
        }
        multi_parser.current_mode = "TAG";
        break;
      case "TK_STYLE":
      case "TK_SCRIPT":
        if (multi_parser.token_text !== "") {
          multi_parser.output.push("\n");
          var text8 = multi_parser.token_text;
          if (multi_parser.token_type == "TK_SCRIPT") {
            var _beautifier = typeof js_beautify == "function" && js_beautify;
          } else if (multi_parser.token_type == "TK_STYLE") {
            var _beautifier = typeof css_beautify == "function" && css_beautify;
          }
          if (options.indent_scripts == "keep") {
            var script_indent_level = 0;
          } else if (options.indent_scripts == "separate") {
            var script_indent_level = -multi_parser.indent_level;
          } else {
            var script_indent_level = 1;
          }
          var indentation = multi_parser.get_full_indent(script_indent_level);
          if (_beautifier) {
            text8 = _beautifier(text8.replace(/^\s*/, indentation), options);
          } else {
            var white = text8.match(/^\s*/)[0];
            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
            text8 = text8.replace(/^\s*/, indentation).replace(/\r\n|\r|\n/g, "\n" + reindent).replace(/\s*$/, "");
          }
          if (text8) {
            multi_parser.print_token(text8);
            multi_parser.print_newline(true, multi_parser.output);
          }
        }
        multi_parser.current_mode = "TAG";
        break;
    }
    multi_parser.last_token = multi_parser.token_type;
    multi_parser.last_text = multi_parser.token_text;
  }
  return multi_parser.output.join("");
}
var html = {
  prettyPrint: style_html
};
var crypto = self.crypto || self.msCrypto;
var url = "-_";
var i$1 = 36;
while (i$1--) {
  url += i$1.toString(36);
}
i$1 = 36;
while (i$1-- - 10) {
  url += i$1.toString(36).toUpperCase();
}
var index_browser = function(size) {
  var id2 = "";
  var bytes = crypto.getRandomValues(new Uint8Array(size || 21));
  i$1 = size || 21;
  while (i$1--) {
    id2 += url[bytes[i$1] & 63];
  }
  return id2;
};
var nanoid = index_browser;
function subscribeOnUpdates(editorView, callback) {
  var dispatch3 = (editorView._props.dispatchTransaction || editorView.dispatch).bind(editorView);
  var handler = function handler2(tr) {
    var oldState = editorView.state;
    dispatch3(tr);
    callback(tr, oldState, editorView.state);
  };
  if (editorView._props.dispatchTransaction) {
    editorView._props.dispatchTransaction = handler;
  } else {
    editorView.dispatch = handler;
  }
}
function findNode(fullPath, currentNode, nodeToFind) {
  if (nodeToFind === currentNode) {
    return fullPath;
  }
  if (!currentNode.content || !currentNode.content.content)
    return null;
  var res = currentNode.content.content.map(function(currentNode2, i) {
    return findNode([].concat(fullPath, "content", i), currentNode2, nodeToFind);
  }).filter(function(res2) {
    return Array.isArray(res2) && res2.length;
  })[0];
  return res;
}
function findNodeIn(doc2, node18) {
  var path = findNode([], doc2, node18);
  if (path) {
    return path.reduce(function(newPath, item) {
      if (item === "content" && newPath[newPath.length - 1] === "content") {
        return newPath;
      }
      newPath.push(item);
      return newPath;
    }, []);
  }
}
function findNodeJSON(fullPath, currentNode, nodeToFind) {
  if (nodeToFind === currentNode) {
    return fullPath;
  }
  if (!currentNode.content)
    return null;
  if (currentNode.content === nodeToFind) {
    return fullPath.concat("content");
  }
  var res = currentNode.content.map(function(currentNode2, i) {
    return findNodeJSON([].concat(fullPath, "content", i), currentNode2, nodeToFind);
  }).filter(function(res2) {
    return Array.isArray(res2) && res2.length;
  })[0];
  return res;
}
function findNodeInJSON(doc2, node18) {
  var path = findNodeJSON([], doc2, node18);
  if (path) {
    return path.reduce(function(newPath, item) {
      newPath.push(item);
      if (item === "content") {
        newPath.push("content");
      }
      return newPath;
    }, []);
  }
}
var dist = {};
function OrderedMap$1(content2) {
  this.content = content2;
}
OrderedMap$1.prototype = {
  constructor: OrderedMap$1,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content2 = self2.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap$1(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap$1(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap$1([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap$1(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap$1(content2);
  },
  forEach: function(f2) {
    for (var i = 0; i < this.content.length; i += 2)
      f2(this.content[i], this.content[i + 1]);
  },
  prepend: function(map19) {
    map19 = OrderedMap$1.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$1(map19.content.concat(this.subtract(map19).content));
  },
  append: function(map19) {
    map19 = OrderedMap$1.from(map19);
    if (!map19.size)
      return this;
    return new OrderedMap$1(this.subtract(map19).content.concat(map19.content));
  },
  subtract: function(map19) {
    var result2 = this;
    map19 = OrderedMap$1.from(map19);
    for (var i = 0; i < map19.content.length; i += 2)
      result2 = result2.remove(map19.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap$1.from = function(value) {
  if (value instanceof OrderedMap$1)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap$1(content2);
};
var orderedmap = OrderedMap$1;
Object.defineProperty(dist, "__esModule", { value: true });
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var OrderedMap = _interopDefault(orderedmap);
function findDiffStart(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment7 = function Fragment8(content2, size) {
  var this$1$1 = this;
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content2.length; i++) {
      this$1$1.size += content2[i].nodeSize;
    }
  }
};
var prototypeAccessors$1 = { firstChild: {}, lastChild: {}, childCount: {} };
Fragment7.prototype.nodesBetween = function nodesBetween13(from12, to, f2, nodeStart, parent) {
  var this$1$1 = this;
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
    if (end8 > from12 && f2(child15, nodeStart + pos, parent, i) !== false && child15.content.size) {
      var start16 = pos + 1;
      child15.nodesBetween(
        Math.max(0, from12 - start16),
        Math.min(child15.content.size, to - start16),
        f2,
        nodeStart + start16
      );
    }
    pos = end8;
  }
};
Fragment7.prototype.descendants = function descendants13(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment7.prototype.textBetween = function textBetween13(from12, to, blockSeparator, leafText) {
  var text8 = "", separated = true;
  this.nodesBetween(from12, to, function(node18, pos) {
    if (node18.isText) {
      text8 += node18.text.slice(Math.max(from12, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node18.isLeaf && leafText) {
      text8 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node18.isBlock) {
      text8 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text8;
};
Fragment7.prototype.append = function append9(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content2[content2.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content2.push(other.content[i]);
  }
  return new Fragment7(content2, this.size + other.size);
};
Fragment7.prototype.cut = function cut13(from12, to) {
  var this$1$1 = this;
  if (to == null) {
    to = this.size;
  }
  if (from12 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from12) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child15 = this$1$1.content[i], end8 = pos + child15.nodeSize;
      if (end8 > from12) {
        if (pos < from12 || end8 > to) {
          if (child15.isText) {
            child15 = child15.cut(Math.max(0, from12 - pos), Math.min(child15.text.length, to - pos));
          } else {
            child15 = child15.cut(Math.max(0, from12 - pos - 1), Math.min(child15.content.size, to - pos - 1));
          }
        }
        result2.push(child15);
        size += child15.nodeSize;
      }
      pos = end8;
    }
  }
  return new Fragment7(result2, size);
};
Fragment7.prototype.cutByIndex = function cutByIndex7(from12, to) {
  if (from12 == to) {
    return Fragment7.empty;
  }
  if (from12 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment7(this.content.slice(from12, to));
};
Fragment7.prototype.replaceChild = function replaceChild7(index8, node18) {
  var current = this.content[index8];
  if (current == node18) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node18.nodeSize - current.nodeSize;
  copy12[index8] = node18;
  return new Fragment7(copy12, size);
};
Fragment7.prototype.addToStart = function addToStart7(node18) {
  return new Fragment7([node18].concat(this.content), this.size + node18.nodeSize);
};
Fragment7.prototype.addToEnd = function addToEnd7(node18) {
  return new Fragment7(this.content.concat(node18), this.size + node18.nodeSize);
};
Fragment7.prototype.eq = function eq37(other) {
  var this$1$1 = this;
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this$1$1.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$1.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$1.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$1.childCount.get = function() {
  return this.content.length;
};
Fragment7.prototype.child = function child13(index8) {
  var found2 = this.content[index8];
  if (!found2) {
    throw new RangeError("Index " + index8 + " out of range for " + this);
  }
  return found2;
};
Fragment7.prototype.maybeChild = function maybeChild13(index8) {
  return this.content[index8];
};
Fragment7.prototype.forEach = function forEach15(f2) {
  var this$1$1 = this;
  for (var i = 0, p2 = 0; i < this.content.length; i++) {
    var child15 = this$1$1.content[i];
    f2(child15, p2, i);
    p2 += child15.nodeSize;
  }
};
Fragment7.prototype.findDiffStart = function findDiffStart$17(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart(this, other, pos);
};
Fragment7.prototype.findDiffEnd = function findDiffEnd$17(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd(this, other, pos, otherPos);
};
Fragment7.prototype.findIndex = function findIndex7(pos, round) {
  var this$1$1 = this;
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex(0, pos);
  }
  if (pos == this.size) {
    return retIndex(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this$1$1.child(i), end8 = curPos + cur.nodeSize;
    if (end8 >= pos) {
      if (end8 == pos || round > 0) {
        return retIndex(i + 1, end8);
      }
      return retIndex(i, curPos);
    }
    curPos = end8;
  }
};
Fragment7.prototype.toString = function toString32() {
  return "<" + this.toStringInner() + ">";
};
Fragment7.prototype.toStringInner = function toStringInner7() {
  return this.content.join(", ");
};
Fragment7.prototype.toJSON = function toJSON27() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment7.fromJSON = function fromJSON28(schema2, value) {
  if (!value) {
    return Fragment7.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment7(value.map(schema2.nodeFromJSON));
};
Fragment7.fromArray = function fromArray7(array) {
  if (!array.length) {
    return Fragment7.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node18 = array[i];
    size += node18.nodeSize;
    if (i && node18.isText && array[i - 1].sameMarkup(node18)) {
      if (!joined) {
        joined = array.slice(0, i);
      }
      joined[joined.length - 1] = node18.withText(joined[joined.length - 1].text + node18.text);
    } else if (joined) {
      joined.push(node18);
    }
  }
  return new Fragment7(joined || array, size);
};
Fragment7.from = function from11(nodes2) {
  if (!nodes2) {
    return Fragment7.empty;
  }
  if (nodes2 instanceof Fragment7) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  return new Fragment7([nodes2], nodes2.nodeSize);
};
Object.defineProperties(Fragment7.prototype, prototypeAccessors$1);
var found = { index: 0, offset: 0 };
function retIndex(index8, offset2) {
  found.index = index8;
  found.offset = offset2;
  return found;
}
Fragment7.empty = new Fragment7([], 0);
function compareDeep(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p2 in a) {
      if (!(p2 in b) || !compareDeep(a[p2], b[p2])) {
        return false;
      }
    }
    for (var p$12 in b) {
      if (!(p$12 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark7 = function Mark8(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark7.prototype.addToSet = function addToSet7(set) {
  var this$1$1 = this;
  var copy12, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this$1$1.eq(other)) {
      return set;
    }
    if (this$1$1.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set.slice(0, i);
      }
    } else if (other.type.excludes(this$1$1.type)) {
      return set;
    } else {
      if (!placed && other.type.rank > this$1$1.type.rank) {
        if (!copy12) {
          copy12 = set.slice(0, i);
        }
        copy12.push(this$1$1);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark7.prototype.removeFromSet = function removeFromSet13(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
Mark7.prototype.isInSet = function isInSet13(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (this$1$1.eq(set[i])) {
      return true;
    }
  }
  return false;
};
Mark7.prototype.eq = function eq38(other) {
  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
};
Mark7.prototype.toJSON = function toJSON28() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  return obj;
};
Mark7.fromJSON = function fromJSON29(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark7.sameSet = function sameSet7(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark7.setFrom = function setFrom7(marks9) {
  if (!marks9 || marks9.length == 0) {
    return Mark7.none;
  }
  if (marks9 instanceof Mark7) {
    return [marks9];
  }
  var copy12 = marks9.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark7.none = [];
function ReplaceError(message) {
  var err8 = Error.call(this, message);
  err8.__proto__ = ReplaceError.prototype;
  return err8;
}
ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";
var Slice7 = function Slice8(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$2 = { size: {} };
prototypeAccessors$2.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice7.prototype.insertAt = function insertAt7(pos, fragment) {
  var content2 = insertInto(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice7(content2, this.openStart, this.openEnd);
};
Slice7.prototype.removeBetween = function removeBetween7(from12, to) {
  return new Slice7(removeRange(this.content, from12 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice7.prototype.eq = function eq39(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice7.prototype.toString = function toString33() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice7.prototype.toJSON = function toJSON29() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice7.fromJSON = function fromJSON30(schema2, json) {
  if (!json) {
    return Slice7.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice7(Fragment7.fromJSON(schema2, json.content), json.openStart || 0, json.openEnd || 0);
};
Slice7.maxOpen = function maxOpen7(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice7(fragment, openStart, openEnd);
};
Object.defineProperties(Slice7.prototype, prototypeAccessors$2);
function removeRange(content2, from12, to) {
  var ref = content2.findIndex(from12);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from12 || child15.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from12).append(content2.cut(to));
  }
  if (index8 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index8, child15.copy(removeRange(child15.content, from12 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content2, dist2, insert, parent) {
  var ref = content2.findIndex(dist2);
  var index8 = ref.index;
  var offset2 = ref.offset;
  var child15 = content2.maybeChild(index8);
  if (offset2 == dist2 || child15.isText) {
    if (parent && !parent.canReplace(index8, index8, insert)) {
      return null;
    }
    return content2.cut(0, dist2).append(insert).append(content2.cut(dist2));
  }
  var inner = insertInto(child15.content, dist2 - offset2 - 1, insert);
  return inner && content2.replaceChild(index8, child15.copy(inner));
}
Slice7.empty = new Slice7(Fragment7.empty, 0, 0);
function replace2($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice11, 0);
}
function replaceOuter($from, $to, slice11, depth) {
  var index8 = $from.index(depth), node18 = $from.node(depth);
  if (index8 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter($from, $to, slice11, depth + 1);
    return node18.copy(node18.content.replaceChild(index8, inner));
  } else if (!slice11.content.size) {
    return close(node18, replaceTwoWay($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close(parent, content2.cut(0, $from.parentOffset).append(slice11.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace(slice11, $from);
    var start16 = ref.start;
    var end8 = ref.end;
    return close(node18, replaceThreeWay($from, start16, end8, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable($before, $after, depth) {
  var node18 = $before.node(depth);
  checkJoin(node18, $after.node(depth));
  return node18;
}
function addNode4(child15, target) {
  var last = target.length - 1;
  if (last >= 0 && child15.isText && child15.sameMarkup(target[last])) {
    target[last] = child15.withText(target[last].text + child15.text);
  } else {
    target.push(child15);
  }
}
function addRange3($start, $end, depth, target) {
  var node18 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node18.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode4($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode4(node18.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode4($end.nodeBefore, target);
  }
}
function close(node18, content2) {
  if (!node18.type.validContent(content2)) {
    throw new ReplaceError("Invalid content for node " + node18.type.name);
  }
  return node18.copy(content2);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content2 = [];
  addRange3(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode4(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode4(close(openStart, replaceTwoWay($from, $start, depth + 1)), content2);
    }
    addRange3($start, $end, depth, content2);
    if (openEnd) {
      addNode4(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content2);
    }
  }
  addRange3($to, null, depth, content2);
  return new Fragment7(content2);
}
function replaceTwoWay($from, $to, depth) {
  var content2 = [];
  addRange3(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode4(close(type, replaceTwoWay($from, $to, depth + 1)), content2);
  }
  addRange3($to, null, depth, content2);
  return new Fragment7(content2);
}
function prepareSliceForReplace(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node18 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node18 = $along.node(i).copy(Fragment7.from(node18));
  }
  return {
    start: node18.resolveNoCache(slice11.openStart + extra),
    end: node18.resolveNoCache(node18.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos7 = function ResolvedPos8(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$3 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };
ResolvedPos7.prototype.resolveDepth = function resolveDepth7(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$3.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$3.doc.get = function() {
  return this.node(0);
};
ResolvedPos7.prototype.node = function node15(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos7.prototype.index = function index7(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos7.prototype.indexAfter = function indexAfter7(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos7.prototype.start = function start15(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos7.prototype.end = function end7(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos7.prototype.before = function before7(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos7.prototype.after = function after7(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$3.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$3.nodeAfter.get = function() {
  var parent = this.parent, index8 = this.index(this.depth);
  if (index8 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child15 = parent.child(index8);
  return dOff ? parent.child(index8).cut(dOff) : child15;
};
prototypeAccessors$3.nodeBefore.get = function() {
  var index8 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index8).cut(0, dOff);
  }
  return index8 == 0 ? null : this.parent.child(index8 - 1);
};
ResolvedPos7.prototype.marks = function marks8() {
  var parent = this.parent, index8 = this.index();
  if (parent.content.size == 0) {
    return Mark7.none;
  }
  if (this.textOffset) {
    return parent.child(index8).marks;
  }
  var main = parent.maybeChild(index8 - 1), other = parent.maybeChild(index8);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks9 = main.marks;
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!other || !marks9[i].isInSet(other.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos7.prototype.marksAcross = function marksAcross7($end) {
  var after8 = this.parent.maybeChild(this.index());
  if (!after8 || !after8.isInline) {
    return null;
  }
  var marks9 = after8.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks9.length; i++) {
    if (marks9[i].type.spec.inclusive === false && (!next2 || !marks9[i].isInSet(next2.marks))) {
      marks9 = marks9[i--].removeFromSet(marks9);
    }
  }
  return marks9;
};
ResolvedPos7.prototype.sharedDepth = function sharedDepth7(pos) {
  var this$1$1 = this;
  for (var depth = this.depth; depth > 0; depth--) {
    if (this$1$1.start(depth) <= pos && this$1$1.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos7.prototype.blockRange = function blockRange7(other, pred) {
  var this$1$1 = this;
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this$1$1.end(d) && (!pred || pred(this$1$1.node(d)))) {
      return new NodeRange7(this$1$1, other, d);
    }
  }
};
ResolvedPos7.prototype.sameParent = function sameParent7(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos7.prototype.max = function max7(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos7.prototype.min = function min7(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos7.prototype.toString = function toString34() {
  var this$1$1 = this;
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this$1$1.node(i).type.name + "_" + this$1$1.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos7.resolve = function resolve17(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start16 = 0, parentOffset = pos;
  for (var node18 = doc2; ; ) {
    var ref = node18.content.findIndex(parentOffset);
    var index8 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path.push(node18, index8, start16 + offset2);
    if (!rem) {
      break;
    }
    node18 = node18.child(index8);
    if (node18.isText) {
      break;
    }
    parentOffset = rem - 1;
    start16 += offset2 + 1;
  }
  return new ResolvedPos7(pos, path, parentOffset);
};
ResolvedPos7.resolveCached = function resolveCached7(doc2, pos) {
  for (var i = 0; i < resolveCache.length; i++) {
    var cached = resolveCache[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache[resolveCachePos] = ResolvedPos7.resolve(doc2, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result2;
};
Object.defineProperties(ResolvedPos7.prototype, prototypeAccessors$3);
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange7 = function NodeRange8($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };
prototypeAccessors$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange7.prototype, prototypeAccessors$1$1);
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node$1 = function Node8(type, attrs, content2, marks9) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment7.empty;
  this.marks = marks9 || Mark7.none;
};
var prototypeAccessors = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors.childCount.get = function() {
  return this.content.childCount;
};
Node$1.prototype.child = function child14(index8) {
  return this.content.child(index8);
};
Node$1.prototype.maybeChild = function maybeChild14(index8) {
  return this.content.maybeChild(index8);
};
Node$1.prototype.forEach = function forEach16(f2) {
  this.content.forEach(f2);
};
Node$1.prototype.nodesBetween = function nodesBetween14(from12, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from12, to, f2, startPos, this);
};
Node$1.prototype.descendants = function descendants14(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$1.prototype.textBetween = function textBetween14(from12, to, blockSeparator, leafText) {
  return this.content.textBetween(from12, to, blockSeparator, leafText);
};
prototypeAccessors.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors.lastChild.get = function() {
  return this.content.lastChild;
};
Node$1.prototype.eq = function eq40(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$1.prototype.sameMarkup = function sameMarkup7(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$1.prototype.hasMarkup = function hasMarkup7(type, attrs, marks9) {
  return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark7.sameSet(this.marks, marks9 || Mark7.none);
};
Node$1.prototype.copy = function copy10(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$1.prototype.mark = function mark13(marks9) {
  return marks9 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks9);
};
Node$1.prototype.cut = function cut14(from12, to) {
  if (from12 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from12, to));
};
Node$1.prototype.slice = function slice10(from12, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from12 == to) {
    return Slice7.empty;
  }
  var $from = this.resolve(from12), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start16 = $from.start(depth), node18 = $from.node(depth);
  var content2 = node18.content.cut($from.pos - start16, $to.pos - start16);
  return new Slice7(content2, $from.depth - depth, $to.depth - depth);
};
Node$1.prototype.replace = function replace$18(from12, to, slice11) {
  return replace2(this.resolve(from12), this.resolve(to), slice11);
};
Node$1.prototype.nodeAt = function nodeAt7(pos) {
  for (var node18 = this; ; ) {
    var ref = node18.content.findIndex(pos);
    var index8 = ref.index;
    var offset2 = ref.offset;
    node18 = node18.maybeChild(index8);
    if (!node18) {
      return null;
    }
    if (offset2 == pos || node18.isText) {
      return node18;
    }
    pos -= offset2 + 1;
  }
};
Node$1.prototype.childAfter = function childAfter7(pos) {
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index8), index: index8, offset: offset2 };
};
Node$1.prototype.childBefore = function childBefore7(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index8 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index8), index: index8, offset: offset2 };
  }
  var node18 = this.content.child(index8 - 1);
  return { node: node18, index: index8 - 1, offset: offset2 - node18.nodeSize };
};
Node$1.prototype.resolve = function resolve18(pos) {
  return ResolvedPos7.resolveCached(this, pos);
};
Node$1.prototype.resolveNoCache = function resolveNoCache7(pos) {
  return ResolvedPos7.resolve(this, pos);
};
Node$1.prototype.rangeHasMark = function rangeHasMark7(from12, to, type) {
  var found2 = false;
  if (to > from12) {
    this.nodesBetween(from12, to, function(node18) {
      if (type.isInSet(node18.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors.isAtom.get = function() {
  return this.type.isAtom;
};
Node$1.prototype.toString = function toString35() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks(this.marks, name);
};
Node$1.prototype.contentMatchAt = function contentMatchAt7(index8) {
  return this.type.contentMatch.matchFragment(this.content, 0, index8);
};
Node$1.prototype.canReplace = function canReplace7(from12, to, replacement, start16, end8) {
  var this$1$1 = this;
  if (replacement === void 0)
    replacement = Fragment7.empty;
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = replacement.childCount;
  var one = this.contentMatchAt(from12).matchFragment(replacement, start16, end8);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start16; i < end8; i++) {
    if (!this$1$1.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$1.prototype.canReplaceWith = function canReplaceWith7(from12, to, type, marks9) {
  if (marks9 && !this.type.allowsMarks(marks9)) {
    return false;
  }
  var start16 = this.contentMatchAt(from12).matchType(type);
  var end8 = start16 && start16.matchFragment(this.content, to);
  return end8 ? end8.validEnd : false;
};
Node$1.prototype.canAppend = function canAppend7(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$1.prototype.defaultContentType = function defaultContentType7(at) {
  return this.contentMatchAt(at).defaultType;
};
Node$1.prototype.check = function check7() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  this.content.forEach(function(node18) {
    return node18.check();
  });
};
Node$1.prototype.toJSON = function toJSON30() {
  var this$1$1 = this;
  var obj = { type: this.type.name };
  for (var _ in this$1$1.attrs) {
    obj.attrs = this$1$1.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$1.fromJSON = function fromJSON31(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks9 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks9 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks9);
  }
  var content2 = Fragment7.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content2, marks9);
};
Object.defineProperties(Node$1.prototype, prototypeAccessors);
var TextNode = function(Node9) {
  function TextNode2(type, attrs, content2, marks9) {
    Node9.call(this, type, attrs, null, marks9);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node9)
    TextNode2.__proto__ = Node9;
  TextNode2.prototype = Object.create(Node9 && Node9.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: {}, nodeSize: {} };
  TextNode2.prototype.toString = function toString38() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween16(from12, to) {
    return this.text.slice(from12, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark15(marks9) {
    return marks9 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks9);
  };
  TextNode2.prototype.withText = function withText(text8) {
    if (text8 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text8, this.marks);
  };
  TextNode2.prototype.cut = function cut15(from12, to) {
    if (from12 === void 0)
      from12 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from12 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from12, to));
  };
  TextNode2.prototype.eq = function eq41(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON31() {
    var base2 = Node9.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$1);
function wrapMarks(marks9, str) {
  for (var i = marks9.length - 1; i >= 0; i--) {
    str = marks9[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch7 = function ContentMatch8(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$5 = { inlineContent: {}, defaultType: {}, edgeCount: {} };
ContentMatch7.parse = function parse13(string, nodeTypes) {
  var stream = new TokenStream7(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch7.empty;
  }
  var expr = parseExpr(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa(nfa(expr));
  checkForDeadEnds(match2, stream);
  return match2;
};
ContentMatch7.prototype.matchType = function matchType7(type) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    if (this$1$1.next[i] == type) {
      return this$1$1.next[i + 1];
    }
  }
  return null;
};
ContentMatch7.prototype.matchFragment = function matchFragment7(frag, start16, end8) {
  if (start16 === void 0)
    start16 = 0;
  if (end8 === void 0)
    end8 = frag.childCount;
  var cur = this;
  for (var i = start16; cur && i < end8; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$5.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$5.defaultType.get = function() {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this$1$1.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch7.prototype.compatible = function compatible7(other) {
  var this$1$1 = this;
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this$1$1.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch7.prototype.fillBefore = function fillBefore7(after8, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after8, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment7.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i], next2 = match2.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch7.prototype.findWrapping = function findWrapping14(target) {
  var this$1$1 = this;
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this$1$1.wrapCache[i] == target) {
      return this$1$1.wrapCache[i + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch7.prototype.computeWrapping = function computeWrapping7(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match2.next.length; i += 2) {
      var type = match2.next[i];
      if (!type.isLeaf && !(type.name in seen) && (!current.type || match2.next[i + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$5.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch7.prototype.edge = function edge7(n2) {
  var i = n2 << 1;
  if (i > this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch7.prototype.toString = function toString36() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i = 1; i < m2.next.length; i += 2) {
      if (seen.indexOf(m2.next[i]) == -1) {
        scan(m2.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i) {
    var out = i + (m2.validEnd ? "*" : " ") + " ";
    for (var i$12 = 0; i$12 < m2.next.length; i$12 += 2) {
      out += (i$12 ? ", " : "") + m2.next[i$12].name + "->" + seen.indexOf(m2.next[i$12 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch7.prototype, prototypeAccessors$5);
ContentMatch7.empty = new ContentMatch7(true);
var TokenStream7 = function TokenStream8(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.unshift();
  }
};
var prototypeAccessors$1$3 = { next: {} };
prototypeAccessors$1$3.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream7.prototype.eat = function eat7(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream7.prototype.err = function err7(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream7.prototype, prototypeAccessors$1$3);
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min9 = parseNum(stream), max9 = min9;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max9 = parseNum(stream);
    } else {
      max9 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min9, max: max9, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile16(expr, 0), node18());
  return nfa2;
  function node18() {
    return nfa2.push([]) - 1;
  }
  function edge8(from12, to, term) {
    var edge9 = { term, to };
    nfa2[from12].push(edge9);
    return edge9;
  }
  function connect(edges, to) {
    edges.forEach(function(edge9) {
      return edge9.to = to;
    });
  }
  function compile16(expr2, from12) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile16(expr3, from12));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next2 = compile16(expr2.exprs[i], from12);
        if (i == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from12 = node18());
      }
    } else if (expr2.type == "star") {
      var loop = node18();
      edge8(from12, loop);
      connect(compile16(expr2.expr, loop), loop);
      return [edge8(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node18();
      connect(compile16(expr2.expr, from12), loop$1);
      connect(compile16(expr2.expr, loop$1), loop$1);
      return [edge8(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge8(from12)].concat(compile16(expr2.expr, from12));
    } else if (expr2.type == "range") {
      var cur = from12;
      for (var i$12 = 0; i$12 < expr2.min; i$12++) {
        var next$1 = node18();
        connect(compile16(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile16(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node18();
          edge8(cur, next$2);
          connect(compile16(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge8(cur)];
    } else if (expr2.type == "name") {
      return [edge8(from12, null, expr2.value)];
    }
  }
}
function cmp(a, b) {
  return a - b;
}
function nullFrom(nfa2, node18) {
  var result2 = [];
  scan(node18);
  return result2.sort(cmp);
  function scan(node19) {
    var edges = nfa2[node19];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node19);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node18) {
      nfa2[node18].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom(nfa2, to).forEach(function(node19) {
          if (!set) {
            out.push(term, set = []);
          }
          if (set.indexOf(node19) == -1) {
            set.push(node19);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch7(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match2, stream) {
  for (var i = 0, work = [match2]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes2 = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node18 = state.next[j], next2 = state.next[j + 1];
      nodes2.push(node18.name);
      if (dead && !(node18.isText || node18.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute7(attrs[name]);
    }
  }
  return result2;
}
var NodeType9 = function NodeType10(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);
  this.defaultAttrs = defaultAttrs(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$4 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };
prototypeAccessors$4.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$4.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$4.isLeaf.get = function() {
  return this.contentMatch == ContentMatch7.empty;
};
prototypeAccessors$4.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType9.prototype.hasRequiredAttrs = function hasRequiredAttrs7(ignore) {
  var this$1$1 = this;
  for (var n2 in this$1$1.attrs) {
    if (this$1$1.attrs[n2].isRequired && (!ignore || !(n2 in ignore))) {
      return true;
    }
  }
  return false;
};
NodeType9.prototype.compatibleContent = function compatibleContent7(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType9.prototype.computeAttrs = function computeAttrs$17(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs(this.attrs, attrs);
  }
};
NodeType9.prototype.create = function create16(attrs, content2, marks9) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$1(this, this.computeAttrs(attrs), Fragment7.from(content2), Mark7.setFrom(marks9));
};
NodeType9.prototype.createChecked = function createChecked7(attrs, content2, marks9) {
  content2 = Fragment7.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$1(this, this.computeAttrs(attrs), content2, Mark7.setFrom(marks9));
};
NodeType9.prototype.createAndFill = function createAndFill7(attrs, content2, marks9) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment7.from(content2);
  if (content2.size) {
    var before8 = this.contentMatch.fillBefore(content2);
    if (!before8) {
      return null;
    }
    content2 = before8.append(content2);
  }
  var after8 = this.contentMatch.matchFragment(content2).fillBefore(Fragment7.empty, true);
  if (!after8) {
    return null;
  }
  return new Node$1(this, attrs, content2.append(after8), Mark7.setFrom(marks9));
};
NodeType9.prototype.validContent = function validContent7(content2) {
  var this$1$1 = this;
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content2.childCount; i++) {
    if (!this$1$1.allowsMarks(content2.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType9.prototype.allowsMarkType = function allowsMarkType7(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType9.prototype.allowsMarks = function allowsMarks7(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType9.prototype.allowedMarks = function allowedMarks7(marks9) {
  var this$1$1 = this;
  if (this.markSet == null) {
    return marks9;
  }
  var copy12;
  for (var i = 0; i < marks9.length; i++) {
    if (!this$1$1.allowsMarkType(marks9[i].type)) {
      if (!copy12) {
        copy12 = marks9.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks9[i]);
    }
  }
  return !copy12 ? marks9 : copy12.length ? copy12 : Mark7.empty;
};
NodeType9.compile = function compile14(nodes2, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType9(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType9.prototype, prototypeAccessors$4);
var Attribute7 = function Attribute8(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$2 = { isRequired: {} };
prototypeAccessors$1$2.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute7.prototype, prototypeAccessors$1$2);
var MarkType7 = function MarkType8(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark7(this, defaults);
};
MarkType7.prototype.create = function create17(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark7(this, computeAttrs(this.attrs, attrs));
};
MarkType7.compile = function compile15(marks9, schema2) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks9.forEach(function(name, spec) {
    return result2[name] = new MarkType7(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType7.prototype.removeFromSet = function removeFromSet14(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set.slice(0, i).concat(set.slice(i + 1));
    }
  }
  return set;
};
MarkType7.prototype.isInSet = function isInSet14(set) {
  var this$1$1 = this;
  for (var i = 0; i < set.length; i++) {
    if (set[i].type == this$1$1) {
      return set[i];
    }
  }
};
MarkType7.prototype.excludes = function excludes7(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema7 = function Schema8(spec) {
  var this$1$1 = this;
  this.spec = {};
  for (var prop in spec) {
    this$1$1.spec[prop] = spec[prop];
  }
  this.spec.nodes = OrderedMap.from(spec.nodes);
  this.spec.marks = OrderedMap.from(spec.marks);
  this.nodes = NodeType9.compile(this.spec.nodes, this);
  this.marks = MarkType7.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this$1$1.nodes) {
    if (prop$1 in this$1$1.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this$1$1.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch7.parse(contentExpr, this$1$1.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this$1$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this$1$1.marks) {
    var type$1 = this$1$1.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this$1$1, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema7.prototype.node = function node16(type, attrs, content2, marks9) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType9)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks9);
};
Schema7.prototype.text = function text7(text$1, marks9) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$1, Mark7.setFrom(marks9));
};
Schema7.prototype.mark = function mark14(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema7.prototype.nodeFromJSON = function nodeFromJSON7(json) {
  return Node$1.fromJSON(this, json);
};
Schema7.prototype.markFromJSON = function markFromJSON7(json) {
  return Mark7.fromJSON(this, json);
};
Schema7.prototype.nodeType = function nodeType7(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks(schema2, marks9) {
  var found2 = [];
  for (var i = 0; i < marks9.length; i++) {
    var name = marks9[i], mark15 = schema2.marks[name], ok3 = mark15;
    if (mark15) {
      found2.push(mark15);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks9[i] + "'");
    }
  }
  return found2;
}
var DOMParser7 = function DOMParser8(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
};
DOMParser7.prototype.parse = function parse14(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext7(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser7.prototype.parseSlice = function parseSlice7(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext7(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice7.maxOpen(context.finish());
};
DOMParser7.prototype.matchTag = function matchTag7(dom, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.tags.length; i++) {
    var rule = this$1$1.tags[i];
    if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser7.prototype.matchStyle = function matchStyle7(prop, value, context) {
  var this$1$1 = this;
  for (var i = 0; i < this.styles.length; i++) {
    var rule = this$1$1.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser7.schemaRules = function schemaRules7(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next2 = result2[i], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy11(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy11(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser7.fromSchema = function fromSchema13(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser7(schema2, DOMParser7.schemaRules(schema2)));
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
}
var NodeContext7 = function NodeContext8(type, attrs, marks9, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks9;
  this.activeMarks = Mark7.none;
};
NodeContext7.prototype.findWrapping = function findWrapping15(node18) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment7.from(node18));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start16 = this.type.contentMatch, wrap2;
      if (wrap2 = start16.findWrapping(node18.type)) {
        this.match = start16;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node18.type);
};
NodeContext7.prototype.finish = function finish15(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /\s+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment7.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment7.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
var ParseContext7 = function ParseContext8(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  this.pendingMarks = [];
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode) {
    topContext = new NodeContext7(
      topNode.type,
      topNode.attrs,
      Mark7.none,
      true,
      options.topMatch || topNode.type.contentMatch,
      topOptions
    );
  } else if (open) {
    topContext = new NodeContext7(null, null, Mark7.none, true, null, topOptions);
  } else {
    topContext = new NodeContext7(parser.schema.topNodeType, null, Mark7.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6 = { top: {}, currentPos: {} };
prototypeAccessors$6.top.get = function() {
  return this.nodes[this.open];
};
ParseContext7.prototype.addDOM = function addDOM7(dom) {
  var this$1$1 = this;
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks9 = style2 ? this.readStyles(parseStyles(style2)) : null;
    if (marks9 != null) {
      for (var i = 0; i < marks9.length; i++) {
        this$1$1.addPendingMark(marks9[i]);
      }
    }
    this.addElement(dom);
    if (marks9 != null) {
      for (var i$12 = 0; i$12 < marks9.length; i$12++) {
        this$1$1.removePendingMark(marks9[i$12]);
      }
    }
  }
};
ParseContext7.prototype.addTextNode = function addTextNode7(dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS)) {
      value = value.replace(/\s+/g, " ");
      if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        if (!nodeBefore || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext7.prototype.addElement = function addElement7(dom) {
  var name = dom.nodeName.toLowerCase();
  if (listTags.hasOwnProperty(name)) {
    normalizeList(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
  } else if (!rule || rule.skip) {
    if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync8, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync8 = true;
      if (!top.type) {
        this.needsBlock = true;
      }
    }
    this.addAll(dom);
    if (sync8) {
      this.sync(top);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule);
  }
};
ParseContext7.prototype.readStyles = function readStyles7(styles2) {
  var this$1$1 = this;
  var marks9 = Mark7.none;
  for (var i = 0; i < styles2.length; i += 2) {
    var rule = this$1$1.parser.matchStyle(styles2[i], styles2[i + 1], this$1$1);
    if (!rule) {
      continue;
    }
    if (rule.ignore) {
      return null;
    }
    marks9 = this$1$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks9);
  }
  return marks9;
};
ParseContext7.prototype.addElementByRule = function addElementByRule7(dom, rule) {
  var this$1$1 = this;
  var sync8, nodeType8, markType, mark15;
  if (rule.node) {
    nodeType8 = this.parser.schema.nodes[rule.node];
    if (nodeType8.isLeaf) {
      this.insertNode(nodeType8.create(rule.attrs));
    } else {
      sync8 = this.enter(nodeType8, rule.attrs, rule.preserveWhitespace);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark15 = markType.create(rule.attrs);
    this.addPendingMark(mark15);
  }
  var startIn = this.top;
  if (nodeType8 && nodeType8.isLeaf) {
    this.findInside(dom);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node18) {
      return this$1$1.insertNode(node18);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync8);
  }
  if (sync8) {
    this.sync(startIn);
    this.open--;
  }
  if (mark15) {
    this.removePendingMark(mark15);
  }
  return true;
};
ParseContext7.prototype.addAll = function addAll7(parent, sync8, startIndex, endIndex) {
  var this$1$1 = this;
  var index8 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end8 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end8; dom = dom.nextSibling, ++index8) {
    this$1$1.findAtPoint(parent, index8);
    this$1$1.addDOM(dom);
    if (sync8 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this$1$1.sync(sync8);
    }
  }
  this.findAtPoint(parent, index8);
};
ParseContext7.prototype.findPlace = function findPlace7(node18) {
  var this$1$1 = this;
  var route, sync8;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this$1$1.nodes[depth];
    var found2 = cx.findWrapping(node18);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync8 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync8);
  for (var i = 0; i < route.length; i++) {
    this$1$1.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext7.prototype.insertNode = function insertNode7(node18) {
  if (node18.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node18)) {
    this.closeExtra();
    var top = this.top;
    this.applyPendingMarks(top);
    if (top.match) {
      top.match = top.match.matchType(node18.type);
    }
    var marks9 = top.activeMarks;
    for (var i = 0; i < node18.marks.length; i++) {
      if (!top.type || top.type.allowsMarkType(node18.marks[i].type)) {
        marks9 = node18.marks[i].addToSet(marks9);
      }
    }
    top.content.push(node18.mark(marks9));
  }
};
ParseContext7.prototype.applyPendingMarks = function applyPendingMarks7(top) {
  var this$1$1 = this;
  for (var i = 0; i < this.pendingMarks.length; i++) {
    var mark15 = this$1$1.pendingMarks[i];
    if ((!top.type || top.type.allowsMarkType(mark15.type)) && !mark15.type.isInSet(top.activeMarks)) {
      top.activeMarks = mark15.addToSet(top.activeMarks);
      this$1$1.pendingMarks.splice(i--, 1);
    }
  }
};
ParseContext7.prototype.enter = function enter7(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.applyPendingMarks(this.top);
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext7.prototype.enterInner = function enterInner7(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
  if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {
    options |= OPT_OPEN_LEFT;
  }
  this.nodes.push(new NodeContext7(type, attrs, top.activeMarks, solid, null, options));
  this.open++;
};
ParseContext7.prototype.closeExtra = function closeExtra7(openEnd) {
  var this$1$1 = this;
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this$1$1.nodes[i - 1].content.push(this$1$1.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext7.prototype.finish = function finish16() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext7.prototype.sync = function sync7(to) {
  var this$1$1 = this;
  for (var i = this.open; i >= 0; i--) {
    if (this$1$1.nodes[i] == to) {
      this$1$1.open = i;
      return;
    }
  }
};
ParseContext7.prototype.addPendingMark = function addPendingMark7(mark15) {
  this.pendingMarks.push(mark15);
};
ParseContext7.prototype.removePendingMark = function removePendingMark7(mark15) {
  var found2 = this.pendingMarks.lastIndexOf(mark15);
  if (found2 > -1) {
    this.pendingMarks.splice(found2, 1);
  } else {
    var top = this.top;
    top.activeMarks = mark15.removeFromSet(top.activeMarks);
  }
};
prototypeAccessors$6.currentPos.get = function() {
  var this$1$1 = this;
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content2 = this$1$1.nodes[i].content;
    for (var j = content2.length - 1; j >= 0; j--) {
      pos += content2[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext7.prototype.findAtPoint = function findAtPoint7(parent, offset2) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == parent && this$1$1.find[i].offset == offset2) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext7.prototype.findInside = function findInside7(parent) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        this$1$1.find[i].pos = this$1$1.currentPos;
      }
    }
  }
};
ParseContext7.prototype.findAround = function findAround7(parent, content2, before8) {
  var this$1$1 = this;
  if (parent != content2 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1$1.find[i].node)) {
        var pos = content2.compareDocumentPosition(this$1$1.find[i].node);
        if (pos & (before8 ? 2 : 4)) {
          this$1$1.find[i].pos = this$1$1.currentPos;
        }
      }
    }
  }
};
ParseContext7.prototype.findInText = function findInText7(textNode) {
  var this$1$1 = this;
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this$1$1.find[i].node == textNode) {
        this$1$1.find[i].pos = this$1$1.currentPos - (textNode.nodeValue.length - this$1$1.find[i].offset);
      }
    }
  }
};
ParseContext7.prototype.matchesContext = function matchesContext7(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext7.prototype.textblockFromContext = function textblockFromContext7() {
  var this$1$1 = this;
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this$1$1.parser.schema.nodes) {
    var type = this$1$1.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
Object.defineProperties(ParseContext7.prototype, prototypeAccessors$6);
function normalizeList(dom) {
  for (var child15 = dom.firstChild, prevItem = null; child15; child15 = child15.nextSibling) {
    var name = child15.nodeType == 1 ? child15.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child15);
      child15 = prevItem;
    } else if (name == "li") {
      prevItem = child15;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy11(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
var DOMSerializer7 = function DOMSerializer8(nodes2, marks9) {
  this.nodes = nodes2 || {};
  this.marks = marks9 || {};
};
DOMSerializer7.prototype.serializeFragment = function serializeFragment7(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc(options).createDocumentFragment();
  }
  var top = target, active = null;
  fragment.forEach(function(node18) {
    if (active || node18.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node18.marks.length) {
        var next2 = node18.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep])) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node18.marks.length) {
        var add4 = node18.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add4, node18.isInline, options);
        if (markDOM) {
          active.push(add4, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1$1.serializeNode(node18, options));
  });
  return target;
};
DOMSerializer7.prototype.serializeNode = function serializeNode7(node18, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer7.renderSpec(doc(options), this.nodes[node18.type.name](node18));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node18.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node18, contentDOM, options);
    } else {
      this.serializeFragment(node18.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer7.prototype.serializeNodeAndMarks = function serializeNodeAndMarks7(node18, options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var dom = this.serializeNode(node18, options);
  for (var i = node18.marks.length - 1; i >= 0; i--) {
    var wrap2 = this$1$1.serializeMark(node18.marks[i], node18.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer7.prototype.serializeMark = function serializeMark7(mark15, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM4 = this.marks[mark15.type.name];
  return toDOM4 && DOMSerializer7.renderSpec(doc(options), toDOM4(mark15, inline3));
};
DOMSerializer7.renderSpec = function renderSpec7(doc2, structure) {
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  var dom = doc2.createElement(structure[0]), contentDOM = null;
  var attrs = structure[1], start16 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start16 = 2;
    for (var name in attrs) {
      if (name == "style") {
        dom.style.cssText = attrs[name];
      } else if (attrs[name] != null) {
        dom.setAttribute(name, attrs[name]);
      }
    }
  }
  for (var i = start16; i < structure.length; i++) {
    var child15 = structure[i];
    if (child15 === 0) {
      if (i < structure.length - 1 || i > start16) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer7.renderSpec(doc2, child15);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer7.fromSchema = function fromSchema14(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer7(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer7.nodesFromSchema = function nodesFromSchema7(schema2) {
  var result2 = gatherToDOM(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node18) {
      return node18.text;
    };
  }
  return result2;
};
DOMSerializer7.marksFromSchema = function marksFromSchema7(schema2) {
  return gatherToDOM(schema2.marks);
};
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM4 = obj[name].spec.toDOM;
    if (toDOM4) {
      result2[name] = toDOM4;
    }
  }
  return result2;
}
function doc(options) {
  return options.document || window.document;
}
var Node_1 = dist.Node = Node$1;
dist.ResolvedPos = ResolvedPos7;
dist.NodeRange = NodeRange7;
var Fragment_1 = dist.Fragment = Fragment7;
var Slice_1 = dist.Slice = Slice7;
dist.ReplaceError = ReplaceError;
var Mark_1 = dist.Mark = Mark7;
dist.Schema = Schema7;
dist.NodeType = NodeType9;
dist.MarkType = MarkType7;
dist.ContentMatch = ContentMatch7;
dist.DOMParser = DOMParser7;
dist.DOMSerializer = DOMSerializer7;
const classesById = /* @__PURE__ */ Object.create(null);
class Selection2 {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange2($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content2 = Slice_1.empty) {
    let lastNode = content2.content.lastChild, lastParent = null;
    for (let i = 0; i < content2.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice_1.empty : content2);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node18) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from12 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from12, to);
      } else {
        tr.replaceRangeWith(from12, to, node18);
        selectionToInsertionEnd(tr, mapFrom, node18.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  static jsonID(id2, selectionClass) {
    if (id2 in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id2);
    classesById[id2] = selectionClass;
    selectionClass.prototype.jsonID = id2;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection2.prototype.visible = true;
class SelectionRange2 {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection2 {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection2.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content2 = Slice_1.empty) {
    super.replace(tr, content2);
    if (content2 == Slice_1.empty) {
      let marks9 = this.$from.marksAcross(this.$to);
      if (marks9)
        tr.ensureMarks(marks9);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark2(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection2.findFrom($head, bias, true) || Selection2.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection2.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection2.findFrom($anchor, -bias, true) || Selection2.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection2.jsonID("text", TextSelection);
class TextBookmark2 {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark2(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection2 {
  constructor($pos) {
    let node18 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node18.nodeSize);
    super($pos, $end);
    this.node = node18;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection2.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice_1(Fragment_1.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark2(this.anchor);
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  static create(doc2, from12) {
    return new NodeSelection(doc2.resolve(from12));
  }
  static isSelectable(node18) {
    return !node18.isText && node18.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection2.jsonID("node", NodeSelection);
class NodeBookmark2 {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark2(pos, pos) : new NodeBookmark2(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node18 = $pos.nodeAfter;
    if (node18 && NodeSelection.isSelectable(node18))
      return new NodeSelection($pos);
    return Selection2.near($pos);
  }
}
class AllSelection extends Selection2 {
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content2 = Slice_1.empty) {
    if (content2 == Slice_1.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection2.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content2);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection2.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node18, pos, index8, dir, text8 = false) {
  if (node18.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index8 - (dir > 0 ? 0 : 1); dir > 0 ? i < node18.childCount : i >= 0; i += dir) {
    let child15 = node18.child(i);
    if (!child15.isAtom) {
      let inner = findSelectionIn(doc2, child15, pos + dir, dir < 0 ? child15.childCount : 0, dir, text8);
      if (inner)
        return inner;
    } else if (!text8 && NodeSelection.isSelectable(child15)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child15.nodeSize : 0));
    }
    pos += child15.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step3 = tr.steps[last];
  if (!(step3 instanceof ReplaceStep_1 || step3 instanceof ReplaceAroundStep_1))
    return;
  let map19 = tr.mapping.maps[last], end8;
  map19.forEach((_from, _to, _newFrom, newTo) => {
    if (end8 == null)
      end8 = newTo;
  });
  tr.setSelection(Selection2.near(tr.doc.resolve(end8), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform_1 {
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  setStoredMarks(marks9) {
    this.storedMarks = marks9;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  ensureMarks(marks9) {
    if (!Mark_1.sameSet(this.storedMarks || this.selection.$from.marks(), marks9))
      this.setStoredMarks(marks9);
    return this;
  }
  addStoredMark(mark15) {
    return this.ensureMarks(mark15.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  removeStoredMark(mark15) {
    return this.ensureMarks(mark15.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  addStep(step3, doc2) {
    super.addStep(step3, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  setTime(time) {
    this.time = time;
    return this;
  }
  replaceSelection(slice11) {
    this.selection.replace(this, slice11);
    return this;
  }
  replaceSelectionWith(node18, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node18 = node18.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark_1.none));
    selection.replaceWith(this, node18);
    return this;
  }
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  insertText(text8, from12, to) {
    let schema2 = this.doc.type.schema;
    if (from12 == null) {
      if (!text8)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema2.text(text8), true);
    } else {
      if (to == null)
        to = from12;
      to = to == null ? from12 : to;
      if (!text8)
        return this.deleteRange(from12, to);
      let marks9 = this.storedMarks;
      if (!marks9) {
        let $from = this.doc.resolve(from12);
        marks9 = to == from12 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from12, to, schema2.text(text8, marks9));
      if (!this.selection.empty)
        this.setSelection(Selection2.near(this.selection.$to));
      return this;
    }
  }
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f2, self2) {
  return !self2 || !f2 ? f2 : f2.bind(self2);
}
class FieldDesc2 {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc2("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc2("selection", {
    init(config, instance) {
      return config.selection || Selection2.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc2("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc2("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev2) {
      return tr.scrolledIntoView ? prev2 + 1 : prev2;
    }
  })
];
class Configuration2 {
  constructor(schema2, plugins) {
    this.schema = schema2;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc2(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState2 {
  constructor(config) {
    this.config = config;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n2 = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState2(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  get tr() {
    return new Transaction(this);
  }
  static create(config) {
    let $config = new Configuration2(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState2($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  reconfigure(config) {
    let $config = new Configuration2(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState2($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  toJSON(pluginFields) {
    let result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result2.storedMarks = this.storedMarks.map((m2) => m2.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result2;
  }
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration2(config.schema, config.plugins);
    let instance = new EditorState2($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node_1.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection2.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function getEditorStateClass() {
  return EditorState2;
}
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function asyncGeneratorStep(gen, resolve19, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve19(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve19, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve19, reject, _next, _throw, "next", value);
      }
      function _throw(err8) {
        asyncGeneratorStep(gen, resolve19, reject, _next, _throw, "throw", err8);
      }
      _next(void 0);
    });
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err8) {
    _d = true;
    _e = err8;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$9(o, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function() {
    var Super = _getPrototypeOf$8(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result2);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var NODE_PICKER_DEFAULT = {
  top: 0,
  left: 0,
  width: 0,
  height: 0,
  active: false
};
var HISTORY_SIZE = 200;
var SNAPSHOTS_KEY = "prosemirror-dev-tools-snapshots";
var nodesColors = [
  "#EA7C7F",
  "#67B0C6",
  "#94BB7F",
  "#CA9EDB",
  "#DCDC5D",
  "#B9CC7C",
  "#DD97D8",
  "#FFB761",
  "#4D8FD1",
  "#F36E98",
  "#E45F44",
  "#A6A4AE",
  "#FCC047",
  "#FFC129",
  "#D3929C",
  "#4CBCD4",
  "#8D7BC0"
];
function calculateSafeIndex(index8, total) {
  var quotient = index8 / total;
  return Math.round(total * (quotient - Math.floor(quotient)));
}
function buildColors(schema2) {
  return Object.keys(schema2.nodes).reduce(function(acc, node18, index8) {
    var safeIndex = index8 >= nodesColors.length ? calculateSafeIndex(index8, nodesColors.length) : index8;
    acc[node18] = nodesColors[safeIndex];
    return acc;
  }, {});
}
function findPMNode(domNode) {
  var node18;
  var target = domNode;
  while (!node18 && target) {
    if (target.pmViewDesc) {
      node18 = target;
    }
    target = target.parentNode;
  }
  return node18;
}
function getActiveMarks(editorState) {
  var selection = editorState.selection;
  var marks9 = [];
  if (selection.empty) {
    marks9 = selection.storedMarks || selection.$from.marks();
  } else {
    editorState.doc.nodesBetween(selection.from, selection.to, function(node18) {
      marks9 = marks9.concat(node18.marks);
    });
  }
  marks9 = marks9.reduce(function(acc, mark15) {
    if (acc.indexOf(mark15) === -1) {
      acc.push(mark15);
    }
    return acc;
  }, []).map(function(m2) {
    return m2.toJSON();
  });
  return marks9;
}
function buildSelection(selection) {
  return {
    type: selection.type,
    empty: selection.empty,
    anchor: selection.anchor,
    head: selection.head,
    from: selection.from,
    to: selection.to
  };
}
function createHistoryEntry(editorState) {
  var serializer = DOMSerializer$5.fromSchema(editorState.schema);
  var selection = editorState.selection;
  var domFragment = serializer.serializeFragment(selection.content().content);
  var selectionContent = [];
  if (domFragment) {
    var child15 = domFragment.firstChild;
    while (child15) {
      selectionContent.push(child15.outerHTML);
      child15 = child15.nextSibling;
    }
  }
  return {
    id: nanoid(),
    state: editorState,
    timestamp: Date.now(),
    diffPending: true,
    diff: void 0,
    selection: void 0,
    selectionContent: html.prettyPrint(selectionContent.join("\n"), {
      max_char: 60,
      indent_size: 2
    })
  };
}
function shrinkEditorHistory(history2, historyRolledBackTo) {
  var startIndex = historyRolledBackTo !== false ? historyRolledBackTo : 0;
  return history2.slice(startIndex, HISTORY_SIZE);
}
function updateEditorHistory(history2, historyRolledBackTo, tr, newState) {
  var skipHistory = tr.getMeta("_skip-dev-tools-history_");
  if (skipHistory)
    return;
  var newHistory = shrinkEditorHistory(history2, historyRolledBackTo);
  newHistory.unshift(createHistoryEntry(newState));
  return newHistory;
}
var EditorStateContainer = /* @__PURE__ */ function(_Container) {
  _inherits$8(EditorStateContainer2, _Container);
  var _super = _createSuper$8(EditorStateContainer2);
  function EditorStateContainer2(_editorView, props) {
    var _this;
    _classCallCheck$8(this, EditorStateContainer2);
    _this = _super.call(this);
    _defineProperty$5(_assertThisInitialized$8(_this), "state", {
      EditorState: function EditorState3() {
      },
      view: null,
      state: {},
      schema: {},
      nodeColors: {},
      activeMarks: [],
      history: [],
      expandPath: [],
      historyRolledBackTo: false,
      selectedHistoryItem: 0,
      snapshots: JSON.parse(window.localStorage.getItem(SNAPSHOTS_KEY)) || [],
      nodePicker: NODE_PICKER_DEFAULT
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "activatePicker", function() {
      _this.setState({
        nodePicker: Object.assign({}, NODE_PICKER_DEFAULT, {
          active: true
        })
      });
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "deactivatePicker", function() {
      var picker = _this.state.nodePicker;
      if (picker.onMouseOver) {
        document.removeEventListener("mouseover", picker.onMouseOver);
      }
      if (picker.onMouseOver) {
        document.removeEventListener("click", picker.onClick);
      }
      _this.setState({
        nodePicker: NODE_PICKER_DEFAULT
      });
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "updateNodePickerPossition", function(target) {
      var node18 = findPMNode(target);
      if (node18 && (node18.pmViewDesc.node && node18.pmViewDesc.node.type.name !== "doc" || node18.pmViewDesc.mark)) {
        var _node$getBoundingClie = node18.getBoundingClientRect(), top = _node$getBoundingClie.top, left = _node$getBoundingClie.left, width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
        _this.setState({
          nodePicker: {
            top: top + window.scrollY,
            left,
            width,
            height,
            active: true
          }
        });
      } else {
        _this.setState({
          nodePicker: Object.assign({}, NODE_PICKER_DEFAULT, {
            active: true
          })
        });
      }
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "nodePickerSelect", function(target) {
      var node18 = findPMNode(target);
      if (node18) {
        var editorState = _this.state.state;
        var path = findNodeIn(editorState.doc, editorState.doc.nodeAt(node18.pmViewDesc.posAtStart));
        _this.setState({
          expandPath: path
        });
      }
      _this.setState({
        nodePicker: NODE_PICKER_DEFAULT
      });
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "saveSnapshot", function() {
      var snapshotName = prompt("Enter snapshot name", Date.now());
      if (!snapshotName)
        return;
      var snapshots = [{
        name: snapshotName,
        timestamp: Date.now(),
        snapshot: _this.state.state.doc.toJSON()
      }].concat(_this.state.snapshots);
      _this.setState({
        snapshots
      });
      window.localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(snapshots));
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "loadSnapshot", function(snapshot) {
      var EditorState3 = _this.state.EditorState;
      var editorView = _this.state.view;
      var editorState = editorView.state;
      var newState = EditorState3.create({
        schema: editorState.schema,
        plugins: editorState.plugins,
        doc: editorState.schema.nodeFromJSON(snapshot.snapshot)
      });
      _this.setState({
        history: [createHistoryEntry(newState)],
        state: newState
      });
      editorView.updateState(newState);
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "deleteSnapshot", function(snapshot) {
      var snapshots = _this.state.snapshots;
      var snapshotIndex = snapshots.indexOf(snapshot);
      snapshots.splice(snapshotIndex, 1);
      _this.setState({
        snapshots: [].concat(snapshots)
      });
      window.localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(snapshots));
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "logNodeFromJSON", function(_ref) {
      var doc2 = _ref.doc, node18 = _ref.node;
      var fullDoc = _this.state.state.doc;
      var path = findNodeInJSON(doc2, node18);
      if (path) {
        console.log(path.reduce(function(node19, pathItem) {
          return node19[pathItem];
        }, fullDoc));
      } else {
        console.log(node18);
      }
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "selectHistoryItem", function(index8) {
      return _this.setState({
        selectedHistoryItem: index8
      });
    });
    _defineProperty$5(_assertThisInitialized$8(_this), "rollbackHistory", function(index8) {
      var EditorState3 = _this.state.EditorState;
      var editorState = _this.state.history[index8].state;
      var editorView = _this.state.view;
      var newState = EditorState3.create({
        schema: editorState.schema,
        plugins: editorState.plugins,
        doc: editorState.schema.nodeFromJSON(editorState.doc.toJSON())
      });
      editorView.updateState(newState);
      editorView.dom.focus();
      var tr = editorView.state.tr.setSelection(editorState.selection).setMeta("addToHistory", false).setMeta("_skip-dev-tools-history_", true);
      editorView.dispatch(tr);
      _this.setState({
        state: newState,
        historyRolledBackTo: index8
      });
    });
    _this.diffWorker = props && props.diffWorker ? import("./json-diff-worker.js").then(function(_ref2) {
      var JsonDiffWorker = _ref2.JsonDiffWorker;
      return new JsonDiffWorker(props.diffWorker);
    }) : import("./json-diff-main.js").then(function(_ref3) {
      var JsonDiffMain = _ref3.JsonDiffMain;
      return new JsonDiffMain();
    });
    _this.state = Object.assign({}, _this.state, {
      EditorState: getEditorStateClass(),
      view: _editorView,
      state: _editorView.state,
      nodeColors: buildColors(_editorView.state.schema),
      history: [{
        state: _editorView.state,
        timestamp: Date.now()
      }]
    });
    subscribeOnUpdates(_editorView, function(tr, oldState, newState) {
      var updatedHistory = updateEditorHistory(_this.state.history, _this.state.historyRolledBackTo, tr, newState);
      if (oldState && updatedHistory) {
        var _updatedHistory = _slicedToArray(updatedHistory, 1), id2 = _updatedHistory[0].id;
        var self2 = _assertThisInitialized$8(_this);
        _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee() {
          var diffWorker, _yield$Promise$all, _yield$Promise$all2, diff, selection, history2;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.diffWorker;
                case 2:
                  diffWorker = _context.sent;
                  _context.next = 5;
                  return Promise.all([diffWorker.diff({
                    a: oldState.doc.toJSON(),
                    b: newState.doc.toJSON(),
                    id: id2
                  }), diffWorker.diff({
                    a: buildSelection(oldState.selection),
                    b: buildSelection(newState.selection),
                    id: id2
                  })]);
                case 5:
                  _yield$Promise$all = _context.sent;
                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                  diff = _yield$Promise$all2[0].delta;
                  selection = _yield$Promise$all2[1].delta;
                  history2 = updatedHistory.map(function(item) {
                    return item.id === id2 ? Object.assign({}, item, {
                      diff,
                      diffPending: false,
                      selection
                    }) : item;
                  });
                  self2.setState({
                    history: history2
                  });
                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
      _this.setState({
        state: newState,
        nodeColors: buildColors(newState.schema),
        activeMarks: getActiveMarks(newState),
        history: updatedHistory || _this.state.history,
        selectedHistoryItem: updatedHistory ? 0 : _this.state.selectedHistoryItem,
        historyRolledBackTo: updatedHistory ? false : _this.state.historyRolledBackTo
      });
    });
    return _this;
  }
  return EditorStateContainer2;
}(Container);
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$8(o, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function() {
    var Super = _getPrototypeOf$7(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result2);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StateTabStateContainer = /* @__PURE__ */ function(_Container) {
  _inherits$7(StateTabStateContainer2, _Container);
  var _super = _createSuper$7(StateTabStateContainer2);
  function StateTabStateContainer2() {
    var _this;
    _classCallCheck$7(this, StateTabStateContainer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$7(_this), "state", {
      selectionExpanded: false
    });
    _defineProperty$4(_assertThisInitialized$7(_this), "toggleSelection", function() {
      _this.setState({
        selectionExpanded: !_this.state.selectionExpanded
      });
    });
    return _this;
  }
  return StateTabStateContainer2;
}(Container);
var copyProps = ["jsonID", "empty", "anchor", "from", "head", "to", "$anchor", "$head", "$cursor", "$to", "$from"];
var copySubProps = {
  $from: ["nodeAfter", "nodeBefore", "parent", "textOffset", "depth", "pos"],
  $to: ["nodeAfter", "nodeBefore", "parent", "textOffset", "depth", "pos"]
};
var isNode = ["nodeAfter", "nodeBefore", "parent"];
function filterProps(selection, props, subProps) {
  return props.reduce(function(acc, prop) {
    if (subProps && subProps[prop]) {
      acc[prop] = subProps[prop].reduce(function(subAcc, subProp) {
        subAcc[subProp] = isNode.indexOf(subProp) === -1 || !selection[prop][subProp] ? selection[prop][subProp] : selection[prop][subProp].toJSON();
        return subAcc;
      }, {});
    } else {
      acc[prop === "jsonID" ? "type" : prop] = selection[prop];
    }
    return acc;
  }, {});
}
function expandedStateFormatSelection(selection) {
  return filterProps(selection, copyProps, copySubProps);
}
function collapsedStateFormatSelection(selection) {
  return filterProps(selection, copyProps.slice(0, 6));
}
var SplitView = newStyled("div")({
  display: "flex",
  height: "100%"
});
SplitView.displayName = "SplitView";
var SplitViewCol = newStyled("div")({
  boxSizing: "border-box",
  height: "100%",
  overflow: "scroll"
}, function(_ref) {
  var grow = _ref.grow, sep = _ref.sep, noPaddings = _ref.noPaddings, minWidth = _ref.minWidth, maxWidth = _ref.maxWidth;
  return {
    flexGrow: grow ? 1 : 0,
    borderLeft: sep ? "1px solid " + mainTheme.main20 : "none",
    padding: noPaddings ? "" : "16px 18px 18px",
    minWidth: minWidth ? "".concat(minWidth, "px") : "none",
    maxWidth: maxWidth ? "".concat(maxWidth, "px") : "none"
  };
});
SplitViewCol.displayName = "SplitViewCol";
var lib$1 = {};
var objectWithoutProperties = {};
objectWithoutProperties.__esModule = true;
objectWithoutProperties.default = function(obj, keys3) {
  var target = {};
  for (var i in obj) {
    if (keys3.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
};
var classCallCheck = {};
classCallCheck.__esModule = true;
classCallCheck.default = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var possibleConstructorReturn = {};
var _typeof$8 = {};
var iterator$1 = { exports: {} };
var ceil = Math.ceil;
var floor$1 = Math.floor;
var _toInteger = function(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor$1 : ceil)(it);
};
var _defined = function(it) {
  if (it == void 0)
    throw TypeError("Can't call method on  " + it);
  return it;
};
var toInteger$3 = _toInteger;
var defined$2 = _defined;
var _stringAt = function(TO_STRING) {
  return function(that, pos) {
    var s = String(defined$2(that));
    var i = toInteger$3(pos);
    var l2 = s.length;
    var a, b;
    if (i < 0 || i >= l2)
      return TO_STRING ? "" : void 0;
    a = s.charCodeAt(i);
    return a < 55296 || a > 56319 || i + 1 === l2 || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
  };
};
var _library = true;
var _global = { exports: {} };
var global$5 = _global.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
if (typeof __g == "number")
  __g = global$5;
var _core = { exports: {} };
var core$4 = _core.exports = { version: "2.5.7" };
if (typeof __e == "number")
  __e = core$4;
var _aFunction = function(it) {
  if (typeof it != "function")
    throw TypeError(it + " is not a function!");
  return it;
};
var aFunction = _aFunction;
var _ctx = function(fn, that, length2) {
  aFunction(fn);
  if (that === void 0)
    return fn;
  switch (length2) {
    case 1:
      return function(a) {
        return fn.call(that, a);
      };
    case 2:
      return function(a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function(a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function() {
    return fn.apply(that, arguments);
  };
};
var _objectDp = {};
var _isObject = function(it) {
  return typeof it === "object" ? it !== null : typeof it === "function";
};
var isObject$8 = _isObject;
var _anObject = function(it) {
  if (!isObject$8(it))
    throw TypeError(it + " is not an object!");
  return it;
};
var _fails = function(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};
var _descriptors = !_fails(function() {
  return Object.defineProperty({}, "a", { get: function() {
    return 7;
  } }).a != 7;
});
var isObject$7 = _isObject;
var document$2 = _global.exports.document;
var is3 = isObject$7(document$2) && isObject$7(document$2.createElement);
var _domCreate = function(it) {
  return is3 ? document$2.createElement(it) : {};
};
var _ie8DomDefine = !_descriptors && !_fails(function() {
  return Object.defineProperty(_domCreate("div"), "a", { get: function() {
    return 7;
  } }).a != 7;
});
var isObject$6 = _isObject;
var _toPrimitive = function(it, S2) {
  if (!isObject$6(it))
    return it;
  var fn, val;
  if (S2 && typeof (fn = it.toString) == "function" && !isObject$6(val = fn.call(it)))
    return val;
  if (typeof (fn = it.valueOf) == "function" && !isObject$6(val = fn.call(it)))
    return val;
  if (!S2 && typeof (fn = it.toString) == "function" && !isObject$6(val = fn.call(it)))
    return val;
  throw TypeError("Can't convert object to primitive value");
};
var anObject$5 = _anObject;
var IE8_DOM_DEFINE$1 = _ie8DomDefine;
var toPrimitive$2 = _toPrimitive;
var dP$3 = Object.defineProperty;
_objectDp.f = _descriptors ? Object.defineProperty : function defineProperty(O2, P2, Attributes) {
  anObject$5(O2);
  P2 = toPrimitive$2(P2, true);
  anObject$5(Attributes);
  if (IE8_DOM_DEFINE$1)
    try {
      return dP$3(O2, P2, Attributes);
    } catch (e) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw TypeError("Accessors not supported!");
  if ("value" in Attributes)
    O2[P2] = Attributes.value;
  return O2;
};
var _propertyDesc = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var dP$2 = _objectDp;
var createDesc$2 = _propertyDesc;
var _hide = _descriptors ? function(object, key, value) {
  return dP$2.f(object, key, createDesc$2(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var hasOwnProperty$2 = {}.hasOwnProperty;
var _has = function(it, key) {
  return hasOwnProperty$2.call(it, key);
};
var global$4 = _global.exports;
var core$3 = _core.exports;
var ctx = _ctx;
var hide$2 = _hide;
var has$6 = _has;
var PROTOTYPE$2 = "prototype";
var $export$7 = function(type, name, source) {
  var IS_FORCED = type & $export$7.F;
  var IS_GLOBAL = type & $export$7.G;
  var IS_STATIC = type & $export$7.S;
  var IS_PROTO = type & $export$7.P;
  var IS_BIND = type & $export$7.B;
  var IS_WRAP = type & $export$7.W;
  var exports = IS_GLOBAL ? core$3 : core$3[name] || (core$3[name] = {});
  var expProto = exports[PROTOTYPE$2];
  var target = IS_GLOBAL ? global$4 : IS_STATIC ? global$4[name] : (global$4[name] || {})[PROTOTYPE$2];
  var key, own, out;
  if (IS_GLOBAL)
    source = name;
  for (key in source) {
    own = !IS_FORCED && target && target[key] !== void 0;
    if (own && has$6(exports, key))
      continue;
    out = own ? target[key] : source[key];
    exports[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global$4) : IS_WRAP && target[key] == out ? function(C2) {
      var F2 = function(a, b, c) {
        if (this instanceof C2) {
          switch (arguments.length) {
            case 0:
              return new C2();
            case 1:
              return new C2(a);
            case 2:
              return new C2(a, b);
          }
          return new C2(a, b, c);
        }
        return C2.apply(this, arguments);
      };
      F2[PROTOTYPE$2] = C2[PROTOTYPE$2];
      return F2;
    }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      if (type & $export$7.R && expProto && !expProto[key])
        hide$2(expProto, key, out);
    }
  }
};
$export$7.F = 1;
$export$7.G = 2;
$export$7.S = 4;
$export$7.P = 8;
$export$7.B = 16;
$export$7.W = 32;
$export$7.U = 64;
$export$7.R = 128;
var _export = $export$7;
var _redefine = _hide;
var _iterators = {};
var toString$1 = {}.toString;
var _cof = function(it) {
  return toString$1.call(it).slice(8, -1);
};
var cof$2 = _cof;
var _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
  return cof$2(it) == "String" ? it.split("") : Object(it);
};
var IObject$1 = _iobject;
var defined$1 = _defined;
var _toIobject = function(it) {
  return IObject$1(defined$1(it));
};
var toInteger$2 = _toInteger;
var min$1 = Math.min;
var _toLength = function(it) {
  return it > 0 ? min$1(toInteger$2(it), 9007199254740991) : 0;
};
var toInteger$1 = _toInteger;
var max8 = Math.max;
var min8 = Math.min;
var _toAbsoluteIndex = function(index8, length2) {
  index8 = toInteger$1(index8);
  return index8 < 0 ? max8(index8 + length2, 0) : min8(index8, length2);
};
var toIObject$5 = _toIobject;
var toLength = _toLength;
var toAbsoluteIndex = _toAbsoluteIndex;
var _arrayIncludes = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O2 = toIObject$5($this);
    var length2 = toLength(O2.length);
    var index8 = toAbsoluteIndex(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el != el)
      while (length2 > index8) {
        value = O2[index8++];
        if (value != value)
          return true;
      }
    else
      for (; length2 > index8; index8++)
        if (IS_INCLUDES || index8 in O2) {
          if (O2[index8] === el)
            return IS_INCLUDES || index8 || 0;
        }
    return !IS_INCLUDES && -1;
  };
};
var _shared = { exports: {} };
var core$2 = _core.exports;
var global$3 = _global.exports;
var SHARED = "__core-js_shared__";
var store$1 = global$3[SHARED] || (global$3[SHARED] = {});
(_shared.exports = function(key, value) {
  return store$1[key] || (store$1[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: core$2.version,
  mode: "pure",
  copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
});
var id$1 = 0;
var px = Math.random();
var _uid = function(key) {
  return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id$1 + px).toString(36));
};
var shared$1 = _shared.exports("keys");
var uid$2 = _uid;
var _sharedKey = function(key) {
  return shared$1[key] || (shared$1[key] = uid$2(key));
};
var has$5 = _has;
var toIObject$4 = _toIobject;
var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$2 = _sharedKey("IE_PROTO");
var _objectKeysInternal = function(object, names) {
  var O2 = toIObject$4(object);
  var i = 0;
  var result2 = [];
  var key;
  for (key in O2)
    if (key != IE_PROTO$2)
      has$5(O2, key) && result2.push(key);
  while (names.length > i)
    if (has$5(O2, key = names[i++])) {
      ~arrayIndexOf(result2, key) || result2.push(key);
    }
  return result2;
};
var _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
var $keys$3 = _objectKeysInternal;
var enumBugKeys$1 = _enumBugKeys;
var _objectKeys = Object.keys || function keys(O2) {
  return $keys$3(O2, enumBugKeys$1);
};
var dP$1 = _objectDp;
var anObject$4 = _anObject;
var getKeys$2 = _objectKeys;
var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O2, Properties) {
  anObject$4(O2);
  var keys3 = getKeys$2(Properties);
  var length2 = keys3.length;
  var i = 0;
  var P2;
  while (length2 > i)
    dP$1.f(O2, P2 = keys3[i++], Properties[P2]);
  return O2;
};
var document$1 = _global.exports.document;
var _html = document$1 && document$1.documentElement;
var anObject$3 = _anObject;
var dPs = _objectDps;
var enumBugKeys = _enumBugKeys;
var IE_PROTO$1 = _sharedKey("IE_PROTO");
var Empty = function() {
};
var PROTOTYPE$1 = "prototype";
var createDict = function() {
  var iframe = _domCreate("iframe");
  var i = enumBugKeys.length;
  var lt = "<";
  var gt = ">";
  var iframeDocument;
  iframe.style.display = "none";
  _html.appendChild(iframe);
  iframe.src = "javascript:";
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--)
    delete createDict[PROTOTYPE$1][enumBugKeys[i]];
  return createDict();
};
var _objectCreate = Object.create || function create18(O2, Properties) {
  var result2;
  if (O2 !== null) {
    Empty[PROTOTYPE$1] = anObject$3(O2);
    result2 = new Empty();
    Empty[PROTOTYPE$1] = null;
    result2[IE_PROTO$1] = O2;
  } else
    result2 = createDict();
  return Properties === void 0 ? result2 : dPs(result2, Properties);
};
var _wks = { exports: {} };
var store = _shared.exports("wks");
var uid$1 = _uid;
var Symbol$2 = _global.exports.Symbol;
var USE_SYMBOL = typeof Symbol$2 == "function";
var $exports = _wks.exports = function(name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : uid$1)("Symbol." + name));
};
$exports.store = store;
var def = _objectDp.f;
var has$4 = _has;
var TAG$1 = _wks.exports("toStringTag");
var _setToStringTag = function(it, tag, stat) {
  if (it && !has$4(it = stat ? it : it.prototype, TAG$1))
    def(it, TAG$1, { configurable: true, value: tag });
};
var create$2 = _objectCreate;
var descriptor = _propertyDesc;
var setToStringTag$2 = _setToStringTag;
var IteratorPrototype = {};
_hide(IteratorPrototype, _wks.exports("iterator"), function() {
  return this;
});
var _iterCreate = function(Constructor, NAME, next2) {
  Constructor.prototype = create$2(IteratorPrototype, { next: descriptor(1, next2) });
  setToStringTag$2(Constructor, NAME + " Iterator");
};
var defined = _defined;
var _toObject = function(it) {
  return Object(defined(it));
};
var has$3 = _has;
var toObject$2 = _toObject;
var IE_PROTO = _sharedKey("IE_PROTO");
var ObjectProto$1 = Object.prototype;
var _objectGpo = Object.getPrototypeOf || function(O2) {
  O2 = toObject$2(O2);
  if (has$3(O2, IE_PROTO))
    return O2[IE_PROTO];
  if (typeof O2.constructor == "function" && O2 instanceof O2.constructor) {
    return O2.constructor.prototype;
  }
  return O2 instanceof Object ? ObjectProto$1 : null;
};
var $export$6 = _export;
var redefine$1 = _redefine;
var hide$1 = _hide;
var Iterators$4 = _iterators;
var $iterCreate = _iterCreate;
var setToStringTag$1 = _setToStringTag;
var getPrototypeOf = _objectGpo;
var ITERATOR$2 = _wks.exports("iterator");
var BUGGY = !([].keys && "next" in [].keys());
var FF_ITERATOR = "@@iterator";
var KEYS = "keys";
var VALUES = "values";
var returnThis = function() {
  return this;
};
var _iterDefine = function(Base, NAME, Constructor, next2, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next2);
  var getMethod = function(kind) {
    if (!BUGGY && kind in proto)
      return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys3() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }
    return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG2 = NAME + " Iterator";
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR$2] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
  var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype2;
  if ($anyNative) {
    IteratorPrototype2 = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype2 !== Object.prototype && IteratorPrototype2.next) {
      setToStringTag$1(IteratorPrototype2, TAG2, true);
    }
  }
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  if (FORCED && (BUGGY || VALUES_BUG || !proto[ITERATOR$2])) {
    hide$1(proto, ITERATOR$2, $default);
  }
  Iterators$4[NAME] = $default;
  Iterators$4[TAG2] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED)
      for (key in methods) {
        if (!(key in proto))
          redefine$1(proto, key, methods[key]);
      }
    else
      $export$6($export$6.P + $export$6.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
var $at = _stringAt(true);
_iterDefine(String, "String", function(iterated) {
  this._t = String(iterated);
  this._i = 0;
}, function() {
  var O2 = this._t;
  var index8 = this._i;
  var point;
  if (index8 >= O2.length)
    return { value: void 0, done: true };
  point = $at(O2, index8);
  this._i += point.length;
  return { value: point, done: false };
});
var _iterStep = function(done3, value) {
  return { value, done: !!done3 };
};
var step2 = _iterStep;
var Iterators$3 = _iterators;
var toIObject$3 = _toIobject;
_iterDefine(Array, "Array", function(iterated, kind) {
  this._t = toIObject$3(iterated);
  this._i = 0;
  this._k = kind;
}, function() {
  var O2 = this._t;
  var kind = this._k;
  var index8 = this._i++;
  if (!O2 || index8 >= O2.length) {
    this._t = void 0;
    return step2(1);
  }
  if (kind == "keys")
    return step2(0, index8);
  if (kind == "values")
    return step2(0, O2[index8]);
  return step2(0, [index8, O2[index8]]);
}, "values");
Iterators$3.Arguments = Iterators$3.Array;
var global$2 = _global.exports;
var hide = _hide;
var Iterators$2 = _iterators;
var TO_STRING_TAG = _wks.exports("toStringTag");
var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global$2[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG])
    hide(proto, TO_STRING_TAG, NAME);
  Iterators$2[NAME] = Iterators$2.Array;
}
var _wksExt = {};
_wksExt.f = _wks.exports;
var iterator = _wksExt.f("iterator");
(function(module) {
  module.exports = { "default": iterator, __esModule: true };
})(iterator$1);
var symbol$1 = { exports: {} };
var _meta = { exports: {} };
var META$1 = _uid("meta");
var isObject$5 = _isObject;
var has$2 = _has;
var setDesc = _objectDp.f;
var id = 0;
var isExtensible = Object.isExtensible || function() {
  return true;
};
var FREEZE = !_fails(function() {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it) {
  setDesc(it, META$1, { value: {
    i: "O" + ++id,
    w: {}
  } });
};
var fastKey = function(it, create22) {
  if (!isObject$5(it))
    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!has$2(it, META$1)) {
    if (!isExtensible(it))
      return "F";
    if (!create22)
      return "E";
    setMeta(it);
  }
  return it[META$1].i;
};
var getWeak = function(it, create22) {
  if (!has$2(it, META$1)) {
    if (!isExtensible(it))
      return true;
    if (!create22)
      return false;
    setMeta(it);
  }
  return it[META$1].w;
};
var onFreeze = function(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has$2(it, META$1))
    setMeta(it);
  return it;
};
var meta = _meta.exports = {
  KEY: META$1,
  NEED: false,
  fastKey,
  getWeak,
  onFreeze
};
var core$1 = _core.exports;
var wksExt$1 = _wksExt;
var defineProperty$1 = _objectDp.f;
var _wksDefine = function(name) {
  var $Symbol2 = core$1.Symbol || (core$1.Symbol = {});
  if (name.charAt(0) != "_" && !(name in $Symbol2))
    defineProperty$1($Symbol2, name, { value: wksExt$1.f(name) });
};
var _objectGops = {};
_objectGops.f = Object.getOwnPropertySymbols;
var _objectPie = {};
_objectPie.f = {}.propertyIsEnumerable;
var getKeys$1 = _objectKeys;
var gOPS$1 = _objectGops;
var pIE$2 = _objectPie;
var _enumKeys = function(it) {
  var result2 = getKeys$1(it);
  var getSymbols = gOPS$1.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum2 = pIE$2.f;
    var i = 0;
    var key;
    while (symbols.length > i)
      if (isEnum2.call(it, key = symbols[i++]))
        result2.push(key);
  }
  return result2;
};
var cof$1 = _cof;
var _isArray = Array.isArray || function isArray(arg) {
  return cof$1(arg) == "Array";
};
var _objectGopnExt = {};
var _objectGopn = {};
var $keys$2 = _objectKeysInternal;
var hiddenKeys = _enumBugKeys.concat("length", "prototype");
_objectGopn.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
  return $keys$2(O2, hiddenKeys);
};
var toIObject$2 = _toIobject;
var gOPN$1 = _objectGopn.f;
var toString37 = {}.toString;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return gOPN$1(it);
  } catch (e) {
    return windowNames.slice();
  }
};
_objectGopnExt.f = function getOwnPropertyNames2(it) {
  return windowNames && toString37.call(it) == "[object Window]" ? getWindowNames(it) : gOPN$1(toIObject$2(it));
};
var _objectGopd = {};
var pIE$1 = _objectPie;
var createDesc$1 = _propertyDesc;
var toIObject$1 = _toIobject;
var toPrimitive$1 = _toPrimitive;
var has$1 = _has;
var IE8_DOM_DEFINE = _ie8DomDefine;
var gOPD$1 = Object.getOwnPropertyDescriptor;
_objectGopd.f = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O2, P2) {
  O2 = toIObject$1(O2);
  P2 = toPrimitive$1(P2, true);
  if (IE8_DOM_DEFINE)
    try {
      return gOPD$1(O2, P2);
    } catch (e) {
    }
  if (has$1(O2, P2))
    return createDesc$1(!pIE$1.f.call(O2, P2), O2[P2]);
};
var global$1 = _global.exports;
var has = _has;
var DESCRIPTORS = _descriptors;
var $export$5 = _export;
var redefine = _redefine;
var META = _meta.exports.KEY;
var $fails = _fails;
var shared = _shared.exports;
var setToStringTag = _setToStringTag;
var uid = _uid;
var wks = _wks.exports;
var wksExt = _wksExt;
var wksDefine = _wksDefine;
var enumKeys = _enumKeys;
var isArray$1 = _isArray;
var anObject$2 = _anObject;
var isObject$4 = _isObject;
var toIObject = _toIobject;
var toPrimitive = _toPrimitive;
var createDesc = _propertyDesc;
var _create$1 = _objectCreate;
var gOPNExt = _objectGopnExt;
var $GOPD = _objectGopd;
var $DP = _objectDp;
var $keys$1 = _objectKeys;
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global$1.Symbol;
var $JSON = global$1.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = "prototype";
var HIDDEN = wks("_hidden");
var TO_PRIMITIVE = wks("toPrimitive");
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared("symbol-registry");
var AllSymbols = shared("symbols");
var OPSymbols = shared("op-symbols");
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == "function";
var QObject = global$1.QObject;
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDesc = DESCRIPTORS && $fails(function() {
  return _create$1(dP({}, "a", {
    get: function() {
      return dP(this, "a", { value: 7 }).a;
    }
  })).a != 7;
}) ? function(it, key, D2) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc)
    delete ObjectProto[key];
  dP(it, key, D2);
  if (protoDesc && it !== ObjectProto)
    dP(ObjectProto, key, protoDesc);
} : dP;
var wrap = function(tag) {
  var sym = AllSymbols[tag] = _create$1($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};
var isSymbol$1 = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  return it instanceof $Symbol;
};
var $defineProperty = function defineProperty2(it, key, D2) {
  if (it === ObjectProto)
    $defineProperty(OPSymbols, key, D2);
  anObject$2(it);
  key = toPrimitive(key, true);
  anObject$2(D2);
  if (has(AllSymbols, key)) {
    if (!D2.enumerable) {
      if (!has(it, HIDDEN))
        dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key])
        it[HIDDEN][key] = false;
      D2 = _create$1(D2, { enumerable: createDesc(0, false) });
    }
    return setSymbolDesc(it, key, D2);
  }
  return dP(it, key, D2);
};
var $defineProperties = function defineProperties2(it, P2) {
  anObject$2(it);
  var keys3 = enumKeys(P2 = toIObject(P2));
  var i = 0;
  var l2 = keys3.length;
  var key;
  while (l2 > i)
    $defineProperty(it, key = keys3[i++], P2[key]);
  return it;
};
var $create = function create19(it, P2) {
  return P2 === void 0 ? _create$1(it) : $defineProperties(_create$1(it), P2);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
    return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
    return;
  var D2 = gOPD(it, key);
  if (D2 && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
    D2.enumerable = true;
  return D2;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(it) {
  var names = gOPN(toIObject(it));
  var result2 = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
      result2.push(key);
  }
  return result2;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols2(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result2 = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
      result2.push(AllSymbols[key]);
  }
  return result2;
};
if (!USE_NATIVE) {
  $Symbol = function Symbol2() {
    if (this instanceof $Symbol)
      throw TypeError("Symbol is not a constructor!");
    var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
    var $set = function(value) {
      if (this === ObjectProto)
        $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag))
        this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter)
      setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], "toString", function toString38() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  _objectGopn.f = gOPNExt.f = $getOwnPropertyNames;
  _objectPie.f = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;
  if (DESCRIPTORS && !_library) {
    redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable);
  }
  wksExt.f = function(name) {
    return wrap(wks(name));
  };
}
$export$5($export$5.G + $export$5.W + $export$5.F * !USE_NATIVE, { Symbol: $Symbol });
for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
  wks(es6Symbols[j++]);
for (var wellKnownSymbols = $keys$1(wks.store), k = 0; wellKnownSymbols.length > k; )
  wksDefine(wellKnownSymbols[k++]);
$export$5($export$5.S + $export$5.F * !USE_NATIVE, "Symbol", {
  "for": function(key) {
    return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  keyFor: function keyFor(sym) {
    if (!isSymbol$1(sym))
      throw TypeError(sym + " is not a symbol!");
    for (var key in SymbolRegistry)
      if (SymbolRegistry[key] === sym)
        return key;
  },
  useSetter: function() {
    setter = true;
  },
  useSimple: function() {
    setter = false;
  }
});
$export$5($export$5.S + $export$5.F * !USE_NATIVE, "Object", {
  create: $create,
  defineProperty: $defineProperty,
  defineProperties: $defineProperties,
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  getOwnPropertyNames: $getOwnPropertyNames,
  getOwnPropertySymbols: $getOwnPropertySymbols
});
$JSON && $export$5($export$5.S + $export$5.F * (!USE_NATIVE || $fails(function() {
  var S2 = $Symbol();
  return _stringify([S2]) != "[null]" || _stringify({ a: S2 }) != "{}" || _stringify(Object(S2)) != "{}";
})), "JSON", {
  stringify: function stringify2(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i)
      args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject$4(replacer) && it === void 0 || isSymbol$1(it))
      return;
    if (!isArray$1(replacer))
      replacer = function(key, value) {
        if (typeof $replacer == "function")
          value = $replacer.call(this, key, value);
        if (!isSymbol$1(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, "Symbol");
setToStringTag(Math, "Math", true);
setToStringTag(global$1.JSON, "JSON", true);
_wksDefine("asyncIterator");
_wksDefine("observable");
var symbol = _core.exports.Symbol;
(function(module) {
  module.exports = { "default": symbol, __esModule: true };
})(symbol$1);
_typeof$8.__esModule = true;
var _iterator = iterator$1.exports;
var _iterator2 = _interopRequireDefault$5(_iterator);
var _symbol = symbol$1.exports;
var _symbol2 = _interopRequireDefault$5(_symbol);
var _typeof$7 = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
};
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
_typeof$8.default = typeof _symbol2.default === "function" && _typeof$7(_iterator2.default) === "symbol" ? function(obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof$7(obj);
} : function(obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof$7(obj);
};
possibleConstructorReturn.__esModule = true;
var _typeof2$2 = _typeof$8;
var _typeof3$2 = _interopRequireDefault$4(_typeof2$2);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
possibleConstructorReturn.default = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3$2.default)(call)) === "object" || typeof call === "function") ? call : self2;
};
var inherits = {};
var setPrototypeOf$1 = { exports: {} };
var isObject$3 = _isObject;
var anObject$1 = _anObject;
var check8 = function(O2, proto) {
  anObject$1(O2);
  if (!isObject$3(proto) && proto !== null)
    throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
    try {
      set = require("./_ctx")(Function.call, require("./_object-gopd").f(Object.prototype, "__proto__").set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf2(O2, proto) {
      check8(O2, proto);
      if (buggy)
        O2.__proto__ = proto;
      else
        set(O2, proto);
      return O2;
    };
  }({}, false) : void 0),
  check: check8
};
var $export$4 = _export;
$export$4($export$4.S, "Object", { setPrototypeOf: _setProto.set });
var setPrototypeOf = _core.exports.Object.setPrototypeOf;
(function(module) {
  module.exports = { "default": setPrototypeOf, __esModule: true };
})(setPrototypeOf$1);
var create$1 = { exports: {} };
var $export$3 = _export;
$export$3($export$3.S, "Object", { create: _objectCreate });
var $Object$1 = _core.exports.Object;
var create20 = function create21(P2, D2) {
  return $Object$1.create(P2, D2);
};
(function(module) {
  module.exports = { "default": create20, __esModule: true };
})(create$1);
inherits.__esModule = true;
var _setPrototypeOf$7 = setPrototypeOf$1.exports;
var _setPrototypeOf2 = _interopRequireDefault$3(_setPrototypeOf$7);
var _create = create$1.exports;
var _create2 = _interopRequireDefault$3(_create);
var _typeof2$1 = _typeof$8;
var _typeof3$1 = _interopRequireDefault$3(_typeof2$1);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
inherits.default = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3$1.default)(superClass)));
  }
  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
var _extends$1 = {};
var assign$1 = { exports: {} };
var getKeys = _objectKeys;
var gOPS = _objectGops;
var pIE = _objectPie;
var toObject$1 = _toObject;
var IObject = _iobject;
var $assign = Object.assign;
var _objectAssign = !$assign || _fails(function() {
  var A2 = {};
  var B2 = {};
  var S2 = Symbol();
  var K2 = "abcdefghijklmnopqrst";
  A2[S2] = 7;
  K2.split("").forEach(function(k) {
    B2[k] = k;
  });
  return $assign({}, A2)[S2] != 7 || Object.keys($assign({}, B2)).join("") != K2;
}) ? function assign(target, source) {
  var T2 = toObject$1(target);
  var aLen = arguments.length;
  var index8 = 1;
  var getSymbols = gOPS.f;
  var isEnum2 = pIE.f;
  while (aLen > index8) {
    var S2 = IObject(arguments[index8++]);
    var keys3 = getSymbols ? getKeys(S2).concat(getSymbols(S2)) : getKeys(S2);
    var length2 = keys3.length;
    var j = 0;
    var key;
    while (length2 > j)
      if (isEnum2.call(S2, key = keys3[j++]))
        T2[key] = S2[key];
  }
  return T2;
} : $assign;
var $export$2 = _export;
$export$2($export$2.S + $export$2.F, "Object", { assign: _objectAssign });
var assign2 = _core.exports.Object.assign;
(function(module) {
  module.exports = { "default": assign2, __esModule: true };
})(assign$1);
_extends$1.__esModule = true;
var _assign = assign$1.exports;
var _assign2 = _interopRequireDefault$2(_assign);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
_extends$1.default = _assign2.default || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var keys$1 = { exports: {} };
var $export$1 = _export;
var core = _core.exports;
var fails = _fails;
var _objectSap = function(KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export$1($export$1.S + $export$1.F * fails(function() {
    fn(1);
  }), "Object", exp);
};
var toObject = _toObject;
var $keys = _objectKeys;
_objectSap("keys", function() {
  return function keys3(it) {
    return $keys(toObject(it));
  };
});
var keys2 = _core.exports.Object.keys;
(function(module) {
  module.exports = { "default": keys2, __esModule: true };
})(keys$1);
var JSONNode = {};
var objType = {};
(function(exports) {
  exports.__esModule = true;
  var _iterator3 = iterator$1.exports;
  var _iterator22 = _interopRequireDefault2(_iterator3);
  exports["default"] = objType2;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function objType2(obj) {
    var type = Object.prototype.toString.call(obj).slice(8, -1);
    if (type === "Object" && typeof obj[_iterator22["default"]] === "function") {
      return "Iterable";
    }
    if (type === "Custom" && obj.constructor !== Object && obj instanceof Object) {
      return "Object";
    }
    return type;
  }
})(objType);
var JSONObjectNode = {};
var getOwnPropertyNames$1 = { exports: {} };
_objectSap("getOwnPropertyNames", function() {
  return _objectGopnExt.f;
});
var $Object = _core.exports.Object;
var getOwnPropertyNames4 = function getOwnPropertyNames5(it) {
  return $Object.getOwnPropertyNames(it);
};
(function(module) {
  module.exports = { "default": getOwnPropertyNames4, __esModule: true };
})(getOwnPropertyNames$1);
var JSONNestedNode = {};
var JSONArrow = {};
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var JSONArrow2 = function JSONArrow3(_ref) {
    var styling = _ref.styling, arrowStyle = _ref.arrowStyle, expanded = _ref.expanded, nodeType8 = _ref.nodeType, onClick = _ref.onClick;
    return _react22["default"].createElement(
      "div",
      (0, _extends32["default"])({}, styling("arrowContainer", arrowStyle), { onClick }),
      _react22["default"].createElement(
        "div",
        styling(["arrow", "arrowSign"], nodeType8, expanded, arrowStyle),
        "\u25B6",
        arrowStyle === "double" && _react22["default"].createElement(
          "div",
          styling(["arrowSign", "arrowSignInner"]),
          "\u25B6"
        )
      )
    );
  };
  JSONArrow2.propTypes = {
    styling: _propTypes22["default"].func.isRequired,
    arrowStyle: _propTypes22["default"].oneOf(["single", "double"]),
    expanded: _propTypes22["default"].bool.isRequired,
    nodeType: _propTypes22["default"].string.isRequired,
    onClick: _propTypes22["default"].func.isRequired
  };
  JSONArrow2.defaultProps = {
    arrowStyle: "single"
  };
  exports["default"] = JSONArrow2;
})(JSONArrow);
var getCollectionEntries = {};
var getIterator$1 = { exports: {} };
var cof = _cof;
var TAG = _wks.exports("toStringTag");
var ARG = cof(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (e) {
  }
};
var _classof = function(it) {
  var O2, T2, B2;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T2 = tryGet(O2 = Object(it), TAG)) == "string" ? T2 : ARG ? cof(O2) : (B2 = cof(O2)) == "Object" && typeof O2.callee == "function" ? "Arguments" : B2;
};
var classof$1 = _classof;
var ITERATOR$1 = _wks.exports("iterator");
var Iterators$1 = _iterators;
var core_getIteratorMethod = _core.exports.getIteratorMethod = function(it) {
  if (it != void 0)
    return it[ITERATOR$1] || it["@@iterator"] || Iterators$1[classof$1(it)];
};
var anObject = _anObject;
var get3 = core_getIteratorMethod;
var core_getIterator = _core.exports.getIterator = function(it) {
  var iterFn = get3(it);
  if (typeof iterFn != "function")
    throw TypeError(it + " is not iterable!");
  return anObject(iterFn.call(it));
};
var getIterator = core_getIterator;
(function(module) {
  module.exports = { "default": getIterator, __esModule: true };
})(getIterator$1);
(function(exports) {
  exports.__esModule = true;
  var _getIterator22 = getIterator$1.exports;
  var _getIterator32 = _interopRequireDefault2(_getIterator22);
  var _getOwnPropertyNames = getOwnPropertyNames$1.exports;
  var _getOwnPropertyNames2 = _interopRequireDefault2(_getOwnPropertyNames);
  var _keys3 = keys$1.exports;
  var _keys22 = _interopRequireDefault2(_keys3);
  exports["default"] = getCollectionEntries2;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function getLength(type, collection) {
    if (type === "Object") {
      return (0, _keys22["default"])(collection).length;
    } else if (type === "Array") {
      return collection.length;
    }
    return Infinity;
  }
  function isIterableMap(collection) {
    return typeof collection.set === "function";
  }
  function getEntries(type, collection, sortObjectKeys) {
    var from12 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var to = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Infinity;
    var res = void 0;
    if (type === "Object") {
      var keys3 = (0, _getOwnPropertyNames2["default"])(collection);
      if (sortObjectKeys) {
        keys3.sort(sortObjectKeys === true ? void 0 : sortObjectKeys);
      }
      keys3 = keys3.slice(from12, to + 1);
      res = {
        entries: keys3.map(function(key) {
          return { key, value: collection[key] };
        })
      };
    } else if (type === "Array") {
      res = {
        entries: collection.slice(from12, to + 1).map(function(val, idx2) {
          return { key: idx2 + from12, value: val };
        })
      };
    } else {
      var idx = 0;
      var entries = [];
      var done3 = true;
      var isMap = isIterableMap(collection);
      for (var _iterator3 = collection, _isArray2 = Array.isArray(_iterator3), _i = 0, _iterator3 = _isArray2 ? _iterator3 : (0, _getIterator32["default"])(_iterator3); ; ) {
        var _ref;
        if (_isArray2) {
          if (_i >= _iterator3.length)
            break;
          _ref = _iterator3[_i++];
        } else {
          _i = _iterator3.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var item = _ref;
        if (idx > to) {
          done3 = false;
          break;
        }
        if (from12 <= idx) {
          if (isMap && Array.isArray(item)) {
            if (typeof item[0] === "string" || typeof item[0] === "number") {
              entries.push({ key: item[0], value: item[1] });
            } else {
              entries.push({
                key: "[entry " + idx + "]",
                value: {
                  "[key]": item[0],
                  "[value]": item[1]
                }
              });
            }
          } else {
            entries.push({ key: idx, value: item });
          }
        }
        idx++;
      }
      res = {
        hasMore: !done3,
        entries
      };
    }
    return res;
  }
  function getRanges(from12, to, limit) {
    var ranges = [];
    while (to - from12 > limit * limit) {
      limit = limit * limit;
    }
    for (var i = from12; i <= to; i += limit) {
      ranges.push({ from: i, to: Math.min(to, i + limit - 1) });
    }
    return ranges;
  }
  function getCollectionEntries2(type, collection, sortObjectKeys, limit) {
    var from12 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var to = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Infinity;
    var getEntriesBound = getEntries.bind(null, type, collection, sortObjectKeys);
    if (!limit) {
      return getEntriesBound().entries;
    }
    var isSubset = to < Infinity;
    var length2 = Math.min(to - from12, getLength(type, collection));
    if (type !== "Iterable") {
      if (length2 <= limit || limit < 7) {
        return getEntriesBound(from12, to).entries;
      }
    } else {
      if (length2 <= limit && !isSubset) {
        return getEntriesBound(from12, to).entries;
      }
    }
    var limitedEntries = void 0;
    if (type === "Iterable") {
      var _getEntriesBound = getEntriesBound(from12, from12 + limit - 1), hasMore = _getEntriesBound.hasMore, entries = _getEntriesBound.entries;
      limitedEntries = hasMore ? [].concat(entries, getRanges(from12 + limit, from12 + 2 * limit - 1, limit)) : entries;
    } else {
      limitedEntries = isSubset ? getRanges(from12, to, limit) : [].concat(getEntriesBound(0, limit - 5).entries, getRanges(limit - 4, length2 - 5, limit), getEntriesBound(length2 - 4, length2 - 1).entries);
    }
    return limitedEntries;
  }
})(getCollectionEntries);
var ItemRange = {};
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _classCallCheck2 = classCallCheck;
  var _classCallCheck3 = _interopRequireDefault2(_classCallCheck2);
  var _possibleConstructorReturn2 = possibleConstructorReturn;
  var _possibleConstructorReturn3 = _interopRequireDefault2(_possibleConstructorReturn2);
  var _inherits2 = inherits;
  var _inherits3 = _interopRequireDefault2(_inherits2);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _JSONArrow = JSONArrow;
  var _JSONArrow2 = _interopRequireDefault2(_JSONArrow);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var ItemRange2 = function(_React$Component) {
    (0, _inherits3["default"])(ItemRange3, _React$Component);
    function ItemRange3(props) {
      (0, _classCallCheck3["default"])(this, ItemRange3);
      var _this = (0, _possibleConstructorReturn3["default"])(this, _React$Component.call(this, props));
      _this.state = { expanded: false };
      _this.handleClick = _this.handleClick.bind(_this);
      return _this;
    }
    ItemRange3.prototype.render = function render4() {
      var _props = this.props, styling = _props.styling, from12 = _props.from, to = _props.to, renderChildNodes = _props.renderChildNodes, nodeType8 = _props.nodeType;
      return this.state.expanded ? _react22["default"].createElement(
        "div",
        styling("itemRange", this.state.expanded),
        renderChildNodes(this.props, from12, to)
      ) : _react22["default"].createElement(
        "div",
        (0, _extends32["default"])({}, styling("itemRange", this.state.expanded), {
          onClick: this.handleClick
        }),
        _react22["default"].createElement(_JSONArrow2["default"], {
          nodeType: nodeType8,
          styling,
          expanded: false,
          onClick: this.handleClick,
          arrowStyle: "double"
        }),
        from12 + " ... " + to
      );
    };
    ItemRange3.prototype.handleClick = function handleClick2() {
      this.setState({ expanded: !this.state.expanded });
    };
    return ItemRange3;
  }(_react22["default"].Component);
  ItemRange2.propTypes = {
    styling: _propTypes22["default"].func.isRequired,
    from: _propTypes22["default"].number.isRequired,
    to: _propTypes22["default"].number.isRequired,
    renderChildNodes: _propTypes22["default"].func.isRequired,
    nodeType: _propTypes22["default"].string.isRequired
  };
  exports["default"] = ItemRange2;
})(ItemRange);
(function(exports) {
  exports.__esModule = true;
  var _keys3 = keys$1.exports;
  var _keys22 = _interopRequireDefault2(_keys3);
  var _classCallCheck2 = classCallCheck;
  var _classCallCheck3 = _interopRequireDefault2(_classCallCheck2);
  var _possibleConstructorReturn2 = possibleConstructorReturn;
  var _possibleConstructorReturn3 = _interopRequireDefault2(_possibleConstructorReturn2);
  var _inherits2 = inherits;
  var _inherits3 = _interopRequireDefault2(_inherits2);
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _JSONArrow = JSONArrow;
  var _JSONArrow2 = _interopRequireDefault2(_JSONArrow);
  var _getCollectionEntries = getCollectionEntries;
  var _getCollectionEntries2 = _interopRequireDefault2(_getCollectionEntries);
  var _JSONNode = JSONNode;
  var _JSONNode2 = _interopRequireDefault2(_JSONNode);
  var _ItemRange = ItemRange;
  var _ItemRange2 = _interopRequireDefault2(_ItemRange);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function renderChildNodes(props, from12, to) {
    var nodeType8 = props.nodeType, data = props.data, collectionLimit = props.collectionLimit, circularCache = props.circularCache, keyPath = props.keyPath, postprocessValue2 = props.postprocessValue, sortObjectKeys = props.sortObjectKeys;
    var childNodes = [];
    (0, _getCollectionEntries2["default"])(nodeType8, data, sortObjectKeys, collectionLimit, from12, to).forEach(function(entry) {
      if (entry.to) {
        childNodes.push(_react22["default"].createElement(_ItemRange2["default"], (0, _extends32["default"])({}, props, {
          key: "ItemRange--" + entry.from + "-" + entry.to,
          from: entry.from,
          to: entry.to,
          renderChildNodes
        })));
      } else {
        var key = entry.key, value = entry.value;
        var isCircular = circularCache.indexOf(value) !== -1;
        var node18 = _react22["default"].createElement(_JSONNode2["default"], (0, _extends32["default"])({}, props, { postprocessValue: postprocessValue2, collectionLimit }, {
          key: "Node--" + key,
          keyPath: [key].concat(keyPath),
          value: postprocessValue2(value),
          circularCache: [].concat(circularCache, [value]),
          isCircular,
          hideRoot: false
        }));
        if (node18 !== false) {
          childNodes.push(node18);
        }
      }
    });
    return childNodes;
  }
  function getStateFromProps(props) {
    var expanded = props.shouldExpandNode && !props.isCircular ? props.shouldExpandNode(props.keyPath, props.data, props.level) : false;
    return {
      expanded
    };
  }
  var JSONNestedNode2 = function(_React$Component) {
    (0, _inherits3["default"])(JSONNestedNode3, _React$Component);
    function JSONNestedNode3(props) {
      (0, _classCallCheck3["default"])(this, JSONNestedNode3);
      var _this = (0, _possibleConstructorReturn3["default"])(this, _React$Component.call(this, props));
      _this.handleClick = function() {
        if (_this.props.expandable) {
          _this.setState({ expanded: !_this.state.expanded });
        }
      };
      _this.state = getStateFromProps(props);
      return _this;
    }
    JSONNestedNode3.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var nextState = getStateFromProps(nextProps);
      if (getStateFromProps(this.props).expanded !== nextState.expanded) {
        this.setState(nextState);
      }
    };
    JSONNestedNode3.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      var _this2 = this;
      return !!(0, _keys22["default"])(nextProps).find(function(key) {
        return key !== "circularCache" && (key === "keyPath" ? nextProps[key].join("/") !== _this2.props[key].join("/") : nextProps[key] !== _this2.props[key]);
      }) || nextState.expanded !== this.state.expanded;
    };
    JSONNestedNode3.prototype.render = function render4() {
      var _props = this.props, getItemString2 = _props.getItemString, nodeTypeIndicator = _props.nodeTypeIndicator, nodeType8 = _props.nodeType, data = _props.data, hideRoot = _props.hideRoot, createItemString = _props.createItemString, styling = _props.styling, collectionLimit = _props.collectionLimit, keyPath = _props.keyPath, labelRenderer2 = _props.labelRenderer, expandable = _props.expandable;
      var expanded = this.state.expanded;
      var renderedChildren = expanded || hideRoot && this.props.level === 0 ? renderChildNodes((0, _extends32["default"])({}, this.props, { level: this.props.level + 1 })) : null;
      var itemType = _react22["default"].createElement(
        "span",
        styling("nestedNodeItemType", expanded),
        nodeTypeIndicator
      );
      var renderedItemString = getItemString2(nodeType8, data, itemType, createItemString(data, collectionLimit));
      var stylingArgs = [keyPath, nodeType8, expanded, expandable];
      return hideRoot ? _react22["default"].createElement(
        "li",
        styling.apply(void 0, ["rootNode"].concat(stylingArgs)),
        _react22["default"].createElement(
          "ul",
          styling.apply(void 0, ["rootNodeChildren"].concat(stylingArgs)),
          renderedChildren
        )
      ) : _react22["default"].createElement(
        "li",
        styling.apply(void 0, ["nestedNode"].concat(stylingArgs)),
        expandable && _react22["default"].createElement(_JSONArrow2["default"], {
          styling,
          nodeType: nodeType8,
          expanded,
          onClick: this.handleClick
        }),
        _react22["default"].createElement(
          "label",
          (0, _extends32["default"])({}, styling.apply(void 0, [["label", "nestedNodeLabel"]].concat(stylingArgs)), {
            onClick: this.handleClick
          }),
          labelRenderer2.apply(void 0, stylingArgs)
        ),
        _react22["default"].createElement(
          "span",
          (0, _extends32["default"])({}, styling.apply(void 0, ["nestedNodeItemString"].concat(stylingArgs)), {
            onClick: this.handleClick
          }),
          renderedItemString
        ),
        _react22["default"].createElement(
          "ul",
          styling.apply(void 0, ["nestedNodeChildren"].concat(stylingArgs)),
          renderedChildren
        )
      );
    };
    return JSONNestedNode3;
  }(_react22["default"].Component);
  JSONNestedNode2.propTypes = {
    getItemString: _propTypes22["default"].func.isRequired,
    nodeTypeIndicator: _propTypes22["default"].any,
    nodeType: _propTypes22["default"].string.isRequired,
    data: _propTypes22["default"].any,
    hideRoot: _propTypes22["default"].bool.isRequired,
    createItemString: _propTypes22["default"].func.isRequired,
    styling: _propTypes22["default"].func.isRequired,
    collectionLimit: _propTypes22["default"].number,
    keyPath: _propTypes22["default"].arrayOf(_propTypes22["default"].oneOfType([_propTypes22["default"].string, _propTypes22["default"].number])).isRequired,
    labelRenderer: _propTypes22["default"].func.isRequired,
    shouldExpandNode: _propTypes22["default"].func,
    level: _propTypes22["default"].number.isRequired,
    sortObjectKeys: _propTypes22["default"].oneOfType([_propTypes22["default"].func, _propTypes22["default"].bool]),
    isCircular: _propTypes22["default"].bool,
    expandable: _propTypes22["default"].bool
  };
  JSONNestedNode2.defaultProps = {
    data: [],
    circularCache: [],
    level: 0,
    expandable: true
  };
  exports["default"] = JSONNestedNode2;
})(JSONNestedNode);
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _objectWithoutProperties2 = objectWithoutProperties;
  var _objectWithoutProperties3 = _interopRequireDefault2(_objectWithoutProperties2);
  var _getOwnPropertyNames = getOwnPropertyNames$1.exports;
  var _getOwnPropertyNames2 = _interopRequireDefault2(_getOwnPropertyNames);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _JSONNestedNode = JSONNestedNode;
  var _JSONNestedNode2 = _interopRequireDefault2(_JSONNestedNode);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function createItemString(data) {
    var len = (0, _getOwnPropertyNames2["default"])(data).length;
    return len + " " + (len !== 1 ? "keys" : "key");
  }
  var JSONObjectNode2 = function JSONObjectNode3(_ref) {
    var data = _ref.data, props = (0, _objectWithoutProperties3["default"])(_ref, ["data"]);
    return _react22["default"].createElement(_JSONNestedNode2["default"], (0, _extends32["default"])({}, props, {
      data,
      nodeType: "Object",
      nodeTypeIndicator: props.nodeType === "Error" ? "Error()" : "{}",
      createItemString,
      expandable: (0, _getOwnPropertyNames2["default"])(data).length > 0
    }));
  };
  JSONObjectNode2.propTypes = {
    data: _propTypes22["default"].object,
    nodeType: _propTypes22["default"].string
  };
  exports["default"] = JSONObjectNode2;
})(JSONObjectNode);
var JSONArrayNode = {};
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _objectWithoutProperties2 = objectWithoutProperties;
  var _objectWithoutProperties3 = _interopRequireDefault2(_objectWithoutProperties2);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _JSONNestedNode = JSONNestedNode;
  var _JSONNestedNode2 = _interopRequireDefault2(_JSONNestedNode);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function createItemString(data) {
    return data.length + " " + (data.length !== 1 ? "items" : "item");
  }
  var JSONArrayNode2 = function JSONArrayNode3(_ref) {
    var data = _ref.data, props = (0, _objectWithoutProperties3["default"])(_ref, ["data"]);
    return _react22["default"].createElement(_JSONNestedNode2["default"], (0, _extends32["default"])({}, props, {
      data,
      nodeType: "Array",
      nodeTypeIndicator: "[]",
      createItemString,
      expandable: data.length > 0
    }));
  };
  JSONArrayNode2.propTypes = {
    data: _propTypes22["default"].array
  };
  exports["default"] = JSONArrayNode2;
})(JSONArrayNode);
var JSONIterableNode = {};
var isSafeInteger$1 = { exports: {} };
var isObject$2 = _isObject;
var floor = Math.floor;
var _isInteger = function isInteger(it) {
  return !isObject$2(it) && isFinite(it) && floor(it) === it;
};
var $export = _export;
var isInteger2 = _isInteger;
var abs = Math.abs;
$export($export.S, "Number", {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger2(number) && abs(number) <= 9007199254740991;
  }
});
var isSafeInteger2 = _core.exports.Number.isSafeInteger;
(function(module) {
  module.exports = { "default": isSafeInteger2, __esModule: true };
})(isSafeInteger$1);
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _objectWithoutProperties2 = objectWithoutProperties;
  var _objectWithoutProperties3 = _interopRequireDefault2(_objectWithoutProperties2);
  var _getIterator22 = getIterator$1.exports;
  var _getIterator32 = _interopRequireDefault2(_getIterator22);
  var _isSafeInteger = isSafeInteger$1.exports;
  var _isSafeInteger2 = _interopRequireDefault2(_isSafeInteger);
  exports["default"] = JSONIterableNode2;
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _JSONNestedNode = JSONNestedNode;
  var _JSONNestedNode2 = _interopRequireDefault2(_JSONNestedNode);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function createItemString(data, limit) {
    var count = 0;
    var hasMore = false;
    if ((0, _isSafeInteger2["default"])(data.size)) {
      count = data.size;
    } else {
      for (var _iterator3 = data, _isArray2 = Array.isArray(_iterator3), _i = 0, _iterator3 = _isArray2 ? _iterator3 : (0, _getIterator32["default"])(_iterator3); ; ) {
        if (_isArray2) {
          if (_i >= _iterator3.length)
            break;
          _iterator3[_i++];
        } else {
          _i = _iterator3.next();
          if (_i.done)
            break;
          _i.value;
        }
        if (limit && count + 1 > limit) {
          hasMore = true;
          break;
        }
        count += 1;
      }
    }
    return (hasMore ? ">" : "") + count + " " + (count !== 1 ? "entries" : "entry");
  }
  function JSONIterableNode2(_ref2) {
    var props = (0, _objectWithoutProperties3["default"])(_ref2, []);
    return _react22["default"].createElement(_JSONNestedNode2["default"], (0, _extends32["default"])({}, props, {
      nodeType: "Iterable",
      nodeTypeIndicator: "()",
      createItemString
    }));
  }
})(JSONIterableNode);
var JSONValueNode = {};
(function(exports) {
  exports.__esModule = true;
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var JSONValueNode2 = function JSONValueNode3(_ref) {
    var nodeType8 = _ref.nodeType, styling = _ref.styling, labelRenderer2 = _ref.labelRenderer, keyPath = _ref.keyPath, valueRenderer2 = _ref.valueRenderer, value = _ref.value, valueGetter = _ref.valueGetter;
    return _react22["default"].createElement(
      "li",
      styling("value", nodeType8, keyPath),
      _react22["default"].createElement(
        "label",
        styling(["label", "valueLabel"], nodeType8, keyPath),
        labelRenderer2(keyPath, nodeType8, false, false)
      ),
      _react22["default"].createElement(
        "span",
        styling("valueText", nodeType8, keyPath),
        valueRenderer2.apply(void 0, [valueGetter(value), value].concat(keyPath))
      )
    );
  };
  JSONValueNode2.propTypes = {
    nodeType: _propTypes22["default"].string.isRequired,
    styling: _propTypes22["default"].func.isRequired,
    labelRenderer: _propTypes22["default"].func.isRequired,
    keyPath: _propTypes22["default"].arrayOf(_propTypes22["default"].oneOfType([_propTypes22["default"].string, _propTypes22["default"].number])).isRequired,
    valueRenderer: _propTypes22["default"].func.isRequired,
    value: _propTypes22["default"].any,
    valueGetter: _propTypes22["default"].func
  };
  JSONValueNode2.defaultProps = {
    valueGetter: function valueGetter(value) {
      return value;
    }
  };
  exports["default"] = JSONValueNode2;
})(JSONValueNode);
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _objectWithoutProperties2 = objectWithoutProperties;
  var _objectWithoutProperties3 = _interopRequireDefault2(_objectWithoutProperties2);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _objType = objType;
  var _objType2 = _interopRequireDefault2(_objType);
  var _JSONObjectNode = JSONObjectNode;
  var _JSONObjectNode2 = _interopRequireDefault2(_JSONObjectNode);
  var _JSONArrayNode = JSONArrayNode;
  var _JSONArrayNode2 = _interopRequireDefault2(_JSONArrayNode);
  var _JSONIterableNode = JSONIterableNode;
  var _JSONIterableNode2 = _interopRequireDefault2(_JSONIterableNode);
  var _JSONValueNode = JSONValueNode;
  var _JSONValueNode2 = _interopRequireDefault2(_JSONValueNode);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var JSONNode2 = function JSONNode3(_ref) {
    var getItemString2 = _ref.getItemString, keyPath = _ref.keyPath, labelRenderer2 = _ref.labelRenderer, styling = _ref.styling, value = _ref.value, valueRenderer2 = _ref.valueRenderer, isCustomNode = _ref.isCustomNode, rest = (0, _objectWithoutProperties3["default"])(_ref, ["getItemString", "keyPath", "labelRenderer", "styling", "value", "valueRenderer", "isCustomNode"]);
    var nodeType8 = isCustomNode(value) ? "Custom" : (0, _objType2["default"])(value);
    var simpleNodeProps = {
      getItemString: getItemString2,
      key: keyPath[0],
      keyPath,
      labelRenderer: labelRenderer2,
      nodeType: nodeType8,
      styling,
      value,
      valueRenderer: valueRenderer2
    };
    var nestedNodeProps = (0, _extends32["default"])({}, rest, simpleNodeProps, {
      data: value,
      isCustomNode
    });
    switch (nodeType8) {
      case "Object":
      case "Error":
      case "WeakMap":
      case "WeakSet":
        return _react22["default"].createElement(_JSONObjectNode2["default"], nestedNodeProps);
      case "Array":
        return _react22["default"].createElement(_JSONArrayNode2["default"], nestedNodeProps);
      case "Iterable":
      case "Map":
      case "Set":
        return _react22["default"].createElement(_JSONIterableNode2["default"], nestedNodeProps);
      case "String":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, { valueGetter: function valueGetter(raw) {
          return '"' + raw + '"';
        } }));
      case "Number":
        return _react22["default"].createElement(_JSONValueNode2["default"], simpleNodeProps);
      case "Boolean":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, {
          valueGetter: function valueGetter(raw) {
            return raw ? "true" : "false";
          }
        }));
      case "Date":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, {
          valueGetter: function valueGetter(raw) {
            return raw.toISOString();
          }
        }));
      case "Null":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, { valueGetter: function valueGetter() {
          return "null";
        } }));
      case "Undefined":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, { valueGetter: function valueGetter() {
          return "undefined";
        } }));
      case "Function":
      case "Symbol":
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, {
          valueGetter: function valueGetter(raw) {
            return raw.toString();
          }
        }));
      case "Custom":
        return _react22["default"].createElement(_JSONValueNode2["default"], simpleNodeProps);
      default:
        return _react22["default"].createElement(_JSONValueNode2["default"], (0, _extends32["default"])({}, simpleNodeProps, { valueGetter: function valueGetter(raw) {
          return "<" + nodeType8 + ">";
        } }));
    }
  };
  JSONNode2.propTypes = {
    getItemString: _propTypes22["default"].func.isRequired,
    keyPath: _propTypes22["default"].arrayOf(_propTypes22["default"].oneOfType([_propTypes22["default"].string, _propTypes22["default"].number])).isRequired,
    labelRenderer: _propTypes22["default"].func.isRequired,
    styling: _propTypes22["default"].func.isRequired,
    value: _propTypes22["default"].any,
    valueRenderer: _propTypes22["default"].func.isRequired,
    isCustomNode: _propTypes22["default"].func.isRequired
  };
  exports["default"] = JSONNode2;
})(JSONNode);
var createStylingFromTheme = {};
var lib = {};
var slicedToArray = {};
var isIterable$1 = { exports: {} };
var classof = _classof;
var ITERATOR = _wks.exports("iterator");
var Iterators = _iterators;
var core_isIterable = _core.exports.isIterable = function(it) {
  var O2 = Object(it);
  return O2[ITERATOR] !== void 0 || "@@iterator" in O2 || Iterators.hasOwnProperty(classof(O2));
};
var isIterable = core_isIterable;
(function(module) {
  module.exports = { "default": isIterable, __esModule: true };
})(isIterable$1);
slicedToArray.__esModule = true;
var _isIterable2 = isIterable$1.exports;
var _isIterable3 = _interopRequireDefault$1(_isIterable2);
var _getIterator2 = getIterator$1.exports;
var _getIterator3 = _interopRequireDefault$1(_getIterator2);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
slicedToArray.default = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err8) {
      _d = true;
      _e = err8;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var FUNC_ERROR_TEXT$1 = "Expected a function";
var PLACEHOLDER = "__lodash_placeholder__";
var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER$1 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
var wrapFlags = [
  ["ary", ARY_FLAG],
  ["bind", BIND_FLAG],
  ["bindKey", BIND_KEY_FLAG],
  ["curry", CURRY_FLAG],
  ["curryRight", CURRY_RIGHT_FLAG],
  ["flip", FLIP_FLAG],
  ["partial", PARTIAL_FLAG],
  ["partialRight", PARTIAL_RIGHT_FLAG],
  ["rearg", REARG_FLAG]
];
var funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reTrim = /^\s+|\s+$/g;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsOctal = /^0o[0-7]+$/i;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeParseInt = parseInt;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function arrayEach(array, iteratee) {
  var index8 = -1, length2 = array ? array.length : 0;
  while (++index8 < length2) {
    if (iteratee(array[index8], index8, array) === false) {
      break;
    }
  }
  return array;
}
function arrayIncludes(array, value) {
  var length2 = array ? array.length : 0;
  return !!length2 && baseIndexOf(array, value, 0) > -1;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index8 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index8-- : ++index8 < length2) {
    if (predicate(array[index8], index8, array)) {
      return index8;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index8 = fromIndex - 1, length2 = array.length;
  while (++index8 < length2) {
    if (array[index8] === value) {
      return index8;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function countHolders(array, placeholder) {
  var length2 = array.length, result2 = 0;
  while (length2--) {
    if (array[length2] === placeholder) {
      result2++;
    }
  }
  return result2;
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result2 = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result2 = !!(value + "");
    } catch (e) {
    }
  }
  return result2;
}
function replaceHolders(array, placeholder) {
  var index8 = -1, length2 = array.length, resIndex = 0, result2 = [];
  while (++index8 < length2) {
    var value = array[index8];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index8] = PLACEHOLDER;
      result2[resIndex++] = index8;
    }
  }
  return result2;
}
var funcProto = Function.prototype, objectProto$1 = Object.prototype;
var coreJsData = root$1["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var objectToString$1 = objectProto$1.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var objectCreate = Object.create;
var nativeMax$1 = Math.max, nativeMin = Math.min;
var defineProperty3 = function() {
  var func = getNative(Object, "defineProperty"), name = getNative.name;
  return name && name.length > 2 ? func : void 0;
}();
function baseCreate(proto) {
  return isObject$1(proto) ? objectCreate(proto) : {};
}
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$1(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$1(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset2 = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset2 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
function copyArray(source, array) {
  var index8 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index8 < length2) {
    array[index8] = source[index8];
  }
  return array;
}
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
  function wrapper() {
    var fn = this && this !== root$1 && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject$1(result2) ? result2 : thisBinding;
  };
}
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index8 = length2, placeholder = getHolder(wrapper);
    while (index8--) {
      args[index8] = arguments[index8];
    }
    var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
    length2 -= holders.length;
    if (length2 < arity) {
      return createRecurry(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length2
      );
    }
    var fn = this && this !== root$1 && this instanceof wrapper ? Ctor : func;
    return apply$1(fn, this, args);
  }
  return wrapper;
}
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index8 = length2;
    while (index8--) {
      args[index8] = arguments[index8];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length2 -= holdersCount;
    if (isCurried && length2 < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary,
        arity - length2
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length2 = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length2 > 1) {
      args.reverse();
    }
    if (isAry && ary < length2) {
      args.length = ary;
    }
    if (this && this !== root$1 && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root$1 && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply$1(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
  }
  var result2 = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
  result2.placeholder = placeholder;
  return setWrapToString(result2, func, bitmask);
}
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var length2 = partials ? partials.length : 0;
  if (!length2) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = void 0;
  }
  ary = ary === void 0 ? ary : nativeMax$1(toInteger(ary), 0);
  arity = arity === void 0 ? arity : toInteger(arity);
  length2 -= holders ? holders.length : 0;
  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary,
    arity
  ];
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax$1(newData[9] - length2, 0);
  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result2 = createBind(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result2 = createCurry(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result2 = createPartial(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid.apply(void 0, newData);
  }
  return setWrapToString(result2, func, bitmask);
}
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function getWrapDetails(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
function insertWrapDetails(source, details) {
  var length2 = details.length, lastIndex = length2 - 1;
  details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length2 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
function isIndex(value, length2) {
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function reorder(array, indexes) {
  var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
  while (length2--) {
    var index8 = indexes[length2];
    array[length2] = isIndex(index8, arrLength) ? oldArray[index8] : void 0;
  }
  return array;
}
var setWrapToString = !defineProperty3 ? identity : function(wrapper, reference, bitmask) {
  var source = reference + "";
  return defineProperty3(wrapper, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
  });
};
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap(func, CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
function isFunction$1(value) {
  var tag = isObject$1(value) ? objectToString$1.call(value) : "";
  return tag == funcTag$1 || tag == genTag$1;
}
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag;
}
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result2 = toFinite(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function constant(value) {
  return function() {
    return value;
  };
}
function identity(value) {
  return value;
}
curry.placeholder = {};
var lodash_curry = curry;
var threezerotwofour = {
  scheme: "threezerotwofour",
  author: "jan t. sott (http://github.com/idleberg)",
  base00: "#090300",
  base01: "#3a3432",
  base02: "#4a4543",
  base03: "#5c5855",
  base04: "#807d7c",
  base05: "#a5a2a2",
  base06: "#d6d5d4",
  base07: "#f7f7f7",
  base08: "#db2d20",
  base09: "#e8bbd0",
  base0A: "#fded02",
  base0B: "#01a252",
  base0C: "#b5e4f4",
  base0D: "#01a0e4",
  base0E: "#a16a94",
  base0F: "#cdab53"
};
var apathy = {
  scheme: "apathy",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#031A16",
  base01: "#0B342D",
  base02: "#184E45",
  base03: "#2B685E",
  base04: "#5F9C92",
  base05: "#81B5AC",
  base06: "#A7CEC8",
  base07: "#D2E7E4",
  base08: "#3E9688",
  base09: "#3E7996",
  base0A: "#3E4C96",
  base0B: "#883E96",
  base0C: "#963E4C",
  base0D: "#96883E",
  base0E: "#4C963E",
  base0F: "#3E965B"
};
var ashes = {
  scheme: "ashes",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#1C2023",
  base01: "#393F45",
  base02: "#565E65",
  base03: "#747C84",
  base04: "#ADB3BA",
  base05: "#C7CCD1",
  base06: "#DFE2E5",
  base07: "#F3F4F5",
  base08: "#C7AE95",
  base09: "#C7C795",
  base0A: "#AEC795",
  base0B: "#95C7AE",
  base0C: "#95AEC7",
  base0D: "#AE95C7",
  base0E: "#C795AE",
  base0F: "#C79595"
};
var atelierDune = {
  scheme: "atelier dune",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune)",
  base00: "#20201d",
  base01: "#292824",
  base02: "#6e6b5e",
  base03: "#7d7a68",
  base04: "#999580",
  base05: "#a6a28c",
  base06: "#e8e4cf",
  base07: "#fefbec",
  base08: "#d73737",
  base09: "#b65611",
  base0A: "#cfb017",
  base0B: "#60ac39",
  base0C: "#1fad83",
  base0D: "#6684e1",
  base0E: "#b854d4",
  base0F: "#d43552"
};
var atelierForest = {
  scheme: "atelier forest",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest)",
  base00: "#1b1918",
  base01: "#2c2421",
  base02: "#68615e",
  base03: "#766e6b",
  base04: "#9c9491",
  base05: "#a8a19f",
  base06: "#e6e2e0",
  base07: "#f1efee",
  base08: "#f22c40",
  base09: "#df5320",
  base0A: "#d5911a",
  base0B: "#5ab738",
  base0C: "#00ad9c",
  base0D: "#407ee7",
  base0E: "#6666ea",
  base0F: "#c33ff3"
};
var atelierHeath = {
  scheme: "atelier heath",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/heath)",
  base00: "#1b181b",
  base01: "#292329",
  base02: "#695d69",
  base03: "#776977",
  base04: "#9e8f9e",
  base05: "#ab9bab",
  base06: "#d8cad8",
  base07: "#f7f3f7",
  base08: "#ca402b",
  base09: "#a65926",
  base0A: "#bb8a35",
  base0B: "#379a37",
  base0C: "#159393",
  base0D: "#516aec",
  base0E: "#7b59c0",
  base0F: "#cc33cc"
};
var atelierLakeside = {
  scheme: "atelier lakeside",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/lakeside/)",
  base00: "#161b1d",
  base01: "#1f292e",
  base02: "#516d7b",
  base03: "#5a7b8c",
  base04: "#7195a8",
  base05: "#7ea2b4",
  base06: "#c1e4f6",
  base07: "#ebf8ff",
  base08: "#d22d72",
  base09: "#935c25",
  base0A: "#8a8a0f",
  base0B: "#568c3b",
  base0C: "#2d8f6f",
  base0D: "#257fad",
  base0E: "#5d5db1",
  base0F: "#b72dd2"
};
var atelierSeaside = {
  scheme: "atelier seaside",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/seaside/)",
  base00: "#131513",
  base01: "#242924",
  base02: "#5e6e5e",
  base03: "#687d68",
  base04: "#809980",
  base05: "#8ca68c",
  base06: "#cfe8cf",
  base07: "#f0fff0",
  base08: "#e6193c",
  base09: "#87711d",
  base0A: "#c3c322",
  base0B: "#29a329",
  base0C: "#1999b3",
  base0D: "#3d62f5",
  base0E: "#ad2bee",
  base0F: "#e619c3"
};
var bespin = {
  scheme: "bespin",
  author: "jan t. sott",
  base00: "#28211c",
  base01: "#36312e",
  base02: "#5e5d5c",
  base03: "#666666",
  base04: "#797977",
  base05: "#8a8986",
  base06: "#9d9b97",
  base07: "#baae9e",
  base08: "#cf6a4c",
  base09: "#cf7d34",
  base0A: "#f9ee98",
  base0B: "#54be0d",
  base0C: "#afc4db",
  base0D: "#5ea6ea",
  base0E: "#9b859d",
  base0F: "#937121"
};
var brewer = {
  scheme: "brewer",
  author: "timoth\xE9e poisot (http://github.com/tpoisot)",
  base00: "#0c0d0e",
  base01: "#2e2f30",
  base02: "#515253",
  base03: "#737475",
  base04: "#959697",
  base05: "#b7b8b9",
  base06: "#dadbdc",
  base07: "#fcfdfe",
  base08: "#e31a1c",
  base09: "#e6550d",
  base0A: "#dca060",
  base0B: "#31a354",
  base0C: "#80b1d3",
  base0D: "#3182bd",
  base0E: "#756bb1",
  base0F: "#b15928"
};
var bright = {
  scheme: "bright",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#000000",
  base01: "#303030",
  base02: "#505050",
  base03: "#b0b0b0",
  base04: "#d0d0d0",
  base05: "#e0e0e0",
  base06: "#f5f5f5",
  base07: "#ffffff",
  base08: "#fb0120",
  base09: "#fc6d24",
  base0A: "#fda331",
  base0B: "#a1c659",
  base0C: "#76c7b7",
  base0D: "#6fb3d2",
  base0E: "#d381c3",
  base0F: "#be643c"
};
var chalk = {
  scheme: "chalk",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#151515",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#b0b0b0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#f5f5f5",
  base08: "#fb9fb1",
  base09: "#eda987",
  base0A: "#ddb26f",
  base0B: "#acc267",
  base0C: "#12cfc0",
  base0D: "#6fc2ef",
  base0E: "#e1a3ee",
  base0F: "#deaf8f"
};
var codeschool = {
  scheme: "codeschool",
  author: "brettof86",
  base00: "#232c31",
  base01: "#1c3657",
  base02: "#2a343a",
  base03: "#3f4944",
  base04: "#84898c",
  base05: "#9ea7a6",
  base06: "#a7cfa3",
  base07: "#b5d8f6",
  base08: "#2a5491",
  base09: "#43820d",
  base0A: "#a03b1e",
  base0B: "#237986",
  base0C: "#b02f30",
  base0D: "#484d79",
  base0E: "#c59820",
  base0F: "#c98344"
};
var colors = {
  scheme: "colors",
  author: "mrmrs (http://clrs.cc)",
  base00: "#111111",
  base01: "#333333",
  base02: "#555555",
  base03: "#777777",
  base04: "#999999",
  base05: "#bbbbbb",
  base06: "#dddddd",
  base07: "#ffffff",
  base08: "#ff4136",
  base09: "#ff851b",
  base0A: "#ffdc00",
  base0B: "#2ecc40",
  base0C: "#7fdbff",
  base0D: "#0074d9",
  base0E: "#b10dc9",
  base0F: "#85144b"
};
var _default = {
  scheme: "default",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#181818",
  base01: "#282828",
  base02: "#383838",
  base03: "#585858",
  base04: "#b8b8b8",
  base05: "#d8d8d8",
  base06: "#e8e8e8",
  base07: "#f8f8f8",
  base08: "#ab4642",
  base09: "#dc9656",
  base0A: "#f7ca88",
  base0B: "#a1b56c",
  base0C: "#86c1b9",
  base0D: "#7cafc2",
  base0E: "#ba8baf",
  base0F: "#a16946"
};
var eighties = {
  scheme: "eighties",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2d2d2d",
  base01: "#393939",
  base02: "#515151",
  base03: "#747369",
  base04: "#a09f93",
  base05: "#d3d0c8",
  base06: "#e8e6df",
  base07: "#f2f0ec",
  base08: "#f2777a",
  base09: "#f99157",
  base0A: "#ffcc66",
  base0B: "#99cc99",
  base0C: "#66cccc",
  base0D: "#6699cc",
  base0E: "#cc99cc",
  base0F: "#d27b53"
};
var embers = {
  scheme: "embers",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#16130F",
  base01: "#2C2620",
  base02: "#433B32",
  base03: "#5A5047",
  base04: "#8A8075",
  base05: "#A39A90",
  base06: "#BEB6AE",
  base07: "#DBD6D1",
  base08: "#826D57",
  base09: "#828257",
  base0A: "#6D8257",
  base0B: "#57826D",
  base0C: "#576D82",
  base0D: "#6D5782",
  base0E: "#82576D",
  base0F: "#825757"
};
var flat = {
  scheme: "flat",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2C3E50",
  base01: "#34495E",
  base02: "#7F8C8D",
  base03: "#95A5A6",
  base04: "#BDC3C7",
  base05: "#e0e0e0",
  base06: "#f5f5f5",
  base07: "#ECF0F1",
  base08: "#E74C3C",
  base09: "#E67E22",
  base0A: "#F1C40F",
  base0B: "#2ECC71",
  base0C: "#1ABC9C",
  base0D: "#3498DB",
  base0E: "#9B59B6",
  base0F: "#be643c"
};
var google = {
  scheme: "google",
  author: "seth wright (http://sethawright.com)",
  base00: "#1d1f21",
  base01: "#282a2e",
  base02: "#373b41",
  base03: "#969896",
  base04: "#b4b7b4",
  base05: "#c5c8c6",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#CC342B",
  base09: "#F96A38",
  base0A: "#FBA922",
  base0B: "#198844",
  base0C: "#3971ED",
  base0D: "#3971ED",
  base0E: "#A36AC7",
  base0F: "#3971ED"
};
var grayscale = {
  scheme: "grayscale",
  author: "alexandre gavioli (https://github.com/alexx2/)",
  base00: "#101010",
  base01: "#252525",
  base02: "#464646",
  base03: "#525252",
  base04: "#ababab",
  base05: "#b9b9b9",
  base06: "#e3e3e3",
  base07: "#f7f7f7",
  base08: "#7c7c7c",
  base09: "#999999",
  base0A: "#a0a0a0",
  base0B: "#8e8e8e",
  base0C: "#868686",
  base0D: "#686868",
  base0E: "#747474",
  base0F: "#5e5e5e"
};
var greenscreen = {
  scheme: "green screen",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#001100",
  base01: "#003300",
  base02: "#005500",
  base03: "#007700",
  base04: "#009900",
  base05: "#00bb00",
  base06: "#00dd00",
  base07: "#00ff00",
  base08: "#007700",
  base09: "#009900",
  base0A: "#007700",
  base0B: "#00bb00",
  base0C: "#005500",
  base0D: "#009900",
  base0E: "#00bb00",
  base0F: "#005500"
};
var harmonic = {
  scheme: "harmonic16",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#0b1c2c",
  base01: "#223b54",
  base02: "#405c79",
  base03: "#627e99",
  base04: "#aabcce",
  base05: "#cbd6e2",
  base06: "#e5ebf1",
  base07: "#f7f9fb",
  base08: "#bf8b56",
  base09: "#bfbf56",
  base0A: "#8bbf56",
  base0B: "#56bf8b",
  base0C: "#568bbf",
  base0D: "#8b56bf",
  base0E: "#bf568b",
  base0F: "#bf5656"
};
var hopscotch = {
  scheme: "hopscotch",
  author: "jan t. sott",
  base00: "#322931",
  base01: "#433b42",
  base02: "#5c545b",
  base03: "#797379",
  base04: "#989498",
  base05: "#b9b5b8",
  base06: "#d5d3d5",
  base07: "#ffffff",
  base08: "#dd464c",
  base09: "#fd8b19",
  base0A: "#fdcc59",
  base0B: "#8fc13e",
  base0C: "#149b93",
  base0D: "#1290bf",
  base0E: "#c85e7c",
  base0F: "#b33508"
};
var isotope = {
  scheme: "isotope",
  author: "jan t. sott",
  base00: "#000000",
  base01: "#404040",
  base02: "#606060",
  base03: "#808080",
  base04: "#c0c0c0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#ff0000",
  base09: "#ff9900",
  base0A: "#ff0099",
  base0B: "#33ff00",
  base0C: "#00ffff",
  base0D: "#0066ff",
  base0E: "#cc00ff",
  base0F: "#3300ff"
};
var marrakesh = {
  scheme: "marrakesh",
  author: "alexandre gavioli (http://github.com/alexx2/)",
  base00: "#201602",
  base01: "#302e00",
  base02: "#5f5b17",
  base03: "#6c6823",
  base04: "#86813b",
  base05: "#948e48",
  base06: "#ccc37a",
  base07: "#faf0a5",
  base08: "#c35359",
  base09: "#b36144",
  base0A: "#a88339",
  base0B: "#18974e",
  base0C: "#75a738",
  base0D: "#477ca1",
  base0E: "#8868b3",
  base0F: "#b3588e"
};
var mocha = {
  scheme: "mocha",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#3B3228",
  base01: "#534636",
  base02: "#645240",
  base03: "#7e705a",
  base04: "#b8afad",
  base05: "#d0c8c6",
  base06: "#e9e1dd",
  base07: "#f5eeeb",
  base08: "#cb6077",
  base09: "#d28b71",
  base0A: "#f4bc87",
  base0B: "#beb55b",
  base0C: "#7bbda4",
  base0D: "#8ab3b5",
  base0E: "#a89bb9",
  base0F: "#bb9584"
};
var monokai = {
  scheme: "monokai",
  author: "wimer hazenberg (http://www.monokai.nl)",
  base00: "#272822",
  base01: "#383830",
  base02: "#49483e",
  base03: "#75715e",
  base04: "#a59f85",
  base05: "#f8f8f2",
  base06: "#f5f4f1",
  base07: "#f9f8f5",
  base08: "#f92672",
  base09: "#fd971f",
  base0A: "#f4bf75",
  base0B: "#a6e22e",
  base0C: "#a1efe4",
  base0D: "#66d9ef",
  base0E: "#ae81ff",
  base0F: "#cc6633"
};
var ocean = {
  scheme: "ocean",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2b303b",
  base01: "#343d46",
  base02: "#4f5b66",
  base03: "#65737e",
  base04: "#a7adba",
  base05: "#c0c5ce",
  base06: "#dfe1e8",
  base07: "#eff1f5",
  base08: "#bf616a",
  base09: "#d08770",
  base0A: "#ebcb8b",
  base0B: "#a3be8c",
  base0C: "#96b5b4",
  base0D: "#8fa1b3",
  base0E: "#b48ead",
  base0F: "#ab7967"
};
var paraiso = {
  scheme: "paraiso",
  author: "jan t. sott",
  base00: "#2f1e2e",
  base01: "#41323f",
  base02: "#4f424c",
  base03: "#776e71",
  base04: "#8d8687",
  base05: "#a39e9b",
  base06: "#b9b6b0",
  base07: "#e7e9db",
  base08: "#ef6155",
  base09: "#f99b15",
  base0A: "#fec418",
  base0B: "#48b685",
  base0C: "#5bc4bf",
  base0D: "#06b6ef",
  base0E: "#815ba4",
  base0F: "#e96ba8"
};
var pop = {
  scheme: "pop",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#000000",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#b0b0b0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#eb008a",
  base09: "#f29333",
  base0A: "#f8ca12",
  base0B: "#37b349",
  base0C: "#00aabb",
  base0D: "#0e5a94",
  base0E: "#b31e8d",
  base0F: "#7a2d00"
};
var railscasts = {
  scheme: "railscasts",
  author: "ryan bates (http://railscasts.com)",
  base00: "#2b2b2b",
  base01: "#272935",
  base02: "#3a4055",
  base03: "#5a647e",
  base04: "#d4cfc9",
  base05: "#e6e1dc",
  base06: "#f4f1ed",
  base07: "#f9f7f3",
  base08: "#da4939",
  base09: "#cc7833",
  base0A: "#ffc66d",
  base0B: "#a5c261",
  base0C: "#519f50",
  base0D: "#6d9cbe",
  base0E: "#b6b3eb",
  base0F: "#bc9458"
};
var shapeshifter = {
  scheme: "shapeshifter",
  author: "tyler benziger (http://tybenz.com)",
  base00: "#000000",
  base01: "#040404",
  base02: "#102015",
  base03: "#343434",
  base04: "#555555",
  base05: "#ababab",
  base06: "#e0e0e0",
  base07: "#f9f9f9",
  base08: "#e92f2f",
  base09: "#e09448",
  base0A: "#dddd13",
  base0B: "#0ed839",
  base0C: "#23edda",
  base0D: "#3b48e3",
  base0E: "#f996e2",
  base0F: "#69542d"
};
var solarized$1 = {
  scheme: "solarized",
  author: "ethan schoonover (http://ethanschoonover.com/solarized)",
  base00: "#002b36",
  base01: "#073642",
  base02: "#586e75",
  base03: "#657b83",
  base04: "#839496",
  base05: "#93a1a1",
  base06: "#eee8d5",
  base07: "#fdf6e3",
  base08: "#dc322f",
  base09: "#cb4b16",
  base0A: "#b58900",
  base0B: "#859900",
  base0C: "#2aa198",
  base0D: "#268bd2",
  base0E: "#6c71c4",
  base0F: "#d33682"
};
var summerfruit = {
  scheme: "summerfruit",
  author: "christopher corley (http://cscorley.github.io/)",
  base00: "#151515",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#B0B0B0",
  base05: "#D0D0D0",
  base06: "#E0E0E0",
  base07: "#FFFFFF",
  base08: "#FF0086",
  base09: "#FD8900",
  base0A: "#ABA800",
  base0B: "#00C918",
  base0C: "#1faaaa",
  base0D: "#3777E6",
  base0E: "#AD00A1",
  base0F: "#cc6633"
};
var tomorrow = {
  scheme: "tomorrow",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#1d1f21",
  base01: "#282a2e",
  base02: "#373b41",
  base03: "#969896",
  base04: "#b4b7b4",
  base05: "#c5c8c6",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#cc6666",
  base09: "#de935f",
  base0A: "#f0c674",
  base0B: "#b5bd68",
  base0C: "#8abeb7",
  base0D: "#81a2be",
  base0E: "#b294bb",
  base0F: "#a3685a"
};
var tube = {
  scheme: "london tube",
  author: "jan t. sott",
  base00: "#231f20",
  base01: "#1c3f95",
  base02: "#5a5758",
  base03: "#737171",
  base04: "#959ca1",
  base05: "#d9d8d8",
  base06: "#e7e7e8",
  base07: "#ffffff",
  base08: "#ee2e24",
  base09: "#f386a1",
  base0A: "#ffd204",
  base0B: "#00853e",
  base0C: "#85cebc",
  base0D: "#009ddc",
  base0E: "#98005d",
  base0F: "#b06110"
};
var twilight = {
  scheme: "twilight",
  author: "david hart (http://hart-dev.com)",
  base00: "#1e1e1e",
  base01: "#323537",
  base02: "#464b50",
  base03: "#5f5a60",
  base04: "#838184",
  base05: "#a7a7a7",
  base06: "#c3c3c3",
  base07: "#ffffff",
  base08: "#cf6a4c",
  base09: "#cda869",
  base0A: "#f9ee98",
  base0B: "#8f9d6a",
  base0C: "#afc4db",
  base0D: "#7587a6",
  base0E: "#9b859d",
  base0F: "#9b703f"
};
var src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  threezerotwofour,
  apathy,
  ashes,
  atelierDune,
  atelierForest,
  atelierHeath,
  atelierLakeside,
  atelierSeaside,
  bespin,
  brewer,
  bright,
  chalk,
  codeschool,
  colors,
  "default": _default,
  eighties,
  embers,
  flat,
  google,
  grayscale,
  greenscreen,
  harmonic,
  hopscotch,
  isotope,
  marrakesh,
  mocha,
  monokai,
  ocean,
  paraiso,
  pop,
  railscasts,
  shapeshifter,
  solarized: solarized$1,
  summerfruit,
  tomorrow,
  tube,
  twilight
}, Symbol.toStringTag, { value: "Module" }));
var require$$5 = /* @__PURE__ */ getAugmentedNamespace(src);
function clamp$3(val, min9, max9) {
  return Math.min(Math.max(val, min9), max9);
}
var clamp_1 = clamp$3;
var clamp$2 = clamp_1;
function componentToHex(c) {
  var value = Math.round(clamp$2(c, 0, 255));
  var hex2 = value.toString(16);
  return hex2.length == 1 ? "0" + hex2 : hex2;
}
function rgb2hex(rgb2) {
  var alpha = rgb2.length === 4 ? componentToHex(rgb2[3] * 255) : "";
  return "#" + componentToHex(rgb2[0]) + componentToHex(rgb2[1]) + componentToHex(rgb2[2]) + alpha;
}
var rgb2hex_1 = rgb2hex;
var component = /-?\d+(\.\d+)?%?/g;
function extractComponents$2(color) {
  return color.match(component);
}
var extractComponents_1 = extractComponents$2;
var extractComponents$1 = extractComponents_1;
var clamp$1 = clamp_1;
function parseHslComponent(component2, i) {
  component2 = parseFloat(component2);
  switch (i) {
    case 0:
      return clamp$1(component2, 0, 360);
    case 1:
    case 2:
      return clamp$1(component2, 0, 100);
    case 3:
      return clamp$1(component2, 0, 1);
  }
}
function hsl$1(color) {
  return extractComponents$1(color).map(parseHslComponent);
}
var hsl_1 = hsl$1;
function expand2(hex2) {
  var result2 = "#";
  for (var i = 1; i < hex2.length; i++) {
    var val = hex2.charAt(i);
    result2 += val + val;
  }
  return result2;
}
function hex$1(hex2) {
  if (hex2.length === 4 || hex2.length === 5) {
    hex2 = expand2(hex2);
  }
  var rgb2 = [
    parseInt(hex2.substring(1, 3), 16),
    parseInt(hex2.substring(3, 5), 16),
    parseInt(hex2.substring(5, 7), 16)
  ];
  if (hex2.length === 9) {
    var alpha = parseFloat((parseInt(hex2.substring(7, 9), 16) / 255).toFixed(2));
    rgb2.push(alpha);
  }
  return rgb2;
}
var hex_1 = hex$1;
var extractComponents = extractComponents_1;
var clamp = clamp_1;
function parseRgbComponent(component2, i) {
  if (i < 3) {
    if (component2.indexOf("%") != -1) {
      return Math.round(255 * clamp(parseInt(component2, 10), 0, 100) / 100);
    } else {
      return clamp(parseInt(component2, 10), 0, 255);
    }
  } else {
    return clamp(parseFloat(component2), 0, 1);
  }
}
function rgb$1(color) {
  return extractComponents(color).map(parseRgbComponent);
}
var rgb_1 = rgb$1;
function hsl2rgb$1(hsl2) {
  var h = hsl2[0] / 360, s = hsl2[1] / 100, l2 = hsl2[2] / 100, t1, t2, t3, rgb2, val;
  if (s == 0) {
    val = l2 * 255;
    return [val, val, val];
  }
  if (l2 < 0.5)
    t2 = l2 * (1 + s);
  else
    t2 = l2 + s - l2 * s;
  t1 = 2 * l2 - t2;
  rgb2 = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;
    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;
    rgb2[i] = val * 255;
  }
  return rgb2;
}
var hsl2rgb_1 = hsl2rgb$1;
var hsl = hsl_1;
var hex = hex_1;
var rgb = rgb_1;
var hsl2rgb = hsl2rgb_1;
function hsl2rgbParse(color) {
  var h = hsl(color);
  var r2 = hsl2rgb(h);
  if (h.length === 4) {
    r2.push(h[3]);
  }
  return r2;
}
var space2parser = {
  "#": hex,
  "hsl": hsl2rgbParse,
  "rgb": rgb
};
function parse15(color) {
  for (var scheme in space2parser) {
    if (color.indexOf(scheme) === 0) {
      return space2parser[scheme](color);
    }
  }
}
parse15.rgb = rgb;
parse15.hsl = hsl;
parse15.hex = hex;
var parse_1 = parse15;
var FUNC_ERROR_TEXT = "Expected a function";
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function apply7(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function arrayPush(array, values) {
  var index8 = -1, length2 = values.length, offset2 = array.length;
  while (++index8 < length2) {
    array[offset2 + index8] = values[index8];
  }
  return array;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol, propertyIsEnumerable2 = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
var nativeMax = Math.max;
function baseFlatten(array, depth, predicate, isStrict, result2) {
  var index8 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result2 || (result2 = []);
  while (++index8 < length2) {
    var value = array[index8];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
function baseRest(func, start16) {
  start16 = nativeMax(start16 === void 0 ? func.length - 1 : start16, 0);
  return function() {
    var args = arguments, index8 = -1, length2 = nativeMax(args.length - start16, 0), array = Array(length2);
    while (++index8 < length2) {
      array[index8] = args[start16 + index8];
    }
    index8 = -1;
    var otherArgs = Array(start16 + 1);
    while (++index8 < start16) {
      otherArgs[index8] = args[index8];
    }
    otherArgs[start16] = array;
    return apply7(func, this, otherArgs);
  };
}
function createFlow(fromRight) {
  return baseRest(function(funcs) {
    funcs = baseFlatten(funcs, 1);
    var length2 = funcs.length, index8 = length2;
    if (fromRight) {
      funcs.reverse();
    }
    while (index8--) {
      if (typeof funcs[index8] != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
    }
    return function() {
      var index9 = 0, result2 = length2 ? funcs[index9].apply(this, arguments) : arguments[0];
      while (++index9 < length2) {
        result2 = funcs[index9].call(this, result2);
      }
      return result2;
    };
  });
}
function isFlattenable(value) {
  return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function isArguments(value) {
  return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString.call(value) == argsTag);
}
var isArray2 = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
  var tag = isObject(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
var flow = createFlow();
var lodash_flow = flow;
var colorConverters = {};
Object.defineProperty(colorConverters, "__esModule", {
  value: true
});
colorConverters.yuv2rgb = yuv2rgb;
colorConverters.rgb2yuv = rgb2yuv;
function yuv2rgb(yuv) {
  var y2 = yuv[0], u2 = yuv[1], v2 = yuv[2], r2, g2, b;
  r2 = y2 * 1 + u2 * 0 + v2 * 1.13983;
  g2 = y2 * 1 + u2 * -0.39465 + v2 * -0.5806;
  b = y2 * 1 + u2 * 2.02311 + v2 * 0;
  r2 = Math.min(Math.max(0, r2), 1);
  g2 = Math.min(Math.max(0, g2), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r2 * 255, g2 * 255, b * 255];
}
function rgb2yuv(rgb2) {
  var r2 = rgb2[0] / 255, g2 = rgb2[1] / 255, b = rgb2[2] / 255;
  var y2 = r2 * 0.299 + g2 * 0.587 + b * 0.114;
  var u2 = r2 * -0.14713 + g2 * -0.28886 + b * 0.436;
  var v2 = r2 * 0.615 + g2 * -0.51499 + b * -0.10001;
  return [y2, u2, v2];
}
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.getBase16Theme = lib.createStyling = lib.invertTheme = void 0;
var _typeof2 = _typeof$8;
var _typeof3 = _interopRequireDefault(_typeof2);
var _extends2 = _extends$1;
var _extends3 = _interopRequireDefault(_extends2);
var _slicedToArray2 = slicedToArray;
var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
var _keys = keys$1.exports;
var _keys2 = _interopRequireDefault(_keys);
var _lodash = lodash_curry;
var _lodash2 = _interopRequireDefault(_lodash);
var _base = require$$5;
var base16 = _interopRequireWildcard(_base);
var _rgb2hex = rgb2hex_1;
var _rgb2hex2 = _interopRequireDefault(_rgb2hex);
var _parse = parse_1;
var _parse2 = _interopRequireDefault(_parse);
var _lodash3 = lodash_flow;
var _lodash4 = _interopRequireDefault(_lodash3);
var _colorConverters = colorConverters;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var DEFAULT_BASE16 = base16.default;
var BASE16_KEYS = (0, _keys2.default)(DEFAULT_BASE16);
var flip = function flip2(x2) {
  return x2 < 0.25 ? 1 : x2 < 0.5 ? 0.9 - x2 : 1.1 - x2;
};
var invertColor = (0, _lodash4.default)(_parse2.default, _colorConverters.rgb2yuv, function(_ref) {
  var _ref2 = (0, _slicedToArray3.default)(_ref, 3), y2 = _ref2[0], u2 = _ref2[1], v2 = _ref2[2];
  return [flip(y2), u2, v2];
}, _colorConverters.yuv2rgb, _rgb2hex2.default);
var merger = function merger2(styling) {
  return function(prevStyling) {
    return {
      className: [prevStyling.className, styling.className].filter(Boolean).join(" "),
      style: (0, _extends3.default)({}, prevStyling.style || {}, styling.style || {})
    };
  };
};
var mergeStyling = function mergeStyling2(customStyling, defaultStyling) {
  if (customStyling === void 0) {
    return defaultStyling;
  }
  if (defaultStyling === void 0) {
    return customStyling;
  }
  var customType = typeof customStyling === "undefined" ? "undefined" : (0, _typeof3.default)(customStyling);
  var defaultType = typeof defaultStyling === "undefined" ? "undefined" : (0, _typeof3.default)(defaultStyling);
  switch (customType) {
    case "string":
      switch (defaultType) {
        case "string":
          return [defaultStyling, customStyling].filter(Boolean).join(" ");
        case "object":
          return merger({ className: customStyling, style: defaultStyling });
        case "function":
          return function(styling) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return merger({
              className: customStyling
            })(defaultStyling.apply(void 0, [styling].concat(args)));
          };
      }
    case "object":
      switch (defaultType) {
        case "string":
          return merger({ className: defaultStyling, style: customStyling });
        case "object":
          return (0, _extends3.default)({}, defaultStyling, customStyling);
        case "function":
          return function(styling) {
            for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            return merger({
              style: customStyling
            })(defaultStyling.apply(void 0, [styling].concat(args)));
          };
      }
    case "function":
      switch (defaultType) {
        case "string":
          return function(styling) {
            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            return customStyling.apply(void 0, [merger(styling)({
              className: defaultStyling
            })].concat(args));
          };
        case "object":
          return function(styling) {
            for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }
            return customStyling.apply(void 0, [merger(styling)({
              style: defaultStyling
            })].concat(args));
          };
        case "function":
          return function(styling) {
            for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              args[_key5 - 1] = arguments[_key5];
            }
            return customStyling.apply(void 0, [defaultStyling.apply(void 0, [styling].concat(args))].concat(args));
          };
      }
  }
};
var mergeStylings = function mergeStylings2(customStylings, defaultStylings) {
  var keys3 = (0, _keys2.default)(defaultStylings);
  for (var key in customStylings) {
    if (keys3.indexOf(key) === -1)
      keys3.push(key);
  }
  return keys3.reduce(function(mergedStyling, key2) {
    return mergedStyling[key2] = mergeStyling(customStylings[key2], defaultStylings[key2]), mergedStyling;
  }, {});
};
var getStylingByKeys = function getStylingByKeys2(mergedStyling, keys3) {
  for (var _len6 = arguments.length, args = Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    args[_key6 - 2] = arguments[_key6];
  }
  if (keys3 === null) {
    return mergedStyling;
  }
  if (!Array.isArray(keys3)) {
    keys3 = [keys3];
  }
  var styles2 = keys3.map(function(key) {
    return mergedStyling[key];
  }).filter(Boolean);
  var props = styles2.reduce(function(obj, s) {
    if (typeof s === "string") {
      obj.className = [obj.className, s].filter(Boolean).join(" ");
    } else if ((typeof s === "undefined" ? "undefined" : (0, _typeof3.default)(s)) === "object") {
      obj.style = (0, _extends3.default)({}, obj.style, s);
    } else if (typeof s === "function") {
      obj = (0, _extends3.default)({}, obj, s.apply(void 0, [obj].concat(args)));
    }
    return obj;
  }, { className: "", style: {} });
  if (!props.className) {
    delete props.className;
  }
  if ((0, _keys2.default)(props.style).length === 0) {
    delete props.style;
  }
  return props;
};
var invertTheme = lib.invertTheme = function invertTheme2(theme) {
  return (0, _keys2.default)(theme).reduce(function(t2, key) {
    return t2[key] = /^base/.test(key) ? invertColor(theme[key]) : key === "scheme" ? theme[key] + ":inverted" : theme[key], t2;
  }, {});
};
lib.createStyling = (0, _lodash2.default)(function(getStylingFromBase16) {
  for (var _len7 = arguments.length, args = Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
    args[_key7 - 3] = arguments[_key7];
  }
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var themeOrStyling = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _options$defaultBase = options.defaultBase16, defaultBase16 = _options$defaultBase === void 0 ? DEFAULT_BASE16 : _options$defaultBase, _options$base16Themes = options.base16Themes, base16Themes = _options$base16Themes === void 0 ? null : _options$base16Themes;
  var base16Theme = getBase16Theme(themeOrStyling, base16Themes);
  if (base16Theme) {
    themeOrStyling = (0, _extends3.default)({}, base16Theme, themeOrStyling);
  }
  var theme = BASE16_KEYS.reduce(function(t2, key) {
    return t2[key] = themeOrStyling[key] || defaultBase16[key], t2;
  }, {});
  var customStyling = (0, _keys2.default)(themeOrStyling).reduce(function(s, key) {
    return BASE16_KEYS.indexOf(key) === -1 ? (s[key] = themeOrStyling[key], s) : s;
  }, {});
  var defaultStyling = getStylingFromBase16(theme);
  var mergedStyling = mergeStylings(customStyling, defaultStyling);
  return (0, _lodash2.default)(getStylingByKeys, 2).apply(void 0, [mergedStyling].concat(args));
}, 3);
var getBase16Theme = lib.getBase16Theme = function getBase16Theme2(theme, base16Themes) {
  if (theme && theme.extend) {
    theme = theme.extend;
  }
  if (typeof theme === "string") {
    var _theme$split = theme.split(":"), _theme$split2 = (0, _slicedToArray3.default)(_theme$split, 2), themeName = _theme$split2[0], modifier = _theme$split2[1];
    theme = (base16Themes || {})[themeName] || base16[themeName];
    if (modifier === "inverted") {
      theme = invertTheme(theme);
    }
  }
  return theme && theme.hasOwnProperty("base00") ? theme : void 0;
};
var solarized = {};
(function(exports) {
  exports.__esModule = true;
  exports["default"] = {
    scheme: "solarized",
    author: "ethan schoonover (http://ethanschoonover.com/solarized)",
    base00: "#002b36",
    base01: "#073642",
    base02: "#586e75",
    base03: "#657b83",
    base04: "#839496",
    base05: "#93a1a1",
    base06: "#eee8d5",
    base07: "#fdf6e3",
    base08: "#dc322f",
    base09: "#cb4b16",
    base0A: "#b58900",
    base0B: "#859900",
    base0C: "#2aa198",
    base0D: "#268bd2",
    base0E: "#6c71c4",
    base0F: "#d33682"
  };
})(solarized);
(function(exports) {
  exports.__esModule = true;
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _reactBase16Styling = lib;
  var _solarized = solarized;
  var _solarized2 = _interopRequireDefault2(_solarized);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var colorMap = function colorMap2(theme) {
    return {
      BACKGROUND_COLOR: theme.base00,
      TEXT_COLOR: theme.base07,
      STRING_COLOR: theme.base0B,
      DATE_COLOR: theme.base0B,
      NUMBER_COLOR: theme.base09,
      BOOLEAN_COLOR: theme.base09,
      NULL_COLOR: theme.base08,
      UNDEFINED_COLOR: theme.base08,
      FUNCTION_COLOR: theme.base08,
      SYMBOL_COLOR: theme.base08,
      LABEL_COLOR: theme.base0D,
      ARROW_COLOR: theme.base0D,
      ITEM_STRING_COLOR: theme.base0B,
      ITEM_STRING_EXPANDED_COLOR: theme.base03
    };
  };
  var valueColorMap = function valueColorMap2(colors2) {
    return {
      String: colors2.STRING_COLOR,
      Date: colors2.DATE_COLOR,
      Number: colors2.NUMBER_COLOR,
      Boolean: colors2.BOOLEAN_COLOR,
      Null: colors2.NULL_COLOR,
      Undefined: colors2.UNDEFINED_COLOR,
      Function: colors2.FUNCTION_COLOR,
      Symbol: colors2.SYMBOL_COLOR
    };
  };
  var getDefaultThemeStyling = function getDefaultThemeStyling2(theme) {
    var colors2 = colorMap(theme);
    return {
      tree: {
        border: 0,
        padding: 0,
        marginTop: "0.5em",
        marginBottom: "0.5em",
        marginLeft: "0.125em",
        marginRight: 0,
        listStyle: "none",
        MozUserSelect: "none",
        WebkitUserSelect: "none",
        backgroundColor: colors2.BACKGROUND_COLOR
      },
      value: function value(_ref, nodeType8, keyPath) {
        var style2 = _ref.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            paddingTop: "0.25em",
            paddingRight: 0,
            marginLeft: "0.875em",
            WebkitUserSelect: "text",
            MozUserSelect: "text",
            wordWrap: "break-word",
            paddingLeft: keyPath.length > 1 ? "2.125em" : "1.25em",
            textIndent: "-0.5em",
            wordBreak: "break-all"
          })
        };
      },
      label: {
        display: "inline-block",
        color: colors2.LABEL_COLOR
      },
      valueLabel: {
        margin: "0 0.5em 0 0"
      },
      valueText: function valueText(_ref2, nodeType8) {
        var style2 = _ref2.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            color: valueColorMap(colors2)[nodeType8]
          })
        };
      },
      itemRange: function itemRange(styling, expanded) {
        return {
          style: {
            paddingTop: expanded ? 0 : "0.25em",
            cursor: "pointer",
            color: colors2.LABEL_COLOR
          }
        };
      },
      arrow: function arrow2(_ref3, nodeType8, expanded) {
        var style2 = _ref3.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            marginLeft: 0,
            transition: "150ms",
            WebkitTransition: "150ms",
            MozTransition: "150ms",
            WebkitTransform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
            MozTransform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
            transform: expanded ? "rotateZ(90deg)" : "rotateZ(0deg)",
            transformOrigin: "45% 50%",
            WebkitTransformOrigin: "45% 50%",
            MozTransformOrigin: "45% 50%",
            position: "relative",
            lineHeight: "1.1em",
            fontSize: "0.75em"
          })
        };
      },
      arrowContainer: function arrowContainer(_ref4, arrowStyle) {
        var style2 = _ref4.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            display: "inline-block",
            paddingRight: "0.5em",
            paddingLeft: arrowStyle === "double" ? "1em" : 0,
            cursor: "pointer"
          })
        };
      },
      arrowSign: {
        color: colors2.ARROW_COLOR
      },
      arrowSignInner: {
        position: "absolute",
        top: 0,
        left: "-0.4em"
      },
      nestedNode: function nestedNode(_ref5, keyPath, nodeType8, expanded, expandable) {
        var style2 = _ref5.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            position: "relative",
            paddingTop: "0.25em",
            marginLeft: keyPath.length > 1 ? "0.875em" : 0,
            paddingLeft: !expandable ? "1.125em" : 0
          })
        };
      },
      rootNode: {
        padding: 0,
        margin: 0
      },
      nestedNodeLabel: function nestedNodeLabel(_ref6, keyPath, nodeType8, expanded, expandable) {
        var style2 = _ref6.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            margin: 0,
            padding: 0,
            WebkitUserSelect: expandable ? "inherit" : "text",
            MozUserSelect: expandable ? "inherit" : "text",
            cursor: expandable ? "pointer" : "default"
          })
        };
      },
      nestedNodeItemString: function nestedNodeItemString(_ref7, keyPath, nodeType8, expanded) {
        var style2 = _ref7.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            paddingLeft: "0.5em",
            cursor: "default",
            color: expanded ? colors2.ITEM_STRING_EXPANDED_COLOR : colors2.ITEM_STRING_COLOR
          })
        };
      },
      nestedNodeItemType: {
        marginLeft: "0.3em",
        marginRight: "0.3em"
      },
      nestedNodeChildren: function nestedNodeChildren(_ref8, nodeType8, expanded) {
        var style2 = _ref8.style;
        return {
          style: (0, _extends32["default"])({}, style2, {
            padding: 0,
            margin: 0,
            listStyle: "none",
            display: expanded ? "block" : "none"
          })
        };
      },
      rootNodeChildren: {
        padding: 0,
        margin: 0,
        listStyle: "none"
      }
    };
  };
  exports["default"] = (0, _reactBase16Styling.createStyling)(getDefaultThemeStyling, {
    defaultBase16: _solarized2["default"]
  });
})(createStylingFromTheme);
(function(exports) {
  exports.__esModule = true;
  var _objectWithoutProperties2 = objectWithoutProperties;
  var _objectWithoutProperties3 = _interopRequireDefault2(_objectWithoutProperties2);
  var _classCallCheck2 = classCallCheck;
  var _classCallCheck3 = _interopRequireDefault2(_classCallCheck2);
  var _possibleConstructorReturn2 = possibleConstructorReturn;
  var _possibleConstructorReturn3 = _interopRequireDefault2(_possibleConstructorReturn2);
  var _inherits2 = inherits;
  var _inherits3 = _interopRequireDefault2(_inherits2);
  var _extends22 = _extends$1;
  var _extends32 = _interopRequireDefault2(_extends22);
  var _keys3 = keys$1.exports;
  var _keys22 = _interopRequireDefault2(_keys3);
  var _react3 = react.exports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypes.exports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _JSONNode = JSONNode;
  var _JSONNode2 = _interopRequireDefault2(_JSONNode);
  var _createStylingFromTheme = createStylingFromTheme;
  var _createStylingFromTheme2 = _interopRequireDefault2(_createStylingFromTheme);
  var _reactBase16Styling = lib;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var identity2 = function identity3(value) {
    return value;
  };
  var expandRootNode = function expandRootNode2(keyName2, data, level) {
    return level === 0;
  };
  var defaultItemString = function defaultItemString2(type, data, itemType, itemString) {
    return _react22["default"].createElement(
      "span",
      null,
      itemType,
      " ",
      itemString
    );
  };
  var defaultLabelRenderer = function defaultLabelRenderer2(_ref) {
    var label = _ref[0];
    return _react22["default"].createElement(
      "span",
      null,
      label,
      ":"
    );
  };
  var noCustomNode = function noCustomNode2() {
    return false;
  };
  function checkLegacyTheming(theme, props) {
    var deprecatedStylingMethodsMap = {
      getArrowStyle: "arrow",
      getListStyle: "nestedNodeChildren",
      getItemStringStyle: "nestedNodeItemString",
      getLabelStyle: "label",
      getValueStyle: "valueText"
    };
    var deprecatedStylingMethods = (0, _keys22["default"])(deprecatedStylingMethodsMap).filter(function(name) {
      return props[name];
    });
    if (deprecatedStylingMethods.length > 0) {
      if (typeof theme === "string") {
        theme = {
          extend: theme
        };
      } else {
        theme = (0, _extends32["default"])({}, theme);
      }
      deprecatedStylingMethods.forEach(function(name) {
        console.error('Styling method "' + name + '" is deprecated, use "theme" property instead');
        theme[deprecatedStylingMethodsMap[name]] = function(_ref2) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var style2 = _ref2.style;
          return {
            style: (0, _extends32["default"])({}, style2, props[name].apply(props, args))
          };
        };
      });
    }
    return theme;
  }
  function getStateFromProps(props) {
    var theme = checkLegacyTheming(props.theme, props);
    if (props.invertTheme) {
      if (typeof theme === "string") {
        theme = theme + ":inverted";
      } else if (theme && theme.extend) {
        if (typeof theme === "string") {
          theme = (0, _extends32["default"])({}, theme, { extend: theme.extend + ":inverted" });
        } else {
          theme = (0, _extends32["default"])({}, theme, { extend: (0, _reactBase16Styling.invertTheme)(theme.extend) });
        }
      } else if (theme) {
        theme = (0, _reactBase16Styling.invertTheme)(theme);
      }
    }
    return {
      styling: (0, _createStylingFromTheme2["default"])(theme)
    };
  }
  var JSONTree2 = function(_React$Component) {
    (0, _inherits3["default"])(JSONTree3, _React$Component);
    function JSONTree3(props) {
      (0, _classCallCheck3["default"])(this, JSONTree3);
      var _this = (0, _possibleConstructorReturn3["default"])(this, _React$Component.call(this, props));
      _this.state = getStateFromProps(props);
      return _this;
    }
    JSONTree3.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var _this2 = this;
      if (["theme", "invertTheme"].find(function(k) {
        return nextProps[k] !== _this2.props[k];
      })) {
        this.setState(getStateFromProps(nextProps));
      }
    };
    JSONTree3.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var _this3 = this;
      return !!(0, _keys22["default"])(nextProps).find(function(k) {
        return k === "keyPath" ? nextProps[k].join("/") !== _this3.props[k].join("/") : nextProps[k] !== _this3.props[k];
      });
    };
    JSONTree3.prototype.render = function render4() {
      var _props = this.props, value = _props.data, keyPath = _props.keyPath, postprocessValue2 = _props.postprocessValue, hideRoot = _props.hideRoot;
      _props.theme;
      _props.invertTheme;
      var rest = (0, _objectWithoutProperties3["default"])(_props, ["data", "keyPath", "postprocessValue", "hideRoot", "theme", "invertTheme"]);
      var styling = this.state.styling;
      return _react22["default"].createElement(
        "ul",
        styling("tree"),
        _react22["default"].createElement(_JSONNode2["default"], (0, _extends32["default"])({}, (0, _extends32["default"])({ postprocessValue: postprocessValue2, hideRoot, styling }, rest), {
          keyPath: hideRoot ? [] : keyPath,
          value: postprocessValue2(value)
        }))
      );
    };
    return JSONTree3;
  }(_react22["default"].Component);
  JSONTree2.propTypes = {
    data: _propTypes22["default"].oneOfType([_propTypes22["default"].array, _propTypes22["default"].object]).isRequired,
    hideRoot: _propTypes22["default"].bool,
    theme: _propTypes22["default"].oneOfType([_propTypes22["default"].object, _propTypes22["default"].string]),
    invertTheme: _propTypes22["default"].bool,
    keyPath: _propTypes22["default"].arrayOf(_propTypes22["default"].oneOfType([_propTypes22["default"].string, _propTypes22["default"].number])),
    postprocessValue: _propTypes22["default"].func,
    sortObjectKeys: _propTypes22["default"].oneOfType([_propTypes22["default"].func, _propTypes22["default"].bool])
  };
  JSONTree2.defaultProps = {
    shouldExpandNode: expandRootNode,
    hideRoot: false,
    keyPath: ["root"],
    getItemString: defaultItemString,
    labelRenderer: defaultLabelRenderer,
    valueRenderer: identity2,
    postprocessValue: identity2,
    isCustomNode: noCustomNode,
    collectionLimit: 50,
    invertTheme: true
  };
  exports["default"] = JSONTree2;
})(lib$1);
var JSONTreeVendor = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function JSONTree(props) {
  return /* @__PURE__ */ React.createElement(JSONTreeVendor, _extends({
    invertTheme: false,
    theme: jsonTreeTheme,
    hideRoot: true
  }, props));
}
var Heading = newStyled("h2")({
  color: mainTheme.softerMain,
  padding: 0,
  margin: 0,
  fontWeight: 400,
  letterSpacing: "1px",
  fontSize: "13px",
  textTransform: "uppercase",
  flexGrow: 1
});
Heading.displayName = "Heading";
var HeadingWithButton = newStyled("div")({
  display: "flex"
});
HeadingWithButton.displayName = "HeadingWithButton";
var HeadingButton = newStyled("button")({
  padding: "6px 10px",
  margin: "-6px -10px 0 8px",
  fontWeight: 400,
  letterSpacing: "1px",
  fontSize: "11px",
  color: mainTheme.white80,
  textTransform: "uppercase",
  transition: "background 0.3s, color 0.3s",
  borderRadius: "2px",
  border: "none",
  background: "transparent",
  "&:hover": {
    background: mainTheme.main40,
    color: mainTheme.white,
    cursor: "pointer"
  },
  "&:focus": {
    outline: "none"
  },
  "&:active": {
    background: mainTheme.main60
  }
});
HeadingButton.displayName = "HeadingButton";
var JSONTreeWrapper = newStyled("div")({
  padding: "0 0 9px 0",
  overflow: "hidden"
});
JSONTreeWrapper.displayName = "JSONTreeWrapper";
var Section$1 = newStyled("div")({
  minWidth: "180px",
  boxSizing: "border-box",
  "& + &": {
    paddingTop: "9px"
  }
});
Section$1.displayName = "Section";
var Group = newStyled("div")({
  margin: "0.5em 0px 0.5em 1em"
});
Group.displayName = "Group";
var GroupRow = newStyled("div")({
  paddingTop: "0.25em"
});
GroupRow.displayName = "GroupRow";
var Key = newStyled("span")({
  display: "inline-block",
  color: mainTheme.syntax.base0D,
  margin: "0px 0.5em 0px 0px"
});
Key.displayName = "Key";
var ValueNum = newStyled("span")({
  color: mainTheme.syntax.base09
});
ValueNum.displayName = "ValueNum";
var LogNodeButton = newStyled("button")({
  color: mainTheme.white60,
  background: "none",
  border: "none",
  transition: "background 0.3s, color 0.3s",
  borderRadius: "3px",
  "&:hover": {
    cursor: "pointer",
    background: mainTheme.main40,
    color: mainTheme.white
  },
  "&:focus": {
    outline: "none"
  }
});
LogNodeButton.displayName = "LogNodeButton";
function getItemString$1(doc2, action) {
  return function getItemStringWithBindedDoc(type, value, defaultView, keysCount) {
    var logButton = /* @__PURE__ */ React.createElement(LogNodeButton, {
      onClick: function onClick(e) {
        e.preventDefault();
        e.stopPropagation();
        action({
          doc: doc2,
          node: value
        });
      }
    }, "log");
    if (type === "Object" && value.type) {
      return /* @__PURE__ */ React.createElement("span", null, "{} ", value.type, " ", logButton);
    }
    return /* @__PURE__ */ React.createElement("span", null, defaultView, " ", keysCount, " ", logButton);
  };
}
function getItemStringForMark(type, value, defaultView, keysCount) {
  if (type === "Object" && value.type) {
    return /* @__PURE__ */ React.createElement("span", null, "{} ", value.type);
  }
  return /* @__PURE__ */ React.createElement("span", null, defaultView, " ", keysCount);
}
function _shouldExpandNode(expandPath, nodePath) {
  var path = [].concat(nodePath).reverse();
  if (!expandPath)
    return false;
  expandPath.push("attrs");
  if (path.length > expandPath.length)
    return false;
  if (path.join(".") === expandPath.join("."))
    return true;
  if (path.every(function(el, idx) {
    return el === expandPath[idx];
  }))
    return true;
  return false;
}
function StateTab() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer, StateTabStateContainer]
  }, function(editorState, stateTab) {
    var logNodeFromJSON = editorState.logNodeFromJSON;
    var _editorState$state = editorState.state, state = _editorState$state.state, activeMarks = _editorState$state.activeMarks, expandPath = _editorState$state.expandPath;
    var toggleSelection = stateTab.toggleSelection;
    var selectionExpanded = stateTab.state.selectionExpanded;
    var doc2 = state.doc.toJSON();
    return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
      grow: true
    }, /* @__PURE__ */ React.createElement(HeadingWithButton, null, /* @__PURE__ */ React.createElement(Heading, null, "Current Doc"), /* @__PURE__ */ React.createElement(HeadingButton, {
      onClick: function onClick() {
        return console.log(state);
      }
    }, "Log State")), /* @__PURE__ */ React.createElement(JSONTree, {
      data: doc2,
      hideRoot: true,
      getItemString: getItemString$1(doc2, logNodeFromJSON),
      shouldExpandNode: function shouldExpandNode(nodePath) {
        return _shouldExpandNode(expandPath, nodePath);
      }
    })), /* @__PURE__ */ React.createElement(SplitViewCol, {
      sep: true,
      minWidth: 220
    }, /* @__PURE__ */ React.createElement(Section$1, null, /* @__PURE__ */ React.createElement(HeadingWithButton, null, /* @__PURE__ */ React.createElement(Heading, null, "Selection"), /* @__PURE__ */ React.createElement(HeadingButton, {
      onClick: function onClick() {
        return toggleSelection();
      }
    }, selectionExpanded ? "\u25BC" : "\u25B6")), /* @__PURE__ */ React.createElement(JSONTreeWrapper, null, /* @__PURE__ */ React.createElement(JSONTree, {
      data: selectionExpanded ? expandedStateFormatSelection(state.selection) : collapsedStateFormatSelection(state.selection),
      hideRoot: true
    }))), /* @__PURE__ */ React.createElement(Section$1, null, /* @__PURE__ */ React.createElement(Heading, null, "Active Marks"), /* @__PURE__ */ React.createElement(JSONTreeWrapper, null, activeMarks.length ? /* @__PURE__ */ React.createElement(JSONTree, {
      data: activeMarks,
      hideRoot: true,
      getItemString: getItemStringForMark
    }) : /* @__PURE__ */ React.createElement(Group, null, /* @__PURE__ */ React.createElement(GroupRow, null, /* @__PURE__ */ React.createElement(Key, null, "no active marks"))))), /* @__PURE__ */ React.createElement(Section$1, null, /* @__PURE__ */ React.createElement(Heading, null, "Document Stats"), /* @__PURE__ */ React.createElement(Group, null, /* @__PURE__ */ React.createElement(GroupRow, null, /* @__PURE__ */ React.createElement(Key, null, "nodeSize:"), /* @__PURE__ */ React.createElement(ValueNum, null, state.doc.nodeSize)), /* @__PURE__ */ React.createElement(GroupRow, null, /* @__PURE__ */ React.createElement(Key, null, "childCount:"), /* @__PURE__ */ React.createElement(ValueNum, null, state.doc.childCount))))));
  });
}
var InfoPanel = newStyled("div")({
  position: "relative",
  top: "50%",
  transform: "translateY(-50%)",
  textAlign: "center",
  color: mainTheme.main,
  fontSize: "14px"
});
InfoPanel.displayName = "InfoPanel";
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = react.exports, g = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h = Symbol.for;
  g = h("react.element");
  reactJsxRuntime_production_min.Fragment = h("react.fragment");
}
var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, k) {
  var b, d = {}, e = null, l2 = null;
  void 0 !== k && (e = "" + k);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (l2 = a.ref);
  for (b in a)
    n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: g, type: c, key: e, ref: l2, props: d, _owner: m.current };
}
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$6(o, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function() {
    var Super = _getPrototypeOf$6(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result2);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
var noop = function noop2() {
};
var ListItem$1 = newStyled("div")({
  minWidth: "190px",
  width: "100%",
  display: "flex",
  boxSizing: "border-box",
  fontWeight: 400,
  letterSpacing: "1px",
  fontSize: "11px",
  color: mainTheme.white80,
  textTransform: "uppercase",
  transition: "background .3s",
  textAlign: "left",
  fontFamily: "monospace",
  border: "none",
  borderTop: "1px solid ".concat(mainTheme.main20),
  margin: 0,
  "&:first-child": {
    borderTop: "none"
  },
  "&:hover": {
    background: mainTheme.main40,
    color: mainTheme.white,
    cursor: "pointer"
  },
  "&:focus": {
    outline: "none"
  },
  "&:active": {
    background: mainTheme.main60
  }
}, function(props) {
  return {
    opacity: props.isDimmed ? 0.3 : 1,
    padding: props.nested ? "6px 18px 6px 36px" : "6px 18px",
    background: props.background ? props.background(props) : props.isSelected ? mainTheme.main40 : "transparent"
  };
});
ListItem$1.displayName = "ListItem";
var ListItemGroupContent = newStyled("div")({
  display: "block"
}, function(props) {
  return {
    display: props.collapsed ? "none" : "block"
  };
});
ListItemGroupContent.displayName = "ListItemGroupContent";
var ListItemGroup = /* @__PURE__ */ function(_PureComponent) {
  _inherits$6(ListItemGroup2, _PureComponent);
  var _super = _createSuper$6(ListItemGroup2);
  function ListItemGroup2(props) {
    var _this;
    _classCallCheck$6(this, ListItemGroup2);
    _this = _super.call(this, props);
    _this.state = {
      collapsed: true
    };
    return _this;
  }
  _createClass$4(ListItemGroup2, [{
    key: "toggle",
    value: function toggle2() {
      this.setState({
        collapsed: !this.state.collapsed
      });
    }
  }, {
    key: "render",
    value: function render4() {
      var _this2 = this;
      var _this$props = this.props, items = _this$props.items, groupTitle = _this$props.groupTitle, title = _this$props.title, _this$props$isSelecte = _this$props.isSelected, isSelected = _this$props$isSelecte === void 0 ? noop : _this$props$isSelecte, _this$props$isPreviou = _this$props.isPrevious, isPrevious = _this$props$isPreviou === void 0 ? noop : _this$props$isPreviou, _this$props$isDimmed = _this$props.isDimmed, isDimmed = _this$props$isDimmed === void 0 ? noop : _this$props$isDimmed, _this$props$getKey = _this$props.getKey, getKey = _this$props$getKey === void 0 ? noop : _this$props$getKey, _this$props$onListIte = _this$props.onListItemClick, onListItemClick = _this$props$onListIte === void 0 ? noop : _this$props$onListIte, _this$props$onListIte2 = _this$props.onListItemDoubleClick, onListItemDoubleClick = _this$props$onListIte2 === void 0 ? noop : _this$props$onListIte2, customItemBackground = _this$props.customItemBackground;
      return /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsxs(ListItem$1, {
          onClick: function onClick() {
            return _this2.toggle();
          },
          isSelected: items.some(isSelected) && this.state.collapsed,
          isPrevious: isPrevious(items[0], 0) && this.state.collapsed,
          isDimmed: items.every(isDimmed),
          background: customItemBackground,
          children: [/* @__PURE__ */ jsx("div", {
            style: {
              flexGrow: 1
            },
            children: groupTitle(items, 0)
          }), /* @__PURE__ */ jsx("div", {
            children: this.state.collapsed ? "\u25B6" : "\u25BC"
          })]
        }, getKey(items[0])), /* @__PURE__ */ jsx(ListItemGroupContent, {
          collapsed: this.state.collapsed,
          children: (items || []).map(function(item, index8) {
            return /* @__PURE__ */ jsx(ListItem$1, {
              nested: true,
              isSelected: isSelected(item, index8),
              isPrevious: isPrevious(item, index8),
              isDimmed: isDimmed(item, index8),
              background: customItemBackground,
              onClick: function onClick() {
                return onListItemClick(item, index8);
              },
              onDoubleClick: function onDoubleClick() {
                return onListItemDoubleClick(item, index8);
              },
              children: title(item, index8)
            }, getKey(item));
          })
        })]
      });
    }
  }]);
  return ListItemGroup2;
}(react.exports.PureComponent);
function List(props) {
  var _props$isSelected = props.isSelected, isSelected = _props$isSelected === void 0 ? noop : _props$isSelected, _props$isPrevious = props.isPrevious, isPrevious = _props$isPrevious === void 0 ? noop : _props$isPrevious, _props$isDimmed = props.isDimmed, isDimmed = _props$isDimmed === void 0 ? noop : _props$isDimmed, _props$getKey = props.getKey, getKey = _props$getKey === void 0 ? noop : _props$getKey, _props$onListItemClic = props.onListItemClick, onListItemClick = _props$onListItemClic === void 0 ? noop : _props$onListItemClic, _props$onListItemDoub = props.onListItemDoubleClick, onListItemDoubleClick = _props$onListItemDoub === void 0 ? noop : _props$onListItemDoub;
  return /* @__PURE__ */ jsx("div", {
    children: (props.items || []).map(function(item, index8) {
      if (Array.isArray(item)) {
        return /* @__PURE__ */ react.exports.createElement(ListItemGroup, {
          ...props,
          items: item,
          key: item[0].timestamp
        }, props.groupTitle(item, index8));
      }
      return /* @__PURE__ */ jsx(ListItem$1, {
        isSelected: isSelected(item, index8),
        isPrevious: isPrevious(item, index8),
        isDimmed: isDimmed(item, index8),
        background: props.customItemBackground,
        onClick: function onClick() {
          return onListItemClick(item, index8);
        },
        onDoubleClick: function onDoubleClick() {
          return onListItemDoubleClick(item, index8);
        },
        children: props.title(item, index8)
      }, getKey(item));
    })
  });
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Updated = newStyled("span")({
  color: mainTheme.main
});
Updated.displayName = "Updated";
var White = newStyled("span")({
  color: mainTheme.white
});
White.displayName = "White";
var Deleted = newStyled("span")({
  display: "inline-block",
  background: mainTheme.lightYellow,
  color: mainTheme.lightPink,
  padding: "1px 3px 2px",
  textIndent: 0,
  textDecoration: "line-through",
  minHeight: "1ex"
});
Deleted.displayName = "Deleted";
var Added = newStyled("span")({
  display: "inline-block",
  background: mainTheme.lightYellow,
  color: mainTheme.darkGreen,
  padding: "1px 3px 2px",
  textIndent: 0,
  minHeight: "1ex"
});
Added.displayName = "Added";
function postprocessValue$1(value) {
  if (value && value._t === "a") {
    var res = {};
    for (var key in value) {
      if (key !== "_t") {
        if (key[0] === "_" && !value[key.substr(1)]) {
          res[key.substr(1)] = value[key];
        } else if (value["_" + key]) {
          res[key] = [value["_" + key][0], value[key][0]];
        } else if (!value["_" + key] && key[0] !== "_") {
          res[key] = value[key];
        }
      }
    }
    return res;
  }
  return value;
}
function labelRenderer(raw) {
  return raw[0];
}
function stringifyAndShrink(val) {
  if (val === null) {
    return "null";
  }
  var str = JSON.stringify(val);
  if (typeof str === "undefined") {
    return "undefined";
  }
  return str.length > 22 ? "".concat(str.substr(0, 15), "\u2026").concat(str.substr(-5)) : str;
}
function getValueString(raw) {
  if (typeof raw === "string") {
    return raw;
  }
  return stringifyAndShrink(raw);
}
function replaceSpacesWithNonBreakingSpace(value) {
  return value.replace(/\s/gm, "\xA0");
}
function parseTextDiff(textDiff) {
  var diffByLines = textDiff.split(/\n/gm).slice(1);
  return diffByLines.map(function(line2) {
    var type = line2.startsWith("-") ? "delete" : line2.startsWith("+") ? "add" : "raw";
    return _defineProperty$3({}, type, replaceSpacesWithNonBreakingSpace(line2.substr(1)));
  });
}
function valueRenderer$1(raw) {
  if (Array.isArray(raw)) {
    if (raw.length === 1) {
      return /* @__PURE__ */ React.createElement(Added, null, getValueString(raw[0]));
    }
    if (raw.length === 2) {
      return /* @__PURE__ */ React.createElement(Updated, null, /* @__PURE__ */ React.createElement(Deleted, null, getValueString(raw[0])), " =>", " ", /* @__PURE__ */ React.createElement(Added, null, getValueString(raw[1])));
    }
    if (raw.length === 3 && raw[1] === 0 && raw[2] === 0) {
      return /* @__PURE__ */ React.createElement(Deleted, null, getValueString(raw[0]));
    }
    if (raw.length === 3 && raw[2] === 2) {
      return /* @__PURE__ */ React.createElement(Updated, null, '"', parseTextDiff(raw[0]).map(function(item) {
        if (item["delete"]) {
          return /* @__PURE__ */ React.createElement(Deleted, {
            key: item["delete"] + "delete"
          }, item["delete"]);
        }
        if (item.add) {
          return /* @__PURE__ */ React.createElement(Added, {
            key: item.add + "add"
          }, item.add);
        }
        return /* @__PURE__ */ React.createElement(White, {
          key: item.raw + "raw"
        }, item.raw);
      }), '"');
    }
  }
  return "" + raw;
}
function getItemString(type, value, defaultView, keysCount) {
  switch (type) {
    case "Object":
      return /* @__PURE__ */ React.createElement("span", null, "{\u2026}");
    default:
      return /* @__PURE__ */ React.createElement("span", null, defaultView, " ", keysCount);
  }
}
function JSONDiff(props) {
  if (!props.delta)
    return null;
  return /* @__PURE__ */ React.createElement(JSONTree, {
    data: props.delta,
    hideRoot: true,
    postprocessValue: postprocessValue$1,
    labelRenderer,
    valueRenderer: valueRenderer$1,
    isCustomNode: Array.isArray,
    getItemString,
    shouldExpandNode: function shouldExpandNode() {
      return true;
    }
  });
}
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$5(o, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function() {
    var Super = _getPrototypeOf$5(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result2);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
var CustomPre = newStyled("pre")({
  padding: "9px 0 18px 0 !important",
  margin: 0,
  color: mainTheme.white80,
  "& .prosemirror-dev-tools-highlighter-tag": {
    color: mainTheme.main
  }
});
CustomPre.displayName = "CustomPre";
var regexp = /(&lt;\/?[\w\d\s="']+&gt;)/gim;
var highlight = function highlight2(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(regexp, "<span class='prosemirror-dev-tools-highlighter-tag'>$&</span>");
};
var Highlighter = /* @__PURE__ */ function(_React$Component) {
  _inherits$5(Highlighter2, _React$Component);
  var _super = _createSuper$5(Highlighter2);
  function Highlighter2() {
    _classCallCheck$5(this, Highlighter2);
    return _super.apply(this, arguments);
  }
  _createClass$3(Highlighter2, [{
    key: "render",
    value: function render4() {
      if (!this.props.children)
        return null;
      return /* @__PURE__ */ React.createElement(CustomPre, {
        dangerouslySetInnerHTML: {
          __html: highlight(this.props.children)
        }
      });
    }
  }]);
  return Highlighter2;
}(React.Component);
var Section = newStyled("div")({
  minWidth: "180px",
  boxSizing: "border-box",
  "& + &": {
    paddingTop: "9px"
  }
});
Section.displayName = "Section";
function pad(num) {
  return ("00" + num).slice(-2);
}
function pad3(num) {
  return ("000" + num).slice(-3);
}
var formatTimestamp = function formatTimestamp2(timestamp) {
  var date = new Date(timestamp);
  return [pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds()), pad3(date.getMilliseconds())].join(":");
};
function SelectionContentSection(props) {
  if (!props.selectionContent)
    return null;
  return /* @__PURE__ */ React.createElement(Section, null, /* @__PURE__ */ React.createElement(Heading, null, "Selection Content"), /* @__PURE__ */ React.createElement(Highlighter, null, props.selectionContent));
}
function DocDiffSection(props) {
  if (!props.diff)
    return null;
  return /* @__PURE__ */ React.createElement(Section, null, /* @__PURE__ */ React.createElement(Heading, null, "Doc diff"), /* @__PURE__ */ React.createElement(JSONDiff, {
    delta: props.diff
  }));
}
function SelectionSection(props) {
  if (!props.selection)
    return null;
  return /* @__PURE__ */ React.createElement(Section, null, /* @__PURE__ */ React.createElement(Heading, null, "Selection diff"), /* @__PURE__ */ React.createElement(JSONDiff, {
    delta: props.selection
  }));
}
function HistoryView() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer]
  }, function(editorState) {
    var selectHistoryItem = editorState.selectHistoryItem, rollbackHistory = editorState.rollbackHistory;
    var _editorState$state = editorState.state, history2 = _editorState$state.history, selectedHistoryItem = _editorState$state.selectedHistoryItem, historyRolledBackTo = _editorState$state.historyRolledBackTo;
    var prevItem = history2[selectedHistoryItem + 1];
    var selectedItem = history2[selectedHistoryItem];
    var historyRolledBackToItem = history2[historyRolledBackTo];
    var historyList = history2.reduce(function(h, item, index8) {
      var prev2 = h[h.length - 1];
      item.index = index8;
      if (!item.diff) {
        if (!prev2 || !Array.isArray(prev2)) {
          h.push([item]);
        } else {
          prev2.push(item);
        }
      } else {
        h.push(item);
      }
      return h;
    }, []).reduce(function(h, item) {
      if (Array.isArray(item) && item.length === 1) {
        h.push(item[0]);
      } else {
        h.push(item);
      }
      return h;
    }, []);
    var isSelected = function isSelected2(item) {
      return item.timestamp === selectedItem.timestamp;
    };
    var isPrevious = function isPrevious2(item) {
      return prevItem && item.timestamp === prevItem.timestamp;
    };
    var isDimmed = function isDimmed2(item) {
      return historyRolledBackToItem && item.timestamp > historyRolledBackToItem.timestamp;
    };
    return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
      noPaddings: true,
      minWidth: 190
    }, /* @__PURE__ */ React.createElement(List, {
      items: historyList,
      getKey: function getKey(item) {
        return item.timestamp;
      },
      title: function title(item) {
        return formatTimestamp(item.timestamp);
      },
      groupTitle: function groupTitle(item) {
        return formatTimestamp(item[0].timestamp) + " [".concat(item.length, "]");
      },
      isSelected,
      isPrevious,
      isDimmed,
      customItemBackground: function customItemBackground(props) {
        return props.isSelected ? mainTheme.main40 : props.isPrevious ? mainTheme.main20 : "transparent";
      },
      onListItemClick: function onListItemClick(item) {
        return selectHistoryItem(item.index);
      },
      onListItemDoubleClick: function onListItemDoubleClick(item) {
        return rollbackHistory(item.index);
      }
    })), /* @__PURE__ */ React.createElement(SplitViewCol, {
      grow: true,
      sep: true
    }, /* @__PURE__ */ React.createElement(DocDiffSection, {
      diff: selectedItem.diff
    }), /* @__PURE__ */ React.createElement(SelectionSection, {
      selection: selectedItem.selection
    }), /* @__PURE__ */ React.createElement(SelectionContentSection, {
      selectionContent: selectedItem.selectionContent
    }), !selectedItem.diff && !selectedItem.selectionContent && !selectedItem.diffPending && /* @__PURE__ */ React.createElement(InfoPanel, null, "Docs are equal.")));
  });
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$4(o, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function() {
    var Super = _getPrototypeOf$4(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result2);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
var ignoreFields = ["schema", "contentExpr", "schema", "parseDOM", "toDOM"];
function postprocessValue(ignore, data) {
  if (!data || Object.prototype.toString.call(data) !== "[object Object]") {
    return data;
  }
  return Object.keys(data).filter(function(key) {
    return ignore.indexOf(key) === -1;
  }).reduce(function(res, key) {
    res[key] = data[key];
    return res;
  }, {});
}
var SchemaTab = /* @__PURE__ */ function(_React$Component) {
  _inherits$4(SchemaTab2, _React$Component);
  var _super = _createSuper$4(SchemaTab2);
  function SchemaTab2() {
    _classCallCheck$4(this, SchemaTab2);
    return _super.apply(this, arguments);
  }
  _createClass$2(SchemaTab2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return this.props.schema !== nextProps.schema;
    }
  }, {
    key: "render",
    value: function render4() {
      var schema2 = this.props.schema;
      return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
        grow: true
      }, /* @__PURE__ */ React.createElement(Heading, null, "Nodes"), /* @__PURE__ */ React.createElement(JSONTree, {
        data: schema2.nodes,
        postprocessValue: postprocessValue.bind(null, ignoreFields)
      })), /* @__PURE__ */ React.createElement(SplitViewCol, {
        grow: true,
        sep: true
      }, /* @__PURE__ */ React.createElement(Heading, null, "Marks"), /* @__PURE__ */ React.createElement(JSONTree, {
        data: schema2.marks,
        postprocessValue: postprocessValue.bind(null, ignoreFields)
      })));
    }
  }]);
  return SchemaTab2;
}(React.Component);
function SchemaTabContainer() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer]
  }, function(_ref) {
    var schema2 = _ref.state.state.schema;
    return /* @__PURE__ */ React.createElement(SchemaTab, {
      schema: schema2
    });
  });
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function() {
    var Super = _getPrototypeOf$3(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result2);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var PluginsTabStateContainer = /* @__PURE__ */ function(_Container) {
  _inherits$3(PluginsTabStateContainer2, _Container);
  var _super = _createSuper$3(PluginsTabStateContainer2);
  function PluginsTabStateContainer2() {
    var _this;
    _classCallCheck$3(this, PluginsTabStateContainer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$3(_this), "state", {
      selected: 0
    });
    _defineProperty$2(_assertThisInitialized$3(_this), "selectPlugin", function(index8) {
      _this.setState({
        selected: index8
      });
    });
    return _this;
  }
  return PluginsTabStateContainer2;
}(Container);
function valueRenderer(raw) {
  if (typeof (arguments.length <= 1 ? void 0 : arguments[1]) === "function") {
    return "func";
  }
  return raw;
}
function PluginState(props) {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Heading, null, "Plugin State"), /* @__PURE__ */ React.createElement(JSONTree, {
    data: props.pluginState,
    valueRenderer
  }));
}
function PluginsTab() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer, PluginsTabStateContainer]
  }, function(editorState, pluginsTabState) {
    var state = editorState.state.state;
    var plugins = state.plugins;
    var selectedPlugin = plugins[pluginsTabState.state.selected];
    var selectedPluginState = selectedPlugin.getState(state);
    return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
      noPaddings: true
    }, /* @__PURE__ */ React.createElement(List, {
      items: plugins,
      getKey: function getKey(plugin) {
        return plugin.key;
      },
      title: function title(plugin) {
        return plugin.key;
      },
      isSelected: function isSelected(plugin, index8) {
        return pluginsTabState.state.selected === index8;
      },
      isDimmed: function isDimmed(plugin) {
        return !plugin.getState(state);
      },
      onListItemClick: function onListItemClick(plugin, index8) {
        return pluginsTabState.selectPlugin(index8);
      }
    })), /* @__PURE__ */ React.createElement(SplitViewCol, {
      grow: true,
      sep: true
    }, selectedPluginState ? /* @__PURE__ */ React.createElement(PluginState, {
      pluginState: selectedPluginState
    }) : /* @__PURE__ */ React.createElement(InfoPanel, null, "Plugin doesn't have any state")));
  });
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function() {
    var Super = _getPrototypeOf$2(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result2);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StructureTabStateContainer = /* @__PURE__ */ function(_Container) {
  _inherits$2(StructureTabStateContainer2, _Container);
  var _super = _createSuper$2(StructureTabStateContainer2);
  function StructureTabStateContainer2() {
    var _this;
    _classCallCheck$2(this, StructureTabStateContainer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$2(_this), "state", {
      selectedNode: null
    });
    _defineProperty$1(_assertThisInitialized$2(_this), "selectNode", function(_ref) {
      var node18 = _ref.node;
      _this.setState({
        selectedNode: node18
      });
    });
    return _this;
  }
  return StructureTabStateContainer2;
}(Container);
var GraphWrapper = newStyled("div")({
  marginTop: "12px"
});
GraphWrapper.displayName = "GraphWrapper";
var BlockNodeWrapper = newStyled("div")({});
BlockNodeWrapper.displayName = "BlockNodeWrapper";
var BlockNodeContentView = newStyled("div")({
  padding: "0 12px",
  boxSizing: "border-box",
  borderLeft: "1px solid ".concat(mainTheme.white20),
  borderRight: "1px solid ".concat(mainTheme.white20)
});
BlockNodeContentView.displayName = "BlockNodeContentView";
var BlockNodeContentViewWithInline = newStyled("div")({
  padding: "0 12px",
  display: "flex",
  width: "100%",
  boxSizing: "border-box",
  borderLeft: "1px solid ".concat(mainTheme.white20),
  borderRight: "1px solid ".concat(mainTheme.white20),
  flexWrap: "wrap"
});
BlockNodeContentViewWithInline.displayName = "BlockNodeContentViewWithInline";
var BlockNodeView = newStyled("div")({
  width: "100%",
  marginBottom: "3px",
  boxSizing: "border-box",
  display: "flex",
  "&:hover": {
    cursor: "pointer"
  }
}, function(_ref) {
  var bg2 = _ref.bg;
  return {
    background: bg2
  };
});
BlockNodeView.displayName = "BlockNodeView";
var Side = newStyled("div")({
  padding: "3px 6px",
  background: "rgba(255, 255, 255, 0.3)"
});
Side.displayName = "Side";
var Center = newStyled("div")({
  flexGrow: 1,
  padding: "3px 9px",
  whiteSpace: "pre"
});
Center.displayName = "Center";
var InlineNodeView = newStyled("div")({
  flexGrow: 1,
  marginBottom: "3px",
  display: "flex",
  boxSizing: "border-box",
  "&:hover": {
    cursor: "pointer"
  }
}, function(_ref2) {
  var bg2 = _ref2.bg;
  return {
    background: bg2
  };
});
InlineNodeView.displayName = "InlineNodeView";
function BlockNodeContent(props) {
  if (!props.content || !props.content.content || !props.content.content.length)
    return null;
  var content2 = props.content.content;
  if (content2[0].isBlock) {
    var _startPos = props.startPos + 1;
    return /* @__PURE__ */ React.createElement(BlockNodeContentView, null, content2.map(function(childNode, index8) {
      var pos = _startPos;
      _startPos += childNode.nodeSize;
      return /* @__PURE__ */ React.createElement(BlockNode, {
        key: index8,
        node: childNode,
        colors: props.colors,
        onNodeSelected: props.onNodeSelected,
        startPos: pos
      });
    }));
  }
  var startPos = props.startPos;
  return /* @__PURE__ */ React.createElement(BlockNodeContentViewWithInline, null, content2.map(function(childNode, index8) {
    var pos = startPos;
    startPos += childNode.nodeSize;
    return /* @__PURE__ */ React.createElement(InlineNode, {
      key: index8,
      index: index8,
      node: childNode,
      bg: props.colors[childNode.type.name],
      onNodeSelected: props.onNodeSelected,
      startPos: pos
    });
  }));
}
function BlockNode(props) {
  var colors2 = props.colors, node18 = props.node, startPos = props.startPos;
  var color = colors2[node18.type.name];
  return /* @__PURE__ */ React.createElement(BlockNodeWrapper, null, /* @__PURE__ */ React.createElement(BlockNodeView, {
    bg: color,
    onClick: function onClick() {
      return props.onNodeSelected({
        node: node18
      });
    }
  }, /* @__PURE__ */ React.createElement(Side, null, startPos), /* @__PURE__ */ React.createElement(Center, null, node18.type.name), /* @__PURE__ */ React.createElement(Side, null, startPos + node18.nodeSize - 1)), /* @__PURE__ */ React.createElement(BlockNodeContent, {
    content: node18.content,
    colors: colors2,
    onNodeSelected: props.onNodeSelected,
    startPos
  }));
}
function InlineNode(props) {
  var node18 = props.node, bg2 = props.bg, startPos = props.startPos, index8 = props.index;
  var marks9 = node18.marks.length === 1 ? " - [".concat(node18.marks[0].type.name, "]") : node18.marks.length > 1 ? " - [".concat(node18.marks.length, " marks]") : "";
  return /* @__PURE__ */ React.createElement(InlineNodeView, {
    onClick: function onClick() {
      return props.onNodeSelected({
        node: node18
      });
    },
    bg: bg2
  }, index8 === 0 ? /* @__PURE__ */ React.createElement(Side, null, startPos) : null, /* @__PURE__ */ React.createElement(Center, null, node18.type.name, " ", marks9), /* @__PURE__ */ React.createElement(Side, null, startPos + node18.nodeSize));
}
function GraphTab() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer, StructureTabStateContainer]
  }, function(editorState, structureTabState) {
    var _editorState$state = editorState.state, state = _editorState$state.state, nodeColors = _editorState$state.nodeColors;
    var selectedNode = structureTabState.state.selectedNode;
    var selected = selectedNode ? selectedNode : state.doc;
    return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
      grow: true
    }, /* @__PURE__ */ React.createElement(Heading, null, "Current Doc"), /* @__PURE__ */ React.createElement(GraphWrapper, null, /* @__PURE__ */ React.createElement(BlockNode, {
      colors: nodeColors,
      node: state.doc,
      startPos: 0,
      onNodeSelected: structureTabState.selectNode
    }))), /* @__PURE__ */ React.createElement(SplitViewCol, {
      sep: true,
      minWidth: 200,
      maxWidth: 300
    }, /* @__PURE__ */ React.createElement(HeadingWithButton, null, /* @__PURE__ */ React.createElement(Heading, null, "Node Info"), /* @__PURE__ */ React.createElement(HeadingButton, {
      onClick: function onClick() {
        return console.log(selected);
      }
    }, "Log Node")), /* @__PURE__ */ React.createElement(JSONTree, {
      data: selected.toJSON(),
      hideRoot: true,
      shouldExpandNode: function shouldExpandNode() {
        return selected.type.name !== "doc" ? true : false;
      }
    })));
  });
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function() {
    var Super = _getPrototypeOf$1(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result2);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
var ActionButton = newStyled("button")({
  padding: "6px 10px",
  fontWeight: 400,
  letterSpacing: "1px",
  fontSize: "11px",
  color: mainTheme.white80,
  background: mainTheme.white10,
  textTransform: "uppercase",
  transition: "background 0.3s, color 0.3s",
  borderRadius: "2px",
  border: "none",
  "& + &": {
    marginLeft: "4px"
  },
  "&:hover": {
    background: mainTheme.main40,
    color: mainTheme.white,
    cursor: "pointer"
  },
  "&:focus": {
    outline: "none"
  },
  "&:active": {
    background: mainTheme.main60
  }
});
ActionButton.displayName = "ActionButton";
var ListItem = newStyled("div")({
  height: "24px",
  lineHeight: "24px",
  display: "flex",
  width: "100%"
});
ListItem.displayName = "ListItem";
var ListItemTitle = newStyled("div")({
  flexGrow: 1
});
ListItemTitle.displayName = "ListItemTitle";
function SnapshotsList(_ref) {
  var snapshots = _ref.snapshots, deleteSnapshot = _ref.deleteSnapshot, loadSnapshot = _ref.loadSnapshot;
  return /* @__PURE__ */ React.createElement(List, {
    getKey: function getKey(item) {
      return item.name + item.timestamp;
    },
    items: snapshots,
    title: function title(item) {
      return /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemTitle, null, item.name), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(ActionButton, {
        onClick: function onClick() {
          return deleteSnapshot(item);
        }
      }, "delete"), /* @__PURE__ */ React.createElement(ActionButton, {
        onClick: function onClick() {
          return loadSnapshot(item);
        }
      }, "restore")));
    }
  });
}
var SnapshotTab = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(SnapshotTab2, _React$Component);
  var _super = _createSuper$1(SnapshotTab2);
  function SnapshotTab2() {
    _classCallCheck$1(this, SnapshotTab2);
    return _super.apply(this, arguments);
  }
  _createClass$1(SnapshotTab2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return this.props.snapshots !== nextProps.snapshots;
    }
  }, {
    key: "render",
    value: function render4() {
      var _this$props = this.props, snapshots = _this$props.snapshots, loadSnapshot = _this$props.loadSnapshot, deleteSnapshot = _this$props.deleteSnapshot;
      return /* @__PURE__ */ React.createElement(SplitView, null, /* @__PURE__ */ React.createElement(SplitViewCol, {
        noPaddings: true,
        grow: true
      }, snapshots && snapshots.length ? /* @__PURE__ */ React.createElement(SnapshotsList, {
        snapshots,
        loadSnapshot,
        deleteSnapshot
      }) : /* @__PURE__ */ React.createElement(InfoPanel, null, 'No saved snapshots yet. Press "Save Snapshot" button to add one.')));
    }
  }]);
  return SnapshotTab2;
}(React.Component);
function SnapshotsTabContainer() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [EditorStateContainer]
  }, function(_ref2) {
    var snapshots = _ref2.state.snapshots, loadSnapshot = _ref2.loadSnapshot, deleteSnapshot = _ref2.deleteSnapshot;
    return /* @__PURE__ */ React.createElement(SnapshotTab, {
      snapshots,
      loadSnapshot,
      deleteSnapshot
    });
  });
}
var CSSReset = newStyled("div")({
  fontSize: "100%",
  lineHeight: 1,
  "& li + li": {
    margin: 0
  }
});
CSSReset.displayName = "CSSReset";
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor2 = props[i];
    descriptor2.enumerable = descriptor2.enumerable || false;
    descriptor2.configurable = true;
    if ("value" in descriptor2)
      descriptor2.writable = true;
    Object.defineProperty(target, descriptor2.key, descriptor2);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAQAAAACNCElAAAAxklEQVRIx+2Vuw3DMAxEXWUD9VrKvTYJRzAygWpPkSVcBlDtJS6Fg8AQqQ+lAEECXU08iid+pmnoTwWDKzbU6IEbLnkYQaMlD9uA6iqAUArQwDBgX4T1Z+uF4Q4PB/sZmH/1e1BCRZiLhqgWKsJsYjJLUPkDEJKjvmPWwnwCtcKoW4O5VnpTFmaVb8o3LXONOiZAcI3aYe5UIFXiUmv77doOc7oUpDoozLU5iiPFqYtcW4W01LJP3FEiwzXBLG9SUBNq6Ef0BJ8IApq+rItIAAAAAElFTkSuQmCC";
var NodePickerStyled = newStyled("div")({
  position: "absolute",
  pointerEvents: "none",
  top: 0,
  left: 0,
  background: "rgba(0, 0, 255, 0.3)",
  zIndex: 99999,
  cursor: "pointer"
}, function(_ref) {
  var nodePicker = _ref.nodePicker;
  return {
    transform: "translateX(".concat(nodePicker.left, "px) translateY(").concat(nodePicker.top, "px)"),
    display: nodePicker.top && nodePicker.left ? "block" : "none",
    width: "".concat(nodePicker.width, "px"),
    height: "".concat(nodePicker.height, "px")
  };
});
NodePickerStyled.displayName = "NodePickerStyled";
var NodePicker = /* @__PURE__ */ function(_React$Component) {
  _inherits(NodePicker2, _React$Component);
  var _super = _createSuper(NodePicker2);
  function NodePicker2() {
    var _this;
    _classCallCheck(this, NodePicker2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "handleMouseMove", function(e) {
      if (!_this.props.nodePicker.active)
        return;
      _this.props.onMouseMove(e.target);
    });
    _defineProperty(_assertThisInitialized(_this), "handleNodeClick", function(e) {
      if (!_this.props.nodePicker.active)
        return;
      e.preventDefault();
      _this.props.onSelect(e.target);
    });
    _defineProperty(_assertThisInitialized(_this), "closePicker", function() {
      if (!_this.props.nodePicker.active)
        return;
      _this.props.onClose();
    });
    return _this;
  }
  _createClass(NodePicker2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.nodePicker.active) {
        this.initEventHandlers();
      }
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.destroyEventHandlers();
      if (nextProps.nodePicker.active) {
        this.initEventHandlers();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.destroyEventHandlers();
    }
  }, {
    key: "initEventHandlers",
    value: function initEventHandlers() {
      document.addEventListener("mousemove", this.handleMouseMove);
      document.addEventListener("click", this.handleNodeClick);
      document.addEventListener("keydown", this.closePicker);
    }
  }, {
    key: "destroyEventHandlers",
    value: function destroyEventHandlers() {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("click", this.handleNodeClick);
      document.removeEventListener("keydown", this.closePicker);
    }
  }, {
    key: "render",
    value: function render4() {
      return /* @__PURE__ */ React.createElement(NodePickerStyled, {
        nodePicker: this.props.nodePicker
      });
    }
  }]);
  return NodePicker2;
}(React.Component);
var NodePickerTrigger = newStyled("div")({
  position: "absolute",
  right: "4px",
  top: "-28px",
  width: "24px",
  height: "24px",
  borderRadius: "3px",
  "&:hover": {
    backgroundColor: mainTheme.main80,
    cursor: "pointer"
  }
}, function(_ref2) {
  var isActive = _ref2.isActive;
  return {
    background: "".concat(isActive ? mainTheme.main : mainTheme.main60, ' url("').concat(icon, '")'),
    backgroundSize: "20px 20px",
    backgroundRepeat: "none",
    backgroundPosition: "50% 50%"
  };
});
NodePickerTrigger.displayName = "NodePickerTrigger";
var SaveSnapshotButton = newStyled("div")({
  position: "absolute",
  right: "32px",
  top: "-28px",
  color: mainTheme.white,
  background: mainTheme.main60,
  fontSize: "12px",
  lineHeight: "25px",
  padding: "0 6px",
  height: "24px",
  backgroundSize: "20px 20px",
  backgroundRepeat: "none",
  backgroundPosition: "50% 50%",
  borderRadius: "3px",
  "&:hover": {
    backgroundColor: mainTheme.main80,
    cursor: "pointer"
  }
});
SaveSnapshotButton.displayName = "SaveSnapshotButton";
var DockContainer = newStyled("div")({
  width: "100%",
  height: "100%",
  overflow: "hidden",
  background: mainTheme.mainBg,
  fontFamily: "Helvetica Neue, Calibri Light, Roboto, sans-serif",
  fontSize: "13px"
});
DockContainer.displayName = "DockContainer";
var CloseButton = newStyled("button")({
  background: "none",
  border: "none",
  position: "absolute",
  right: 0,
  color: mainTheme.white60,
  fontSize: "18px",
  "&:hover": {
    cursor: "pointer",
    background: mainTheme.white05,
    color: mainTheme.white
  },
  "&:focus": {
    outline: "none"
  }
});
CloseButton.displayName = "CloseButton";
function DevToolsExpanded() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [GlobalStateContainer]
  }, function(globalState) {
    var _globalState$state = globalState.state, defaultSize = _globalState$state.defaultSize, tabIndex = _globalState$state.tabIndex;
    var toggleDevTools = globalState.toggleDevTools, updateBodyMargin = globalState.updateBodyMargin, selectTab = globalState.selectTab;
    return /* @__PURE__ */ React.createElement(CSSReset, null, /* @__PURE__ */ React.createElement(Subscribe, {
      to: [EditorStateContainer]
    }, function(_ref) {
      var nodePicker = _ref.state.nodePicker, deactivatePicker = _ref.deactivatePicker, updateNodePickerPossition = _ref.updateNodePickerPossition, nodePickerSelect = _ref.nodePickerSelect;
      return /* @__PURE__ */ React.createElement(NodePicker, {
        nodePicker,
        onClose: deactivatePicker,
        onMouseMove: updateNodePickerPossition,
        onSelect: function onSelect(target) {
          nodePickerSelect(target);
          selectTab(0);
        }
      });
    }), /* @__PURE__ */ React.createElement(_default$1, {
      position: "bottom",
      dimMode: "none",
      isVisible: true,
      defaultSize,
      onSizeChange: updateBodyMargin
    }, function() {
      return /* @__PURE__ */ React.createElement(DockContainer, null, /* @__PURE__ */ React.createElement(CloseButton, {
        onClick: toggleDevTools
      }, "\xD7"), /* @__PURE__ */ React.createElement(Subscribe, {
        to: [EditorStateContainer]
      }, function(_ref2) {
        var nodePicker = _ref2.state.nodePicker, deactivatePicker = _ref2.deactivatePicker, activatePicker = _ref2.activatePicker;
        return /* @__PURE__ */ React.createElement(NodePickerTrigger, {
          onClick: nodePicker.active ? deactivatePicker : activatePicker,
          isActive: nodePicker.active
        });
      }), /* @__PURE__ */ React.createElement(Subscribe, {
        to: [EditorStateContainer]
      }, function(_ref3) {
        var saveSnapshot = _ref3.saveSnapshot;
        return /* @__PURE__ */ React.createElement(SaveSnapshotButton, {
          onClick: saveSnapshot
        }, "Save Snapshot");
      }), /* @__PURE__ */ React.createElement(Tabs, {
        onSelect: selectTab,
        selectedIndex: tabIndex
      }, /* @__PURE__ */ React.createElement(TabList, null, /* @__PURE__ */ React.createElement(Tab, {
        index: "state"
      }, "State"), /* @__PURE__ */ React.createElement(Tab, {
        index: "history"
      }, "History"), /* @__PURE__ */ React.createElement(Tab, {
        index: "plugins"
      }, "Plugins"), /* @__PURE__ */ React.createElement(Tab, {
        index: "schema"
      }, "Schema"), /* @__PURE__ */ React.createElement(Tab, {
        index: "structure"
      }, "Structure"), /* @__PURE__ */ React.createElement(Tab, {
        index: "snapshots"
      }, "Snapshots")), /* @__PURE__ */ React.createElement(TabPanel, null, function(_ref4) {
        var index8 = _ref4.index;
        switch (index8) {
          case "state":
            return /* @__PURE__ */ React.createElement(StateTab, null);
          case "history":
            return /* @__PURE__ */ React.createElement(HistoryView, null);
          case "plugins":
            return /* @__PURE__ */ React.createElement(PluginsTab, null);
          case "schema":
            return /* @__PURE__ */ React.createElement(SchemaTabContainer, null);
          case "structure":
            return /* @__PURE__ */ React.createElement(GraphTab, null);
          case "snapshots":
            return /* @__PURE__ */ React.createElement(SnapshotsTabContainer, null);
          default:
            return /* @__PURE__ */ React.createElement(StateTab, null);
        }
      })));
    }));
  });
}
function DevTools() {
  return /* @__PURE__ */ React.createElement(Subscribe, {
    to: [GlobalStateContainer]
  }, function(_ref) {
    var state = _ref.state, toggleDevTools = _ref.toggleDevTools;
    return state.opened ? /* @__PURE__ */ React.createElement(DevToolsExpanded, null) : /* @__PURE__ */ React.createElement(DevToolsCollapsed, {
      onClick: toggleDevTools
    });
  });
}
var DEVTOOLS_CLASS_NAME = "__prosemirror-dev-tools__";
function createPlace() {
  var place = document.querySelector(".".concat(DEVTOOLS_CLASS_NAME));
  if (!place) {
    place = document.createElement("div");
    place.className = DEVTOOLS_CLASS_NAME;
    document.body.appendChild(place);
  } else {
    ReactDOM.unmountComponentAtNode(place);
    place.innerHTML = "";
  }
  return place;
}
function applyDevTools(editorView, props) {
  var place = createPlace();
  var editorState = new EditorStateContainer(editorView, props);
  ReactDOM.render(/* @__PURE__ */ React.createElement(Provider, {
    inject: [editorState]
  }, /* @__PURE__ */ React.createElement(DevTools, null)), place);
}
var getInsertedRanges = ({ mapping }) => {
  const ranges = [];
  mapping.maps.forEach((stepMap, i) => {
    stepMap.forEach((_oldStart, _oldEnd, newStart, newEnd) => {
      ranges.push([
        mapping.slice(i + 1).map(newStart),
        mapping.slice(i + 1).map(newEnd)
      ]);
    });
  });
  return ranges;
};
const pluginKey = new PluginKey_1(
  "PROSEMIRROR_INVISIBLES_PLUGIN"
);
const PROSEMIRROR_INVISIBLES_ACTION = "PM_INVISIBLES_ACTION";
const getActionFromTransaction = (tr) => tr.getMeta(PROSEMIRROR_INVISIBLES_ACTION);
const SET_ACTIVE_STATE = "SET_ACTIVE_STATE";
const setActiveStateAction = (isActive) => ({
  type: SET_ACTIVE_STATE,
  payload: { isActive }
});
const reducer = (state, action) => {
  if (!action) {
    return state;
  }
  switch (action.type) {
    case SET_ACTIVE_STATE:
      return { ...state, isActive: action.payload.isActive };
    default:
      return state;
  }
};
const toggleActiveState = () => (state, dispatch3) => {
  var _a;
  dispatch3 && dispatch3(
    state.tr.setMeta(
      PROSEMIRROR_INVISIBLES_ACTION,
      setActiveStateAction(!((_a = pluginKey.getState(state)) == null ? void 0 : _a.isActive))
    )
  );
  return true;
};
const setActiveState = (isActive) => (state, dispatch3) => {
  dispatch3 && dispatch3(
    state.tr.setMeta(
      PROSEMIRROR_INVISIBLES_ACTION,
      setActiveStateAction(isActive)
    )
  );
  return true;
};
const commands = { setActiveState, toggleActiveState };
var textBetween15 = (from12, to, doc2) => {
  const positions = [];
  doc2.nodesBetween(from12, to, (node18, pos) => {
    var _a;
    if (node18.isText) {
      const offset2 = Math.max(from12, pos) - pos;
      positions.push({
        pos: pos + offset2,
        text: ((_a = node18.text) == null ? void 0 : _a.slice(offset2, to - pos)) || ""
      });
    }
  });
  return positions;
};
var createDeco = (pos, type) => {
  const createElement = () => {
    const span = document.createElement("span");
    span.classList.add("invisible");
    span.classList.add(`invisible--${type}`);
    return span;
  };
  return Decoration$2.widget(pos, createElement, {
    marks: [],
    key: type
  });
};
var character = (type) => (predicate) => (from12, to, doc2, decos) => textBetween15(from12, to, doc2).reduce(
  (decos1, { pos, text: text8 }) => text8.split("").reduce((decos2, char2, i) => {
    return predicate(char2) ? decos2.add(doc2, [createDeco(pos + i, type)]) : decos2;
  }, decos1),
  decos
);
var node17 = (type, toPosition) => (predicate) => (from12, to, doc2, decos) => {
  let newDecos = decos;
  doc2.nodesBetween(from12, to, (node18, pos) => {
    if (predicate(node18)) {
      const decoPos = toPosition(node18, pos);
      const oldDecos = newDecos.find(
        decoPos,
        decoPos,
        (spec) => spec.key === type
      );
      newDecos = newDecos.remove(oldDecos).add(doc2, [createDeco(decoPos, type)]);
    }
  });
  return newDecos;
};
var space = (predicate = (char2) => char2 === " ") => character("space")(predicate);
const hardBreak = (predicate = (node22) => node22.type === node22.type.schema.nodes.hard_break) => node17("break", (_, pos) => pos)(predicate);
var paragraph = (predicate = (node22) => node22.type === node22.type.schema.nodes.paragraph) => node17("par", (node22, pos) => pos + node22.nodeSize - 1)(predicate);
const createInvisiblesPlugin = (builders, isActive = true) => {
  const addDecosBetween = (from12, to, doc2, decos) => builders.reduce((newDecos, fn) => fn(from12, to, doc2, newDecos), decos);
  return new Plugin_1({
    key: pluginKey,
    state: {
      init: (_, state) => {
        const { from: from12, to } = new AllSelection_1(state.doc);
        return {
          isActive,
          decorations: addDecosBetween(
            from12,
            to,
            state.doc,
            DecorationSet$2.empty
          )
        };
      },
      apply: (tr, pluginState, _, state) => {
        const newPluginState = reducer(
          pluginState,
          getActionFromTransaction(tr)
        );
        if (!tr.docChanged) {
          return newPluginState;
        }
        const decorations = getInsertedRanges(tr).reduce(
          (nextDecos, [from12, to]) => addDecosBetween(from12, to, state.doc, nextDecos),
          newPluginState.decorations.map(tr.mapping, tr.doc)
        );
        return { ...newPluginState, decorations };
      }
    },
    props: {
      decorations: function(state) {
        const { isActive: isActive2, decorations } = this.getState(state);
        return isActive2 ? decorations : DecorationSet$2.empty;
      }
    }
  });
};
var prosemirror = "";
var menu = "";
var style = "";
var invisibles = "";
const mySchema = new Schema$5({
  nodes: addListNodes_1(schema.spec.nodes, "paragraph block*", "block"),
  marks: schema.spec.marks
});
const view = new EditorView$2(document.querySelector("#editor"), {
  state: EditorState_1.create({
    doc: DOMParser$5.fromSchema(mySchema).parse(
      document.querySelector("#content")
    ),
    plugins: [
      ...exampleSetup({ schema: mySchema }),
      createInvisiblesPlugin([hardBreak(), paragraph(), space()])
    ]
  })
});
const toggle = document.getElementById("show-invisibles");
toggle && toggle.addEventListener("change", (event) => {
  const value = event.currentTarget.checked;
  commands.setActiveState(value)(view.state, view.dispatch);
});
window.process = {};
applyDevTools(view);
export { nanoid as n, regenerator as r };
